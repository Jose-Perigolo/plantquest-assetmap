var Gi = Object.defineProperty, Hi = Object.defineProperties;
var Wi = Object.getOwnPropertyDescriptors;
var oi = Object.getOwnPropertySymbols;
var Vi = Object.prototype.hasOwnProperty, qi = Object.prototype.propertyIsEnumerable;
var Lr = (x, C, c) => C in x ? Gi(x, C, { enumerable: !0, configurable: !0, writable: !0, value: c }) : x[C] = c, Ge = (x, C) => {
  for (var c in C || (C = {}))
    Vi.call(C, c) && Lr(x, c, C[c]);
  if (oi)
    for (var c of oi(C))
      qi.call(C, c) && Lr(x, c, C[c]);
  return x;
}, kn = (x, C) => Hi(x, Wi(C));
var yr = (x, C, c) => (Lr(x, typeof C != "symbol" ? C + "" : C, c), c);
var sn = (x, C, c) => new Promise((p, v) => {
  var n = (r) => {
    try {
      s(c.next(r));
    } catch (o) {
      v(o);
    }
  }, i = (r) => {
    try {
      s(c.throw(r));
    } catch (o) {
      v(o);
    }
  }, s = (r) => r.done ? p(r.value) : Promise.resolve(r.value).then(n, i);
  s((c = c.apply(x, C)).next());
});
var commonjsGlobal = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
var leafletSrcExports$1 = {}, leafletSrc = {
  get exports() {
    return leafletSrcExports$1;
  },
  set exports(x) {
    leafletSrcExports$1 = x;
  }
};
/* @preserve
 * Leaflet 1.8.0, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2022 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
var hasRequiredLeafletSrc;
function requireLeafletSrc() {
  return hasRequiredLeafletSrc || (hasRequiredLeafletSrc = 1, function(x, C) {
    (function(c, p) {
      p(C);
    })(commonjsGlobal, function(c) {
      var p = "1.8.0";
      function v(t) {
        var e, w, I, Y;
        for (w = 1, I = arguments.length; w < I; w++) {
          Y = arguments[w];
          for (e in Y)
            t[e] = Y[e];
        }
        return t;
      }
      var n = Object.create || function() {
        function t() {
        }
        return function(e) {
          return t.prototype = e, new t();
        };
      }();
      function i(t, e) {
        var w = Array.prototype.slice;
        if (t.bind)
          return t.bind.apply(t, w.call(arguments, 1));
        var I = w.call(arguments, 2);
        return function() {
          return t.apply(e, I.length ? I.concat(w.call(arguments)) : arguments);
        };
      }
      var s = 0;
      function r(t) {
        return "_leaflet_id" in t || (t._leaflet_id = ++s), t._leaflet_id;
      }
      function o(t, e, w) {
        var I, Y, dt, Nt;
        return Nt = function() {
          I = !1, Y && (dt.apply(w, Y), Y = !1);
        }, dt = function() {
          I ? Y = arguments : (t.apply(w, arguments), setTimeout(Nt, e), I = !0);
        }, dt;
      }
      function u(t, e, w) {
        var I = e[1], Y = e[0], dt = I - Y;
        return t === I && w ? t : ((t - Y) % dt + dt) % dt + Y;
      }
      function a() {
        return !1;
      }
      function f(t, e) {
        if (e === !1)
          return t;
        var w = Math.pow(10, e === void 0 ? 6 : e);
        return Math.round(t * w) / w;
      }
      function y(t) {
        return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
      }
      function T(t) {
        return y(t).split(/\s+/);
      }
      function h(t, e) {
        Object.prototype.hasOwnProperty.call(t, "options") || (t.options = t.options ? n(t.options) : {});
        for (var w in e)
          t.options[w] = e[w];
        return t.options;
      }
      function _(t, e, w) {
        var I = [];
        for (var Y in t)
          I.push(encodeURIComponent(w ? Y.toUpperCase() : Y) + "=" + encodeURIComponent(t[Y]));
        return (!e || e.indexOf("?") === -1 ? "?" : "&") + I.join("&");
      }
      var g = /\{ *([\w_ -]+) *\}/g;
      function S(t, e) {
        return t.replace(g, function(w, I) {
          var Y = e[I];
          if (Y === void 0)
            throw new Error("No value provided for variable " + w);
          return typeof Y == "function" && (Y = Y(e)), Y;
        });
      }
      var d = Array.isArray || function(t) {
        return Object.prototype.toString.call(t) === "[object Array]";
      };
      function b(t, e) {
        for (var w = 0; w < t.length; w++)
          if (t[w] === e)
            return w;
        return -1;
      }
      var k = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function O(t) {
        return window["webkit" + t] || window["moz" + t] || window["ms" + t];
      }
      var A = 0;
      function l(t) {
        var e = +/* @__PURE__ */ new Date(), w = Math.max(0, 16 - (e - A));
        return A = e + w, window.setTimeout(t, w);
      }
      var E = window.requestAnimationFrame || O("RequestAnimationFrame") || l, M = window.cancelAnimationFrame || O("CancelAnimationFrame") || O("CancelRequestAnimationFrame") || function(t) {
        window.clearTimeout(t);
      };
      function B(t, e, w) {
        if (w && E === l)
          t.call(e);
        else
          return E.call(window, i(t, e));
      }
      function X(t) {
        t && M.call(window, t);
      }
      var K = {
        __proto__: null,
        extend: v,
        create: n,
        bind: i,
        get lastId() {
          return s;
        },
        stamp: r,
        throttle: o,
        wrapNum: u,
        falseFn: a,
        formatNum: f,
        trim: y,
        splitWords: T,
        setOptions: h,
        getParamString: _,
        template: S,
        isArray: d,
        indexOf: b,
        emptyImageUrl: k,
        requestFn: E,
        cancelFn: M,
        requestAnimFrame: B,
        cancelAnimFrame: X
      };
      function D() {
      }
      D.extend = function(t) {
        var e = function() {
          h(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks();
        }, w = e.__super__ = this.prototype, I = n(w);
        I.constructor = e, e.prototype = I;
        for (var Y in this)
          Object.prototype.hasOwnProperty.call(this, Y) && Y !== "prototype" && Y !== "__super__" && (e[Y] = this[Y]);
        return t.statics && v(e, t.statics), t.includes && (j(t.includes), v.apply(null, [I].concat(t.includes))), v(I, t), delete I.statics, delete I.includes, I.options && (I.options = w.options ? n(w.options) : {}, v(I.options, t.options)), I._initHooks = [], I.callInitHooks = function() {
          if (!this._initHooksCalled) {
            w.callInitHooks && w.callInitHooks.call(this), this._initHooksCalled = !0;
            for (var dt = 0, Nt = I._initHooks.length; dt < Nt; dt++)
              I._initHooks[dt].call(this);
          }
        }, e;
      }, D.include = function(t) {
        var e = this.prototype.options;
        return v(this.prototype, t), t.options && (this.prototype.options = e, this.mergeOptions(t.options)), this;
      }, D.mergeOptions = function(t) {
        return v(this.prototype.options, t), this;
      }, D.addInitHook = function(t) {
        var e = Array.prototype.slice.call(arguments, 1), w = typeof t == "function" ? t : function() {
          this[t].apply(this, e);
        };
        return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(w), this;
      };
      function j(t) {
        if (!(typeof L == "undefined" || !L || !L.Mixin)) {
          t = d(t) ? t : [t];
          for (var e = 0; e < t.length; e++)
            t[e] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
        }
      }
      var Z = {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function(t, e, w) {
          if (typeof t == "object")
            for (var I in t)
              this._on(I, t[I], e);
          else {
            t = T(t);
            for (var Y = 0, dt = t.length; Y < dt; Y++)
              this._on(t[Y], e, w);
          }
          return this;
        },
        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object. This includes implicitly attached events.
         */
        off: function(t, e, w) {
          if (!arguments.length)
            delete this._events;
          else if (typeof t == "object")
            for (var I in t)
              this._off(I, t[I], e);
          else {
            t = T(t);
            for (var Y = arguments.length === 1, dt = 0, Nt = t.length; dt < Nt; dt++)
              Y ? this._off(t[dt]) : this._off(t[dt], e, w);
          }
          return this;
        },
        // attach listener (without syntactic sugar now)
        _on: function(t, e, w) {
          if (typeof e != "function") {
            console.warn("wrong listener type: " + typeof e);
            return;
          }
          this._events = this._events || {};
          var I = this._events[t];
          I || (I = [], this._events[t] = I), w === this && (w = void 0);
          for (var Y = { fn: e, ctx: w }, dt = I, Nt = 0, Kt = dt.length; Nt < Kt; Nt++)
            if (dt[Nt].fn === e && dt[Nt].ctx === w)
              return;
          dt.push(Y);
        },
        _off: function(t, e, w) {
          var I, Y, dt;
          if (this._events && (I = this._events[t], !!I)) {
            if (arguments.length === 1) {
              if (this._firingCount)
                for (Y = 0, dt = I.length; Y < dt; Y++)
                  I[Y].fn = a;
              delete this._events[t];
              return;
            }
            if (w === this && (w = void 0), typeof e != "function") {
              console.warn("wrong listener type: " + typeof e);
              return;
            }
            for (Y = 0, dt = I.length; Y < dt; Y++) {
              var Nt = I[Y];
              if (Nt.ctx === w && Nt.fn === e) {
                this._firingCount && (Nt.fn = a, this._events[t] = I = I.slice()), I.splice(Y, 1);
                return;
              }
            }
            console.warn("listener not found");
          }
        },
        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide a data
        // object — the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function(t, e, w) {
          if (!this.listens(t, w))
            return this;
          var I = v({}, e, {
            type: t,
            target: this,
            sourceTarget: e && e.sourceTarget || this
          });
          if (this._events) {
            var Y = this._events[t];
            if (Y) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var dt = 0, Nt = Y.length; dt < Nt; dt++) {
                var Kt = Y[dt];
                Kt.fn.call(Kt.ctx || this, I);
              }
              this._firingCount--;
            }
          }
          return w && this._propagateEvent(I), this;
        },
        // @method listens(type: String, propagate?: Boolean): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
        listens: function(t, e) {
          typeof t != "string" && console.warn('"string" type argument expected');
          var w = this._events && this._events[t];
          if (w && w.length)
            return !0;
          if (e) {
            for (var I in this._eventParents)
              if (this._eventParents[I].listens(t, e))
                return !0;
          }
          return !1;
        },
        // @method once(…): this
        // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
        once: function(t, e, w) {
          if (typeof t == "object") {
            for (var I in t)
              this.once(I, t[I], e);
            return this;
          }
          var Y = i(function() {
            this.off(t, e, w).off(t, Y, w);
          }, this);
          return this.on(t, e, w).on(t, Y, w);
        },
        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function(t) {
          return this._eventParents = this._eventParents || {}, this._eventParents[r(t)] = t, this;
        },
        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function(t) {
          return this._eventParents && delete this._eventParents[r(t)], this;
        },
        _propagateEvent: function(t) {
          for (var e in this._eventParents)
            this._eventParents[e].fire(t.type, v({
              layer: t.target,
              propagatedFrom: t.target
            }, t), !0);
        }
      };
      Z.addEventListener = Z.on, Z.removeEventListener = Z.clearAllEventListeners = Z.off, Z.addOneTimeEventListener = Z.once, Z.fireEvent = Z.fire, Z.hasEventListeners = Z.listens;
      var tt = D.extend(Z);
      function nt(t, e, w) {
        this.x = w ? Math.round(t) : t, this.y = w ? Math.round(e) : e;
      }
      var ct = Math.trunc || function(t) {
        return t > 0 ? Math.floor(t) : Math.ceil(t);
      };
      nt.prototype = {
        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function() {
          return new nt(this.x, this.y);
        },
        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function(t) {
          return this.clone()._add(ut(t));
        },
        _add: function(t) {
          return this.x += t.x, this.y += t.y, this;
        },
        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function(t) {
          return this.clone()._subtract(ut(t));
        },
        _subtract: function(t) {
          return this.x -= t.x, this.y -= t.y, this;
        },
        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function(t) {
          return this.clone()._divideBy(t);
        },
        _divideBy: function(t) {
          return this.x /= t, this.y /= t, this;
        },
        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function(t) {
          return this.clone()._multiplyBy(t);
        },
        _multiplyBy: function(t) {
          return this.x *= t, this.y *= t, this;
        },
        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function(t) {
          return new nt(this.x * t.x, this.y * t.y);
        },
        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function(t) {
          return new nt(this.x / t.x, this.y / t.y);
        },
        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function() {
          return this.clone()._round();
        },
        _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        },
        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function() {
          return this.clone()._floor();
        },
        _floor: function() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        },
        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function() {
          return this.clone()._ceil();
        },
        _ceil: function() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        },
        // @method trunc(): Point
        // Returns a copy of the current point with truncated coordinates (rounded towards zero).
        trunc: function() {
          return this.clone()._trunc();
        },
        _trunc: function() {
          return this.x = ct(this.x), this.y = ct(this.y), this;
        },
        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function(t) {
          t = ut(t);
          var e = t.x - this.x, w = t.y - this.y;
          return Math.sqrt(e * e + w * w);
        },
        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function(t) {
          return t = ut(t), t.x === this.x && t.y === this.y;
        },
        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function(t) {
          return t = ut(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y);
        },
        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function() {
          return "Point(" + f(this.x) + ", " + f(this.y) + ")";
        }
      };
      function ut(t, e, w) {
        return t instanceof nt ? t : d(t) ? new nt(t[0], t[1]) : t == null ? t : typeof t == "object" && "x" in t && "y" in t ? new nt(t.x, t.y) : new nt(t, e, w);
      }
      function V(t, e) {
        if (t)
          for (var w = e ? [t, e] : t, I = 0, Y = w.length; I < Y; I++)
            this.extend(w[I]);
      }
      V.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        extend: function(t) {
          return t = ut(t), !this.min && !this.max ? (this.min = t.clone(), this.max = t.clone()) : (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)), this;
        },
        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function(t) {
          return new nt(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            t
          );
        },
        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function() {
          return new nt(this.min.x, this.max.y);
        },
        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function() {
          return new nt(this.max.x, this.min.y);
        },
        // @method getTopLeft(): Point
        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
        getTopLeft: function() {
          return this.min;
        },
        // @method getBottomRight(): Point
        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
        getBottomRight: function() {
          return this.max;
        },
        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function() {
          return this.max.subtract(this.min);
        },
        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(t) {
          var e, w;
          return typeof t[0] == "number" || t instanceof nt ? t = ut(t) : t = ot(t), t instanceof V ? (e = t.min, w = t.max) : e = w = t, e.x >= this.min.x && w.x <= this.max.x && e.y >= this.min.y && w.y <= this.max.y;
        },
        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function(t) {
          t = ot(t);
          var e = this.min, w = this.max, I = t.min, Y = t.max, dt = Y.x >= e.x && I.x <= w.x, Nt = Y.y >= e.y && I.y <= w.y;
          return dt && Nt;
        },
        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function(t) {
          t = ot(t);
          var e = this.min, w = this.max, I = t.min, Y = t.max, dt = Y.x > e.x && I.x < w.x, Nt = Y.y > e.y && I.y < w.y;
          return dt && Nt;
        },
        isValid: function() {
          return !!(this.min && this.max);
        }
      };
      function ot(t, e) {
        return !t || t instanceof V ? t : new V(t, e);
      }
      function xt(t, e) {
        if (t)
          for (var w = e ? [t, e] : t, I = 0, Y = w.length; I < Y; I++)
            this.extend(w[I]);
      }
      xt.prototype = {
        // @method extend(latlng: LatLng): this
        // Extend the bounds to contain the given point
        // @alternative
        // @method extend(otherBounds: LatLngBounds): this
        // Extend the bounds to contain the given bounds
        extend: function(t) {
          var e = this._southWest, w = this._northEast, I, Y;
          if (t instanceof pt)
            I = t, Y = t;
          else if (t instanceof xt) {
            if (I = t._southWest, Y = t._northEast, !I || !Y)
              return this;
          } else
            return t ? this.extend(at(t) || Ut(t)) : this;
          return !e && !w ? (this._southWest = new pt(I.lat, I.lng), this._northEast = new pt(Y.lat, Y.lng)) : (e.lat = Math.min(I.lat, e.lat), e.lng = Math.min(I.lng, e.lng), w.lat = Math.max(Y.lat, w.lat), w.lng = Math.max(Y.lng, w.lng)), this;
        },
        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(t) {
          var e = this._southWest, w = this._northEast, I = Math.abs(e.lat - w.lat) * t, Y = Math.abs(e.lng - w.lng) * t;
          return new xt(
            new pt(e.lat - I, e.lng - Y),
            new pt(w.lat + I, w.lng + Y)
          );
        },
        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function() {
          return new pt(
            (this._southWest.lat + this._northEast.lat) / 2,
            (this._southWest.lng + this._northEast.lng) / 2
          );
        },
        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function() {
          return this._southWest;
        },
        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function() {
          return this._northEast;
        },
        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function() {
          return new pt(this.getNorth(), this.getWest());
        },
        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function() {
          return new pt(this.getSouth(), this.getEast());
        },
        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function() {
          return this._southWest.lng;
        },
        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function() {
          return this._southWest.lat;
        },
        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function() {
          return this._northEast.lng;
        },
        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function() {
          return this._northEast.lat;
        },
        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(t) {
          typeof t[0] == "number" || t instanceof pt || "lat" in t ? t = at(t) : t = Ut(t);
          var e = this._southWest, w = this._northEast, I, Y;
          return t instanceof xt ? (I = t.getSouthWest(), Y = t.getNorthEast()) : I = Y = t, I.lat >= e.lat && Y.lat <= w.lat && I.lng >= e.lng && Y.lng <= w.lng;
        },
        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function(t) {
          t = Ut(t);
          var e = this._southWest, w = this._northEast, I = t.getSouthWest(), Y = t.getNorthEast(), dt = Y.lat >= e.lat && I.lat <= w.lat, Nt = Y.lng >= e.lng && I.lng <= w.lng;
          return dt && Nt;
        },
        // @method overlaps(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function(t) {
          t = Ut(t);
          var e = this._southWest, w = this._northEast, I = t.getSouthWest(), Y = t.getNorthEast(), dt = Y.lat > e.lat && I.lat < w.lat, Nt = Y.lng > e.lng && I.lng < w.lng;
          return dt && Nt;
        },
        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
        },
        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(t, e) {
          return t ? (t = Ut(t), this._southWest.equals(t.getSouthWest(), e) && this._northEast.equals(t.getNorthEast(), e)) : !1;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this._southWest && this._northEast);
        }
      };
      function Ut(t, e) {
        return t instanceof xt ? t : new xt(t, e);
      }
      function pt(t, e, w) {
        if (isNaN(t) || isNaN(e))
          throw new Error("Invalid LatLng object: (" + t + ", " + e + ")");
        this.lat = +t, this.lng = +e, w !== void 0 && (this.alt = +w);
      }
      pt.prototype = {
        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(t, e) {
          if (!t)
            return !1;
          t = at(t);
          var w = Math.max(
            Math.abs(this.lat - t.lat),
            Math.abs(this.lng - t.lng)
          );
          return w <= (e === void 0 ? 1e-9 : e);
        },
        // @method toString(): String
        // Returns a string representation of the point (for debugging purposes).
        toString: function(t) {
          return "LatLng(" + f(this.lat, t) + ", " + f(this.lng, t) + ")";
        },
        // @method distanceTo(otherLatLng: LatLng): Number
        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
        distanceTo: function(t) {
          return Q.distance(this, at(t));
        },
        // @method wrap(): LatLng
        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
        wrap: function() {
          return Q.wrapLatLng(this);
        },
        // @method toBounds(sizeInMeters: Number): LatLngBounds
        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
        toBounds: function(t) {
          var e = 180 * t / 40075017, w = e / Math.cos(Math.PI / 180 * this.lat);
          return Ut(
            [this.lat - e, this.lng - w],
            [this.lat + e, this.lng + w]
          );
        },
        clone: function() {
          return new pt(this.lat, this.lng, this.alt);
        }
      };
      function at(t, e, w) {
        return t instanceof pt ? t : d(t) && typeof t[0] != "object" ? t.length === 3 ? new pt(t[0], t[1], t[2]) : t.length === 2 ? new pt(t[0], t[1]) : null : t == null ? t : typeof t == "object" && "lat" in t ? new pt(t.lat, "lng" in t ? t.lng : t.lon, t.alt) : e === void 0 ? null : new pt(t, e, w);
      }
      var bt = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function(t, e) {
          var w = this.projection.project(t), I = this.scale(e);
          return this.transformation._transform(w, I);
        },
        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function(t, e) {
          var w = this.scale(e), I = this.transformation.untransform(t, w);
          return this.projection.unproject(I);
        },
        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function(t) {
          return this.projection.project(t);
        },
        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function(t) {
          return this.projection.unproject(t);
        },
        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function(t) {
          return 256 * Math.pow(2, t);
        },
        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function(t) {
          return Math.log(t / 256) / Math.LN2;
        },
        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function(t) {
          if (this.infinite)
            return null;
          var e = this.projection.bounds, w = this.scale(t), I = this.transformation.transform(e.min, w), Y = this.transformation.transform(e.max, w);
          return new V(I, Y);
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.
        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.
        // wrapLng: [min, max],
        // wrapLat: [min, max],
        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: !1,
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function(t) {
          var e = this.wrapLng ? u(t.lng, this.wrapLng, !0) : t.lng, w = this.wrapLat ? u(t.lat, this.wrapLat, !0) : t.lat, I = t.alt;
          return new pt(w, e, I);
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring
        // that its center is within the CRS's bounds.
        // Only accepts actual `L.LatLngBounds` instances, not arrays.
        wrapLatLngBounds: function(t) {
          var e = t.getCenter(), w = this.wrapLatLng(e), I = e.lat - w.lat, Y = e.lng - w.lng;
          if (I === 0 && Y === 0)
            return t;
          var dt = t.getSouthWest(), Nt = t.getNorthEast(), Kt = new pt(dt.lat - I, dt.lng - Y), ee = new pt(Nt.lat - I, Nt.lng - Y);
          return new xt(Kt, ee);
        }
      }, Q = v({}, bt, {
        wrapLng: [-180, 180],
        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see https://rosettacode.org/wiki/Haversine_formula
        R: 6371e3,
        // distance between two geographical points using spherical law of cosines approximation
        distance: function(t, e) {
          var w = Math.PI / 180, I = t.lat * w, Y = e.lat * w, dt = Math.sin((e.lat - t.lat) * w / 2), Nt = Math.sin((e.lng - t.lng) * w / 2), Kt = dt * dt + Math.cos(I) * Math.cos(Y) * Nt * Nt, ee = 2 * Math.atan2(Math.sqrt(Kt), Math.sqrt(1 - Kt));
          return this.R * ee;
        }
      }), At = 6378137, Pt = {
        R: At,
        MAX_LATITUDE: 85.0511287798,
        project: function(t) {
          var e = Math.PI / 180, w = this.MAX_LATITUDE, I = Math.max(Math.min(w, t.lat), -w), Y = Math.sin(I * e);
          return new nt(
            this.R * t.lng * e,
            this.R * Math.log((1 + Y) / (1 - Y)) / 2
          );
        },
        unproject: function(t) {
          var e = 180 / Math.PI;
          return new pt(
            (2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * e,
            t.x * e / this.R
          );
        },
        bounds: function() {
          var t = At * Math.PI;
          return new V([-t, -t], [t, t]);
        }()
      };
      function q(t, e, w, I) {
        if (d(t)) {
          this._a = t[0], this._b = t[1], this._c = t[2], this._d = t[3];
          return;
        }
        this._a = t, this._b = e, this._c = w, this._d = I;
      }
      q.prototype = {
        // @method transform(point: Point, scale?: Number): Point
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts actual `L.Point` instances, not arrays.
        transform: function(t, e) {
          return this._transform(t.clone(), e);
        },
        // destructive transform (faster)
        _transform: function(t, e) {
          return e = e || 1, t.x = e * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t;
        },
        // @method untransform(point: Point, scale?: Number): Point
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
        untransform: function(t, e) {
          return e = e || 1, new nt(
            (t.x / e - this._b) / this._a,
            (t.y / e - this._d) / this._c
          );
        }
      };
      function G(t, e, w, I) {
        return new q(t, e, w, I);
      }
      var lt = v({}, Q, {
        code: "EPSG:3857",
        projection: Pt,
        transformation: function() {
          var t = 0.5 / (Math.PI * Pt.R);
          return G(t, 0.5, -t, 0.5);
        }()
      }), It = v({}, lt, {
        code: "EPSG:900913"
      });
      function Ft(t) {
        return document.createElementNS("http://www.w3.org/2000/svg", t);
      }
      function H(t, e) {
        var w = "", I, Y, dt, Nt, Kt, ee;
        for (I = 0, dt = t.length; I < dt; I++) {
          for (Kt = t[I], Y = 0, Nt = Kt.length; Y < Nt; Y++)
            ee = Kt[Y], w += (Y ? "L" : "M") + ee.x + " " + ee.y;
          w += e ? Et.svg ? "z" : "x" : "";
        }
        return w || "M0 0";
      }
      var F = document.documentElement.style, P = "ActiveXObject" in window, U = P && !document.addEventListener, rt = "msLaunchUri" in navigator && !("documentMode" in document), ft = Ct("webkit"), Ot = Ct("android"), Wt = Ct("android 2") || Ct("android 3"), ce = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), ye = Ot && Ct("Google") && ce < 537 && !("AudioNode" in window), ge = !!window.opera, Ce = !rt && Ct("chrome"), _e = Ct("gecko") && !ft && !ge && !P, je = !Ce && Ct("safari"), Ie = Ct("phantom"), $e = "OTransition" in F, He = navigator.platform.indexOf("Win") === 0, De = P && "transition" in F, _t = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !Wt, jt = "MozPerspective" in F, mt = !window.L_DISABLE_3D && (De || _t || jt) && !$e && !Ie, St = typeof orientation != "undefined" || Ct("mobile"), kt = St && ft, Dt = St && _t, it = !window.PointerEvent && window.MSPointerEvent, qt = !!(window.PointerEvent || it), he = "ontouchstart" in window || !!window.TouchEvent, $ = !window.L_NO_TOUCH && (he || qt), Vt = St && ge, W = St && _e, N = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1, R = function() {
        var t = !1;
        try {
          var e = Object.defineProperty({}, "passive", {
            get: function() {
              t = !0;
            }
          });
          window.addEventListener("testPassiveEventSupport", a, e), window.removeEventListener("testPassiveEventSupport", a, e);
        } catch (w) {
        }
        return t;
      }(), z = function() {
        return !!document.createElement("canvas").getContext;
      }(), et = !!(document.createElementNS && Ft("svg").createSVGRect), ht = !!et && function() {
        var t = document.createElement("div");
        return t.innerHTML = "<svg/>", (t.firstChild && t.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
      }(), yt = !et && function() {
        try {
          var t = document.createElement("div");
          t.innerHTML = '<v:shape adj="1"/>';
          var e = t.firstChild;
          return e.style.behavior = "url(#default#VML)", e && typeof e.adj == "object";
        } catch (w) {
          return !1;
        }
      }();
      function Ct(t) {
        return navigator.userAgent.toLowerCase().indexOf(t) >= 0;
      }
      var Et = {
        ie: P,
        ielt9: U,
        edge: rt,
        webkit: ft,
        android: Ot,
        android23: Wt,
        androidStock: ye,
        opera: ge,
        chrome: Ce,
        gecko: _e,
        safari: je,
        phantom: Ie,
        opera12: $e,
        win: He,
        ie3d: De,
        webkit3d: _t,
        gecko3d: jt,
        any3d: mt,
        mobile: St,
        mobileWebkit: kt,
        mobileWebkit3d: Dt,
        msPointer: it,
        pointer: qt,
        touch: $,
        touchNative: he,
        mobileOpera: Vt,
        mobileGecko: W,
        retina: N,
        passiveEvents: R,
        canvas: z,
        svg: et,
        vml: yt,
        inlineSvg: ht
      }, Zt = Et.msPointer ? "MSPointerDown" : "pointerdown", Qt = Et.msPointer ? "MSPointerMove" : "pointermove", Rt = Et.msPointer ? "MSPointerUp" : "pointerup", Lt = Et.msPointer ? "MSPointerCancel" : "pointercancel", te = {
        touchstart: Zt,
        touchmove: Qt,
        touchend: Rt,
        touchcancel: Lt
      }, Oe = {
        touchstart: Tn,
        touchmove: pn,
        touchend: pn,
        touchcancel: pn
      }, ke = {}, Gt = !1;
      function be(t, e, w) {
        return e === "touchstart" && rn(), Oe[e] ? (w = Oe[e].bind(this, w), t.addEventListener(te[e], w, !1), w) : (console.warn("wrong event specified:", e), L.Util.falseFn);
      }
      function ve(t, e, w) {
        if (!te[e]) {
          console.warn("wrong event specified:", e);
          return;
        }
        t.removeEventListener(te[e], w, !1);
      }
      function we(t) {
        ke[t.pointerId] = t;
      }
      function se(t) {
        ke[t.pointerId] && (ke[t.pointerId] = t);
      }
      function Ue(t) {
        delete ke[t.pointerId];
      }
      function rn() {
        Gt || (document.addEventListener(Zt, we, !0), document.addEventListener(Qt, se, !0), document.addEventListener(Rt, Ue, !0), document.addEventListener(Lt, Ue, !0), Gt = !0);
      }
      function pn(t, e) {
        if (e.pointerType !== (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
          e.touches = [];
          for (var w in ke)
            e.touches.push(ke[w]);
          e.changedTouches = [e], t(e);
        }
      }
      function Tn(t, e) {
        e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH && an(e), pn(t, e);
      }
      function An(t) {
        var e = {}, w, I;
        for (I in t)
          w = t[I], e[I] = w && w.bind ? w.bind(t) : w;
        return t = e, e.type = "dblclick", e.detail = 2, e.isTrusted = !1, e._simulated = !0, e;
      }
      var vn = 200;
      function ln(t, e) {
        t.addEventListener("dblclick", e);
        var w = 0, I;
        function Y(dt) {
          if (dt.detail !== 1) {
            I = dt.detail;
            return;
          }
          if (!(dt.pointerType === "mouse" || dt.sourceCapabilities && !dt.sourceCapabilities.firesTouchEvents)) {
            var Nt = Date.now();
            Nt - w <= vn ? (I++, I === 2 && e(An(dt))) : I = 1, w = Nt;
          }
        }
        return t.addEventListener("click", Y), {
          dblclick: e,
          simDblclick: Y
        };
      }
      function Yt(t, e) {
        t.removeEventListener("dblclick", e.dblclick), t.removeEventListener("click", e.simDblclick);
      }
      var oe = qe(
        ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
      ), ie = qe(
        ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
      ), Ye = ie === "webkitTransition" || ie === "OTransition" ? ie + "End" : "transitionend";
      function We(t) {
        return typeof t == "string" ? document.getElementById(t) : t;
      }
      function Le(t, e) {
        var w = t.style[e] || t.currentStyle && t.currentStyle[e];
        if ((!w || w === "auto") && document.defaultView) {
          var I = document.defaultView.getComputedStyle(t, null);
          w = I ? I[e] : null;
        }
        return w === "auto" ? null : w;
      }
      function Te(t, e, w) {
        var I = document.createElement(t);
        return I.className = e || "", w && w.appendChild(I), I;
      }
      function Re(t) {
        var e = t.parentNode;
        e && e.removeChild(t);
      }
      function en(t) {
        for (; t.firstChild; )
          t.removeChild(t.firstChild);
      }
      function cn(t) {
        var e = t.parentNode;
        e && e.lastChild !== t && e.appendChild(t);
      }
      function J(t) {
        var e = t.parentNode;
        e && e.firstChild !== t && e.insertBefore(t, e.firstChild);
      }
      function st(t, e) {
        if (t.classList !== void 0)
          return t.classList.contains(e);
        var w = Jt(t);
        return w.length > 0 && new RegExp("(^|\\s)" + e + "(\\s|$)").test(w);
      }
      function gt(t, e) {
        if (t.classList !== void 0)
          for (var w = T(e), I = 0, Y = w.length; I < Y; I++)
            t.classList.add(w[I]);
        else if (!st(t, e)) {
          var dt = Jt(t);
          Xt(t, (dt ? dt + " " : "") + e);
        }
      }
      function zt(t, e) {
        t.classList !== void 0 ? t.classList.remove(e) : Xt(t, y((" " + Jt(t) + " ").replace(" " + e + " ", " ")));
      }
      function Xt(t, e) {
        t.className.baseVal === void 0 ? t.className = e : t.className.baseVal = e;
      }
      function Jt(t) {
        return t.correspondingElement && (t = t.correspondingElement), t.className.baseVal === void 0 ? t.className : t.className.baseVal;
      }
      function vt(t, e) {
        "opacity" in t.style ? t.style.opacity = e : "filter" in t.style && Me(t, e);
      }
      function Me(t, e) {
        var w = !1, I = "DXImageTransform.Microsoft.Alpha";
        try {
          w = t.filters.item(I);
        } catch (Y) {
          if (e === 1)
            return;
        }
        e = Math.round(e * 100), w ? (w.Enabled = e !== 100, w.Opacity = e) : t.style.filter += " progid:" + I + "(opacity=" + e + ")";
      }
      function qe(t) {
        for (var e = document.documentElement.style, w = 0; w < t.length; w++)
          if (t[w] in e)
            return t[w];
        return !1;
      }
      function Ke(t, e, w) {
        var I = e || new nt(0, 0);
        t.style[oe] = (Et.ie3d ? "translate(" + I.x + "px," + I.y + "px)" : "translate3d(" + I.x + "px," + I.y + "px,0)") + (w ? " scale(" + w + ")" : "");
      }
      function Ae(t, e) {
        t._leaflet_pos = e, Et.any3d ? Ke(t, e) : (t.style.left = e.x + "px", t.style.top = e.y + "px");
      }
      function le(t) {
        return t._leaflet_pos || new nt(0, 0);
      }
      var gn, pe, bn;
      if ("onselectstart" in document)
        gn = function() {
          Ee(window, "selectstart", an);
        }, pe = function() {
          Ne(window, "selectstart", an);
        };
      else {
        var wn = qe(
          ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
        );
        gn = function() {
          if (wn) {
            var t = document.documentElement.style;
            bn = t[wn], t[wn] = "none";
          }
        }, pe = function() {
          wn && (document.documentElement.style[wn] = bn, bn = void 0);
        };
      }
      function Mn() {
        Ee(window, "dragstart", an);
      }
      function Pn() {
        Ne(window, "dragstart", an);
      }
      var On, Ln;
      function $t(t) {
        for (; t.tabIndex === -1; )
          t = t.parentNode;
        t.style && (ne(), On = t, Ln = t.style.outline, t.style.outline = "none", Ee(window, "keydown", ne));
      }
      function ne() {
        On && (On.style.outline = Ln, On = void 0, Ln = void 0, Ne(window, "keydown", ne));
      }
      function ae(t) {
        do
          t = t.parentNode;
        while ((!t.offsetWidth || !t.offsetHeight) && t !== document.body);
        return t;
      }
      function Be(t) {
        var e = t.getBoundingClientRect();
        return {
          x: e.width / t.offsetWidth || 1,
          y: e.height / t.offsetHeight || 1,
          boundingClientRect: e
        };
      }
      var Fe = {
        __proto__: null,
        TRANSFORM: oe,
        TRANSITION: ie,
        TRANSITION_END: Ye,
        get: We,
        getStyle: Le,
        create: Te,
        remove: Re,
        empty: en,
        toFront: cn,
        toBack: J,
        hasClass: st,
        addClass: gt,
        removeClass: zt,
        setClass: Xt,
        getClass: Jt,
        setOpacity: vt,
        testProp: qe,
        setTransform: Ke,
        setPosition: Ae,
        getPosition: le,
        get disableTextSelection() {
          return gn;
        },
        get enableTextSelection() {
          return pe;
        },
        disableImageDrag: Mn,
        enableImageDrag: Pn,
        preventOutline: $t,
        restoreOutline: ne,
        getSizedParentNode: ae,
        getScale: Be
      };
      function Ee(t, e, w, I) {
        if (e && typeof e == "object")
          for (var Y in e)
            jn(t, Y, e[Y], w);
        else {
          e = T(e);
          for (var dt = 0, Nt = e.length; dt < Nt; dt++)
            jn(t, e[dt], w, I);
        }
        return this;
      }
      var on = "_leaflet_events";
      function Ne(t, e, w, I) {
        if (arguments.length === 1)
          _n(t), delete t[on];
        else if (e && typeof e == "object")
          for (var Y in e)
            un(t, Y, e[Y], w);
        else if (e = T(e), arguments.length === 2)
          _n(t, function(Kt) {
            return b(e, Kt) !== -1;
          });
        else
          for (var dt = 0, Nt = e.length; dt < Nt; dt++)
            un(t, e[dt], w, I);
        return this;
      }
      function _n(t, e) {
        for (var w in t[on]) {
          var I = w.split(/\d/)[0];
          (!e || e(I)) && un(t, I, null, null, w);
        }
      }
      var dn = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
      };
      function jn(t, e, w, I) {
        var Y = e + r(w) + (I ? "_" + r(I) : "");
        if (t[on] && t[on][Y])
          return this;
        var dt = function(Kt) {
          return w.call(I || t, Kt || window.event);
        }, Nt = dt;
        !Et.touchNative && Et.pointer && e.indexOf("touch") === 0 ? dt = be(t, e, dt) : Et.touch && e === "dblclick" ? dt = ln(t, dt) : "addEventListener" in t ? e === "touchstart" || e === "touchmove" || e === "wheel" || e === "mousewheel" ? t.addEventListener(dn[e] || e, dt, Et.passiveEvents ? { passive: !1 } : !1) : e === "mouseenter" || e === "mouseleave" ? (dt = function(Kt) {
          Kt = Kt || window.event, de(t, Kt) && Nt(Kt);
        }, t.addEventListener(dn[e], dt, !1)) : t.addEventListener(e, Nt, !1) : t.attachEvent("on" + e, dt), t[on] = t[on] || {}, t[on][Y] = dt;
      }
      function un(t, e, w, I, Y) {
        Y = Y || e + r(w) + (I ? "_" + r(I) : "");
        var dt = t[on] && t[on][Y];
        if (!dt)
          return this;
        !Et.touchNative && Et.pointer && e.indexOf("touch") === 0 ? ve(t, e, dt) : Et.touch && e === "dblclick" ? Yt(t, dt) : "removeEventListener" in t ? t.removeEventListener(dn[e] || e, dt, !1) : t.detachEvent("on" + e, dt), t[on][Y] = null;
      }
      function Ve(t) {
        return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0, this;
      }
      function Cn(t) {
        return jn(t, "wheel", Ve), this;
      }
      function mn(t) {
        return Ee(t, "mousedown touchstart dblclick contextmenu", Ve), t._leaflet_disable_click = !0, this;
      }
      function an(t) {
        return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this;
      }
      function Tt(t) {
        return an(t), Ve(t), this;
      }
      function Mt(t, e) {
        if (!e)
          return new nt(t.clientX, t.clientY);
        var w = Be(e), I = w.boundingClientRect;
        return new nt(
          // offset.left/top values are in page scale (like clientX/Y),
          // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
          (t.clientX - I.left) / w.x - e.clientLeft,
          (t.clientY - I.top) / w.y - e.clientTop
        );
      }
      var re = Et.win && Et.chrome ? 2 * window.devicePixelRatio : Et.gecko ? window.devicePixelRatio : 1;
      function fe(t) {
        return Et.edge ? t.wheelDeltaY / 2 : (
          // Don't trust window-geometry-based delta
          t.deltaY && t.deltaMode === 0 ? -t.deltaY / re : (
            // Pixels
            t.deltaY && t.deltaMode === 1 ? -t.deltaY * 20 : (
              // Lines
              t.deltaY && t.deltaMode === 2 ? -t.deltaY * 60 : (
                // Pages
                t.deltaX || t.deltaZ ? 0 : (
                  // Skip horizontal/depth wheel events
                  t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : (
                    // Legacy IE pixels
                    t.detail && Math.abs(t.detail) < 32765 ? -t.detail * 20 : (
                      // Legacy Moz lines
                      t.detail ? t.detail / -32765 * 60 : (
                        // Legacy Moz pages
                        0
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      function de(t, e) {
        var w = e.relatedTarget;
        if (!w)
          return !0;
        try {
          for (; w && w !== t; )
            w = w.parentNode;
        } catch (I) {
          return !1;
        }
        return w !== t;
      }
      var me = {
        __proto__: null,
        on: Ee,
        off: Ne,
        stopPropagation: Ve,
        disableScrollPropagation: Cn,
        disableClickPropagation: mn,
        preventDefault: an,
        stop: Tt,
        getMousePosition: Mt,
        getWheelDelta: fe,
        isExternalTarget: de,
        addListener: Ee,
        removeListener: Ne
      }, Ze = tt.extend({
        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function(t, e, w, I) {
          this.stop(), this._el = t, this._inProgress = !0, this._duration = w || 0.25, this._easeOutPower = 1 / Math.max(I || 0.5, 0.2), this._startPos = le(t), this._offset = e.subtract(this._startPos), this._startTime = +/* @__PURE__ */ new Date(), this.fire("start"), this._animate();
        },
        // @method stop()
        // Stops the animation (if currently running).
        stop: function() {
          this._inProgress && (this._step(!0), this._complete());
        },
        _animate: function() {
          this._animId = B(this._animate, this), this._step();
        },
        _step: function(t) {
          var e = +/* @__PURE__ */ new Date() - this._startTime, w = this._duration * 1e3;
          e < w ? this._runFrame(this._easeOut(e / w), t) : (this._runFrame(1), this._complete());
        },
        _runFrame: function(t, e) {
          var w = this._startPos.add(this._offset.multiplyBy(t));
          e && w._round(), Ae(this._el, w), this.fire("step");
        },
        _complete: function() {
          X(this._animId), this._inProgress = !1, this.fire("end");
        },
        _easeOut: function(t) {
          return 1 - Math.pow(1 - t, this._easeOutPower);
        }
      }), xe = tt.extend({
        options: {
          // @section Map State Options
          // @option crs: CRS = L.CRS.EPSG3857
          // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
          // sure what it means.
          crs: lt,
          // @option center: LatLng = undefined
          // Initial geographic center of the map
          center: void 0,
          // @option zoom: Number = undefined
          // Initial map zoom level
          zoom: void 0,
          // @option minZoom: Number = *
          // Minimum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the lowest of their `minZoom` options will be used instead.
          minZoom: void 0,
          // @option maxZoom: Number = *
          // Maximum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the highest of their `maxZoom` options will be used instead.
          maxZoom: void 0,
          // @option layers: Layer[] = []
          // Array of layers that will be added to the map initially
          layers: [],
          // @option maxBounds: LatLngBounds = null
          // When this option is set, the map restricts the view to the given
          // geographical bounds, bouncing the user back if the user tries to pan
          // outside the view. To set the restriction dynamically, use
          // [`setMaxBounds`](#map-setmaxbounds) method.
          maxBounds: void 0,
          // @option renderer: Renderer = *
          // The default method for drawing vector layers on the map. `L.SVG`
          // or `L.Canvas` by default depending on browser support.
          renderer: void 0,
          // @section Animation Options
          // @option zoomAnimation: Boolean = true
          // Whether the map zoom animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          zoomAnimation: !0,
          // @option zoomAnimationThreshold: Number = 4
          // Won't animate zoom if the zoom difference exceeds this value.
          zoomAnimationThreshold: 4,
          // @option fadeAnimation: Boolean = true
          // Whether the tile fade animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          fadeAnimation: !0,
          // @option markerZoomAnimation: Boolean = true
          // Whether markers animate their zoom with the zoom animation, if disabled
          // they will disappear for the length of the animation. By default it's
          // enabled in all browsers that support CSS3 Transitions except Android.
          markerZoomAnimation: !0,
          // @option transform3DLimit: Number = 2^23
          // Defines the maximum size of a CSS translation transform. The default
          // value should not be changed unless a web browser positions layers in
          // the wrong place after doing a large `panBy`.
          transform3DLimit: 8388608,
          // Precision limit of a 32-bit float
          // @section Interaction Options
          // @option zoomSnap: Number = 1
          // Forces the map's zoom level to always be a multiple of this, particularly
          // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
          // By default, the zoom level snaps to the nearest integer; lower values
          // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
          // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
          zoomSnap: 1,
          // @option zoomDelta: Number = 1
          // Controls how much the map's zoom level will change after a
          // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
          // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
          // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
          zoomDelta: 1,
          // @option trackResize: Boolean = true
          // Whether the map automatically handles browser window resize to update itself.
          trackResize: !0
        },
        initialize: function(t, e) {
          e = h(this, e), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(t), this._initLayout(), this._onResize = i(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), e.zoom !== void 0 && (this._zoom = this._limitZoom(e.zoom)), e.center && e.zoom !== void 0 && this.setView(at(e.center), e.zoom, { reset: !0 }), this.callInitHooks(), this._zoomAnimated = ie && Et.any3d && !Et.mobileOpera && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), Ee(this._proxy, Ye, this._catchTransitionEnd, this)), this._addLayers(this.options.layers);
        },
        // @section Methods for modifying map state
        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function(t, e, w) {
          if (e = e === void 0 ? this._zoom : this._limitZoom(e), t = this._limitCenter(at(t), e, this.options.maxBounds), w = w || {}, this._stop(), this._loaded && !w.reset && w !== !0) {
            w.animate !== void 0 && (w.zoom = v({ animate: w.animate }, w.zoom), w.pan = v({ animate: w.animate, duration: w.duration }, w.pan));
            var I = this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, w.zoom) : this._tryAnimatedPan(t, w.pan);
            if (I)
              return clearTimeout(this._sizeTimer), this;
          }
          return this._resetView(t, e), this;
        },
        // @method setZoom(zoom: Number, options?: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function(t, e) {
          return this._loaded ? this.setView(this.getCenter(), t, { zoom: e }) : (this._zoom = t, this);
        },
        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function(t, e) {
          return t = t || (Et.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + t, e);
        },
        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function(t, e) {
          return t = t || (Et.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - t, e);
        },
        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function(t, e, w) {
          var I = this.getZoomScale(e), Y = this.getSize().divideBy(2), dt = t instanceof nt ? t : this.latLngToContainerPoint(t), Nt = dt.subtract(Y).multiplyBy(1 - 1 / I), Kt = this.containerPointToLatLng(Y.add(Nt));
          return this.setView(Kt, e, { zoom: w });
        },
        _getBoundsCenterZoom: function(t, e) {
          e = e || {}, t = t.getBounds ? t.getBounds() : Ut(t);
          var w = ut(e.paddingTopLeft || e.padding || [0, 0]), I = ut(e.paddingBottomRight || e.padding || [0, 0]), Y = this.getBoundsZoom(t, !1, w.add(I));
          if (Y = typeof e.maxZoom == "number" ? Math.min(e.maxZoom, Y) : Y, Y === 1 / 0)
            return {
              center: t.getCenter(),
              zoom: Y
            };
          var dt = I.subtract(w).divideBy(2), Nt = this.project(t.getSouthWest(), Y), Kt = this.project(t.getNorthEast(), Y), ee = this.unproject(Nt.add(Kt).divideBy(2).add(dt), Y);
          return {
            center: ee,
            zoom: Y
          };
        },
        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function(t, e) {
          if (t = Ut(t), !t.isValid())
            throw new Error("Bounds are not valid.");
          var w = this._getBoundsCenterZoom(t, e);
          return this.setView(w.center, w.zoom, e);
        },
        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function(t) {
          return this.fitBounds([[-90, -180], [90, 180]], t);
        },
        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function(t, e) {
          return this.setView(t, this._zoom, { pan: e });
        },
        // @method panBy(offset: Point, options?: Pan options): this
        // Pans the map by a given number of pixels (animated).
        panBy: function(t, e) {
          if (t = ut(t).round(), e = e || {}, !t.x && !t.y)
            return this.fire("moveend");
          if (e.animate !== !0 && !this.getSize().contains(t))
            return this._resetView(this.unproject(this.project(this.getCenter()).add(t)), this.getZoom()), this;
          if (this._panAnim || (this._panAnim = new Ze(), this._panAnim.on({
            step: this._onPanTransitionStep,
            end: this._onPanTransitionEnd
          }, this)), e.noMoveStart || this.fire("movestart"), e.animate !== !1) {
            gt(this._mapPane, "leaflet-pan-anim");
            var w = this._getMapPanePos().subtract(t).round();
            this._panAnim.run(this._mapPane, w, e.duration || 0.25, e.easeLinearity);
          } else
            this._rawPanBy(t), this.fire("move").fire("moveend");
          return this;
        },
        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) performing a smooth
        // pan-zoom animation.
        flyTo: function(t, e, w) {
          if (w = w || {}, w.animate === !1 || !Et.any3d)
            return this.setView(t, e, w);
          this._stop();
          var I = this.project(this.getCenter()), Y = this.project(t), dt = this.getSize(), Nt = this._zoom;
          t = at(t), e = e === void 0 ? Nt : e;
          var Kt = Math.max(dt.x, dt.y), ee = Kt * this.getZoomScale(Nt, e), ue = Y.distanceTo(I) || 1, Pe = 1.42, Xe = Pe * Pe;
          function tn(yn) {
            var _r = yn ? -1 : 1, zi = yn ? ee : Kt, Ui = ee * ee - Kt * Kt + _r * Xe * Xe * ue * ue, Fi = 2 * zi * Xe * ue, Or = Ui / Fi, ii = Math.sqrt(Or * Or + 1) - Or, Zi = ii < 1e-9 ? -18 : Math.log(ii);
            return Zi;
          }
          function Un(yn) {
            return (Math.exp(yn) - Math.exp(-yn)) / 2;
          }
          function Hn(yn) {
            return (Math.exp(yn) + Math.exp(-yn)) / 2;
          }
          function gr(yn) {
            return Un(yn) / Hn(yn);
          }
          var Zn = tn(0);
          function Ar(yn) {
            return Kt * (Hn(Zn) / Hn(Zn + Pe * yn));
          }
          function Ni(yn) {
            return Kt * (Hn(Zn) * gr(Zn + Pe * yn) - Un(Zn)) / Xe;
          }
          function Di(yn) {
            return 1 - Math.pow(1 - yn, 1.5);
          }
          var $i = Date.now(), ni = (tn(1) - Zn) / Pe, Bi = w.duration ? 1e3 * w.duration : 1e3 * ni * 0.8;
          function ri() {
            var yn = (Date.now() - $i) / Bi, _r = Di(yn) * ni;
            yn <= 1 ? (this._flyToFrame = B(ri, this), this._move(
              this.unproject(I.add(Y.subtract(I).multiplyBy(Ni(_r) / ue)), Nt),
              this.getScaleZoom(Kt / Ar(_r), Nt),
              { flyTo: !0 }
            )) : this._move(t, e)._moveEnd(!0);
          }
          return this._moveStart(!0, w.noMoveStart), ri.call(this), this;
        },
        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
        flyToBounds: function(t, e) {
          var w = this._getBoundsCenterZoom(t, e);
          return this.flyTo(w.center, w.zoom, e);
        },
        // @method setMaxBounds(bounds: LatLngBounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function(t) {
          if (t = Ut(t), t.isValid())
            this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds);
          else
            return this.options.maxBounds = null, this.off("moveend", this._panInsideMaxBounds);
          return this.options.maxBounds = t, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds);
        },
        // @method setMinZoom(zoom: Number): this
        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
        setMinZoom: function(t) {
          var e = this.options.minZoom;
          return this.options.minZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(t) : this;
        },
        // @method setMaxZoom(zoom: Number): this
        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
        setMaxZoom: function(t) {
          var e = this.options.maxZoom;
          return this.options.maxZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(t) : this;
        },
        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function(t, e) {
          this._enforcingBounds = !0;
          var w = this.getCenter(), I = this._limitCenter(w, this._zoom, Ut(t));
          return w.equals(I) || this.panTo(I, e), this._enforcingBounds = !1, this;
        },
        // @method panInside(latlng: LatLng, options?: padding options): this
        // Pans the map the minimum amount to make the `latlng` visible. Use
        // padding options to fit the display to more restricted bounds.
        // If `latlng` is already within the (optionally padded) display bounds,
        // the map will not be panned.
        panInside: function(t, e) {
          e = e || {};
          var w = ut(e.paddingTopLeft || e.padding || [0, 0]), I = ut(e.paddingBottomRight || e.padding || [0, 0]), Y = this.project(this.getCenter()), dt = this.project(t), Nt = this.getPixelBounds(), Kt = ot([Nt.min.add(w), Nt.max.subtract(I)]), ee = Kt.getSize();
          if (!Kt.contains(dt)) {
            this._enforcingBounds = !0;
            var ue = dt.subtract(Kt.getCenter()), Pe = Kt.extend(dt).getSize().subtract(ee);
            Y.x += ue.x < 0 ? -Pe.x : Pe.x, Y.y += ue.y < 0 ? -Pe.y : Pe.y, this.panTo(this.unproject(Y), e), this._enforcingBounds = !1;
          }
          return this;
        },
        // @method invalidateSize(options: Zoom/pan options): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.
        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function(t) {
          if (!this._loaded)
            return this;
          t = v({
            animate: !1,
            pan: !0
          }, t === !0 ? { animate: !0 } : t);
          var e = this.getSize();
          this._sizeChanged = !0, this._lastCenter = null;
          var w = this.getSize(), I = e.divideBy(2).round(), Y = w.divideBy(2).round(), dt = I.subtract(Y);
          return !dt.x && !dt.y ? this : (t.animate && t.pan ? this.panBy(dt) : (t.pan && this._rawPanBy(dt), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(i(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
            oldSize: e,
            newSize: w
          }));
        },
        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function() {
          return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop();
        },
        // @section Geolocation methods
        // @method locate(options?: Locate options): this
        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
        // and optionally sets the map view to the user's location with respect to
        // detection accuracy (or to the world view if geolocation failed).
        // Note that, if your page doesn't use HTTPS, this method will fail in
        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
        // See `Locate options` for more details.
        locate: function(t) {
          if (t = this._locateOptions = v({
            timeout: 1e4,
            watch: !1
            // setView: false
            // maxZoom: <Number>
            // maximumAge: 0
            // enableHighAccuracy: false
          }, t), !("geolocation" in navigator))
            return this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            }), this;
          var e = i(this._handleGeolocationResponse, this), w = i(this._handleGeolocationError, this);
          return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, w, t) : navigator.geolocation.getCurrentPosition(e, w, t), this;
        },
        // @method stopLocate(): this
        // Stops watching location previously initiated by `map.locate({watch: true})`
        // and aborts resetting the map view if map.locate was called with
        // `{setView: true}`.
        stopLocate: function() {
          return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this;
        },
        _handleGeolocationError: function(t) {
          if (this._container._leaflet_id) {
            var e = t.code, w = t.message || (e === 1 ? "permission denied" : e === 2 ? "position unavailable" : "timeout");
            this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
              code: e,
              message: "Geolocation error: " + w + "."
            });
          }
        },
        _handleGeolocationResponse: function(t) {
          if (this._container._leaflet_id) {
            var e = t.coords.latitude, w = t.coords.longitude, I = new pt(e, w), Y = I.toBounds(t.coords.accuracy * 2), dt = this._locateOptions;
            if (dt.setView) {
              var Nt = this.getBoundsZoom(Y);
              this.setView(I, dt.maxZoom ? Math.min(Nt, dt.maxZoom) : Nt);
            }
            var Kt = {
              latlng: I,
              bounds: Y,
              timestamp: t.timestamp
            };
            for (var ee in t.coords)
              typeof t.coords[ee] == "number" && (Kt[ee] = t.coords[ee]);
            this.fire("locationfound", Kt);
          }
        },
        // TODO Appropriate docs section?
        // @section Other Methods
        // @method addHandler(name: String, HandlerClass: Function): this
        // Adds a new `Handler` to the map, given its name and constructor function.
        addHandler: function(t, e) {
          if (!e)
            return this;
          var w = this[t] = new e(this);
          return this._handlers.push(w), this.options[t] && w.enable(), this;
        },
        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function() {
          if (this._initEvents(!0), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id)
            throw new Error("Map container is being reused by another instance");
          try {
            delete this._container._leaflet_id, delete this._containerId;
          } catch (e) {
            this._container._leaflet_id = void 0, this._containerId = void 0;
          }
          this._locationWatchId !== void 0 && this.stopLocate(), this._stop(), Re(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (X(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload");
          var t;
          for (t in this._layers)
            this._layers[t].remove();
          for (t in this._panes)
            Re(this._panes[t]);
          return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this;
        },
        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a child of `container`, or
        // as a child of the main map pane if not set.
        createPane: function(t, e) {
          var w = "leaflet-pane" + (t ? " leaflet-" + t.replace("Pane", "") + "-pane" : ""), I = Te("div", w, e || this._mapPane);
          return t && (this._panes[t] = I), I;
        },
        // @section Methods for Getting Map State
        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function() {
          return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter : this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function() {
          return this._zoom;
        },
        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function() {
          var t = this.getPixelBounds(), e = this.unproject(t.getBottomLeft()), w = this.unproject(t.getTopRight());
          return new xt(e, w);
        },
        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function() {
          return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function() {
          return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
        },
        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function(t, e, w) {
          t = Ut(t), w = ut(w || [0, 0]);
          var I = this.getZoom() || 0, Y = this.getMinZoom(), dt = this.getMaxZoom(), Nt = t.getNorthWest(), Kt = t.getSouthEast(), ee = this.getSize().subtract(w), ue = ot(this.project(Kt, I), this.project(Nt, I)).getSize(), Pe = Et.any3d ? this.options.zoomSnap : 1, Xe = ee.x / ue.x, tn = ee.y / ue.y, Un = e ? Math.max(Xe, tn) : Math.min(Xe, tn);
          return I = this.getScaleZoom(Un, I), Pe && (I = Math.round(I / (Pe / 100)) * (Pe / 100), I = e ? Math.ceil(I / Pe) * Pe : Math.floor(I / Pe) * Pe), Math.max(Y, Math.min(dt, I));
        },
        // @method getSize(): Point
        // Returns the current size of the map container (in pixels).
        getSize: function() {
          return (!this._size || this._sizeChanged) && (this._size = new nt(
            this._container.clientWidth || 0,
            this._container.clientHeight || 0
          ), this._sizeChanged = !1), this._size.clone();
        },
        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function(t, e) {
          var w = this._getTopLeftPoint(t, e);
          return new V(w, w.add(this.getSize()));
        },
        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function() {
          return this._checkIfLoaded(), this._pixelOrigin;
        },
        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function(t) {
          return this.options.crs.getProjectedBounds(t === void 0 ? this.getZoom() : t);
        },
        // @section Other Methods
        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function(t) {
          return typeof t == "string" ? this._panes[t] : t;
        },
        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function() {
          return this._panes;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function() {
          return this._container;
        },
        // @section Conversion Methods
        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function(t, e) {
          var w = this.options.crs;
          return e = e === void 0 ? this._zoom : e, w.scale(t) / w.scale(e);
        },
        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function(t, e) {
          var w = this.options.crs;
          e = e === void 0 ? this._zoom : e;
          var I = w.zoom(t * w.scale(e));
          return isNaN(I) ? 1 / 0 : I;
        },
        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function(t, e) {
          return e = e === void 0 ? this._zoom : e, this.options.crs.latLngToPoint(at(t), e);
        },
        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function(t, e) {
          return e = e === void 0 ? this._zoom : e, this.options.crs.pointToLatLng(ut(t), e);
        },
        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function(t) {
          var e = ut(t).add(this.getPixelOrigin());
          return this.unproject(e);
        },
        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function(t) {
          var e = this.project(at(t))._round();
          return e._subtract(this.getPixelOrigin());
        },
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function(t) {
          return this.options.crs.wrapLatLng(at(t));
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring that
        // its center is within the CRS's bounds.
        // By default this means the center longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees, and the majority of the bounds
        // overlaps the CRS's bounds.
        wrapLatLngBounds: function(t) {
          return this.options.crs.wrapLatLngBounds(Ut(t));
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function(t, e) {
          return this.options.crs.distance(at(t), at(e));
        },
        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function(t) {
          return ut(t).subtract(this._getMapPanePos());
        },
        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function(t) {
          return ut(t).add(this._getMapPanePos());
        },
        // @method containerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function(t) {
          var e = this.containerPointToLayerPoint(ut(t));
          return this.layerPointToLatLng(e);
        },
        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function(t) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(at(t)));
        },
        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function(t) {
          return Mt(t, this._container);
        },
        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function(t) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t));
        },
        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function(t) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(t));
        },
        // map initialization methods
        _initContainer: function(t) {
          var e = this._container = We(t);
          if (e) {
            if (e._leaflet_id)
              throw new Error("Map container is already initialized.");
          } else
            throw new Error("Map container not found.");
          Ee(e, "scroll", this._onScroll, this), this._containerId = r(e);
        },
        _initLayout: function() {
          var t = this._container;
          this._fadeAnimated = this.options.fadeAnimation && Et.any3d, gt(t, "leaflet-container" + (Et.touch ? " leaflet-touch" : "") + (Et.retina ? " leaflet-retina" : "") + (Et.ielt9 ? " leaflet-oldie" : "") + (Et.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
          var e = Le(t, "position");
          e !== "absolute" && e !== "relative" && e !== "fixed" && (t.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos();
        },
        _initPanes: function() {
          var t = this._panes = {};
          this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), Ae(this._mapPane, new nt(0, 0)), this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (gt(t.markerPane, "leaflet-zoom-hide"), gt(t.shadowPane, "leaflet-zoom-hide"));
        },
        // private methods that modify map state
        // @section Map state change events
        _resetView: function(t, e) {
          Ae(this._mapPane, new nt(0, 0));
          var w = !this._loaded;
          this._loaded = !0, e = this._limitZoom(e), this.fire("viewprereset");
          var I = this._zoom !== e;
          this._moveStart(I, !1)._move(t, e)._moveEnd(I), this.fire("viewreset"), w && this.fire("load");
        },
        _moveStart: function(t, e) {
          return t && this.fire("zoomstart"), e || this.fire("movestart"), this;
        },
        _move: function(t, e, w, I) {
          e === void 0 && (e = this._zoom);
          var Y = this._zoom !== e;
          return this._zoom = e, this._lastCenter = t, this._pixelOrigin = this._getNewPixelOrigin(t), I ? w && w.pinch && this.fire("zoom", w) : ((Y || w && w.pinch) && this.fire("zoom", w), this.fire("move", w)), this;
        },
        _moveEnd: function(t) {
          return t && this.fire("zoomend"), this.fire("moveend");
        },
        _stop: function() {
          return X(this._flyToFrame), this._panAnim && this._panAnim.stop(), this;
        },
        _rawPanBy: function(t) {
          Ae(this._mapPane, this._getMapPanePos().subtract(t));
        },
        _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function() {
          this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
        },
        _checkIfLoaded: function() {
          if (!this._loaded)
            throw new Error("Set map center and zoom first.");
        },
        // DOM event handling
        // @section Interaction events
        _initEvents: function(t) {
          this._targets = {}, this._targets[r(this._container)] = this;
          var e = t ? Ne : Ee;
          e(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && e(window, "resize", this._onResize, this), Et.any3d && this.options.transform3DLimit && (t ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
        },
        _onResize: function() {
          X(this._resizeRequest), this._resizeRequest = B(
            function() {
              this.invalidateSize({ debounceMoveend: !0 });
            },
            this
          );
        },
        _onScroll: function() {
          this._container.scrollTop = 0, this._container.scrollLeft = 0;
        },
        _onMoveEnd: function() {
          var t = this._getMapPanePos();
          Math.max(Math.abs(t.x), Math.abs(t.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom());
        },
        _findEventTargets: function(t, e) {
          for (var w = [], I, Y = e === "mouseout" || e === "mouseover", dt = t.target || t.srcElement, Nt = !1; dt; ) {
            if (I = this._targets[r(dt)], I && (e === "click" || e === "preclick") && this._draggableMoved(I)) {
              Nt = !0;
              break;
            }
            if (I && I.listens(e, !0) && (Y && !de(dt, t) || (w.push(I), Y)) || dt === this._container)
              break;
            dt = dt.parentNode;
          }
          return !w.length && !Nt && !Y && this.listens(e, !0) && (w = [this]), w;
        },
        _isClickDisabled: function(t) {
          for (; t !== this._container; ) {
            if (t._leaflet_disable_click)
              return !0;
            t = t.parentNode;
          }
        },
        _handleDOMEvent: function(t) {
          var e = t.target || t.srcElement;
          if (!(!this._loaded || e._leaflet_disable_events || t.type === "click" && this._isClickDisabled(e))) {
            var w = t.type;
            w === "mousedown" && $t(e), this._fireDOMEvent(t, w);
          }
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent: function(t, e, w) {
          if (t.type === "click") {
            var I = v({}, t);
            I.type = "preclick", this._fireDOMEvent(I, I.type, w);
          }
          var Y = this._findEventTargets(t, e);
          if (w) {
            for (var dt = [], Nt = 0; Nt < w.length; Nt++)
              w[Nt].listens(e, !0) && dt.push(w[Nt]);
            Y = dt.concat(Y);
          }
          if (Y.length) {
            e === "contextmenu" && an(t);
            var Kt = Y[0], ee = {
              originalEvent: t
            };
            if (t.type !== "keypress" && t.type !== "keydown" && t.type !== "keyup") {
              var ue = Kt.getLatLng && (!Kt._radius || Kt._radius <= 10);
              ee.containerPoint = ue ? this.latLngToContainerPoint(Kt.getLatLng()) : this.mouseEventToContainerPoint(t), ee.layerPoint = this.containerPointToLayerPoint(ee.containerPoint), ee.latlng = ue ? Kt.getLatLng() : this.layerPointToLatLng(ee.layerPoint);
            }
            for (Nt = 0; Nt < Y.length; Nt++)
              if (Y[Nt].fire(e, ee, !0), ee.originalEvent._stopped || Y[Nt].options.bubblingMouseEvents === !1 && b(this._mouseEvents, e) !== -1)
                return;
          }
        },
        _draggableMoved: function(t) {
          return t = t.dragging && t.dragging.enabled() ? t : this, t.dragging && t.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function() {
          for (var t = 0, e = this._handlers.length; t < e; t++)
            this._handlers[t].disable();
        },
        // @section Other Methods
        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function(t, e) {
          return this._loaded ? t.call(e || this, { target: this }) : this.on("load", t, e), this;
        },
        // private methods for getting map state
        _getMapPanePos: function() {
          return le(this._mapPane) || new nt(0, 0);
        },
        _moved: function() {
          var t = this._getMapPanePos();
          return t && !t.equals([0, 0]);
        },
        _getTopLeftPoint: function(t, e) {
          var w = t && e !== void 0 ? this._getNewPixelOrigin(t, e) : this.getPixelOrigin();
          return w.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function(t, e) {
          var w = this.getSize()._divideBy(2);
          return this.project(t, e)._subtract(w)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function(t, e, w) {
          var I = this._getNewPixelOrigin(w, e);
          return this.project(t, e)._subtract(I);
        },
        _latLngBoundsToNewLayerBounds: function(t, e, w) {
          var I = this._getNewPixelOrigin(w, e);
          return ot([
            this.project(t.getSouthWest(), e)._subtract(I),
            this.project(t.getNorthWest(), e)._subtract(I),
            this.project(t.getSouthEast(), e)._subtract(I),
            this.project(t.getNorthEast(), e)._subtract(I)
          ]);
        },
        // layer point of the current center
        _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function(t) {
          return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function(t, e, w) {
          if (!w)
            return t;
          var I = this.project(t, e), Y = this.getSize().divideBy(2), dt = new V(I.subtract(Y), I.add(Y)), Nt = this._getBoundsOffset(dt, w, e);
          return Nt.round().equals([0, 0]) ? t : this.unproject(I.add(Nt), e);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function(t, e) {
          if (!e)
            return t;
          var w = this.getPixelBounds(), I = new V(w.min.add(t), w.max.add(t));
          return t.add(this._getBoundsOffset(I, e));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function(t, e, w) {
          var I = ot(
            this.project(e.getNorthEast(), w),
            this.project(e.getSouthWest(), w)
          ), Y = I.min.subtract(t.min), dt = I.max.subtract(t.max), Nt = this._rebound(Y.x, -dt.x), Kt = this._rebound(Y.y, -dt.y);
          return new nt(Nt, Kt);
        },
        _rebound: function(t, e) {
          return t + e > 0 ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e));
        },
        _limitZoom: function(t) {
          var e = this.getMinZoom(), w = this.getMaxZoom(), I = Et.any3d ? this.options.zoomSnap : 1;
          return I && (t = Math.round(t / I) * I), Math.max(e, Math.min(w, t));
        },
        _onPanTransitionStep: function() {
          this.fire("move");
        },
        _onPanTransitionEnd: function() {
          zt(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");
        },
        _tryAnimatedPan: function(t, e) {
          var w = this._getCenterOffset(t)._trunc();
          return (e && e.animate) !== !0 && !this.getSize().contains(w) ? !1 : (this.panBy(w, e), !0);
        },
        _createAnimProxy: function() {
          var t = this._proxy = Te("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(t), this.on("zoomanim", function(e) {
            var w = oe, I = this._proxy.style[w];
            Ke(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1)), I === this._proxy.style[w] && this._animatingZoom && this._onZoomTransitionEnd();
          }, this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function() {
          Re(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy;
        },
        _animMoveEnd: function() {
          var t = this.getCenter(), e = this.getZoom();
          Ke(this._proxy, this.project(t, e), this.getZoomScale(e, 1));
        },
        _catchTransitionEnd: function(t) {
          this._animatingZoom && t.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd();
        },
        _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(t, e, w) {
          if (this._animatingZoom)
            return !0;
          if (w = w || {}, !this._zoomAnimated || w.animate === !1 || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold)
            return !1;
          var I = this.getZoomScale(e), Y = this._getCenterOffset(t)._divideBy(1 - 1 / I);
          return w.animate !== !0 && !this.getSize().contains(Y) ? !1 : (B(function() {
            this._moveStart(!0, !1)._animateZoom(t, e, !0);
          }, this), !0);
        },
        _animateZoom: function(t, e, w, I) {
          this._mapPane && (w && (this._animatingZoom = !0, this._animateToCenter = t, this._animateToZoom = e, gt(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", {
            center: t,
            zoom: e,
            noUpdate: I
          }), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(this._animateToCenter, this._animateToZoom, void 0, !0), setTimeout(i(this._onZoomTransitionEnd, this), 250));
        },
        _onZoomTransitionEnd: function() {
          this._animatingZoom && (this._mapPane && zt(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom, void 0, !0), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(!0));
        }
      });
      function ze(t, e) {
        return new xe(t, e);
      }
      var wt = D.extend({
        // @section
        // @aka Control Options
        options: {
          // @option position: String = 'topright'
          // The position of the control (one of the map corners). Possible values are `'topleft'`,
          // `'topright'`, `'bottomleft'` or `'bottomright'`
          position: "topright"
        },
        initialize: function(t) {
          h(this, t);
        },
        /* @section
         * Classes extending L.Control will inherit the following methods:
         *
         * @method getPosition: string
         * Returns the position of the control.
         */
        getPosition: function() {
          return this.options.position;
        },
        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function(t) {
          var e = this._map;
          return e && e.removeControl(this), this.options.position = t, e && e.addControl(this), this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function() {
          return this._container;
        },
        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function(t) {
          this.remove(), this._map = t;
          var e = this._container = this.onAdd(t), w = this.getPosition(), I = t._controlCorners[w];
          return gt(e, "leaflet-control"), w.indexOf("bottom") !== -1 ? I.insertBefore(e, I.firstChild) : I.appendChild(e), this._map.on("unload", this.remove, this), this;
        },
        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function() {
          return this._map ? (Re(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null, this) : this;
        },
        _refocusOnMap: function(t) {
          this._map && t && t.screenX > 0 && t.screenY > 0 && this._map.getContainer().focus();
        }
      }), Bt = function(t) {
        return new wt(t);
      };
      xe.include({
        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function(t) {
          return t.addTo(this), this;
        },
        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function(t) {
          return t.remove(), this;
        },
        _initControlPos: function() {
          var t = this._controlCorners = {}, e = "leaflet-", w = this._controlContainer = Te("div", e + "control-container", this._container);
          function I(Y, dt) {
            var Nt = e + Y + " " + e + dt;
            t[Y + dt] = Te("div", Nt, w);
          }
          I("top", "left"), I("top", "right"), I("bottom", "left"), I("bottom", "right");
        },
        _clearControlPos: function() {
          for (var t in this._controlCorners)
            Re(this._controlCorners[t]);
          Re(this._controlContainer), delete this._controlCorners, delete this._controlContainer;
        }
      });
      var Ht = wt.extend({
        // @section
        // @aka Control.Layers options
        options: {
          // @option collapsed: Boolean = true
          // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
          collapsed: !0,
          position: "topright",
          // @option autoZIndex: Boolean = true
          // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
          autoZIndex: !0,
          // @option hideSingleBase: Boolean = false
          // If `true`, the base layers in the control will be hidden when there is only one.
          hideSingleBase: !1,
          // @option sortLayers: Boolean = false
          // Whether to sort the layers. When `false`, layers will keep the order
          // in which they were added to the control.
          sortLayers: !1,
          // @option sortFunction: Function = *
          // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
          // that will be used for sorting the layers, when `sortLayers` is `true`.
          // The function receives both the `L.Layer` instances and their names, as in
          // `sortFunction(layerA, layerB, nameA, nameB)`.
          // By default, it sorts layers alphabetically by their name.
          sortFunction: function(t, e, w, I) {
            return w < I ? -1 : I < w ? 1 : 0;
          }
        },
        initialize: function(t, e, w) {
          h(this, w), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1;
          for (var I in t)
            this._addLayer(t[I], I);
          for (I in e)
            this._addLayer(e[I], I, !0);
        },
        onAdd: function(t) {
          this._initLayout(), this._update(), this._map = t, t.on("zoomend", this._checkDisabledLayers, this);
          for (var e = 0; e < this._layers.length; e++)
            this._layers[e].layer.on("add remove", this._onLayerChange, this);
          return this._container;
        },
        addTo: function(t) {
          return wt.prototype.addTo.call(this, t), this._expandIfNotCollapsed();
        },
        onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var t = 0; t < this._layers.length; t++)
            this._layers[t].layer.off("add remove", this._onLayerChange, this);
        },
        // @method addBaseLayer(layer: Layer, name: String): this
        // Adds a base layer (radio button entry) with the given name to the control.
        addBaseLayer: function(t, e) {
          return this._addLayer(t, e), this._map ? this._update() : this;
        },
        // @method addOverlay(layer: Layer, name: String): this
        // Adds an overlay (checkbox entry) with the given name to the control.
        addOverlay: function(t, e) {
          return this._addLayer(t, e, !0), this._map ? this._update() : this;
        },
        // @method removeLayer(layer: Layer): this
        // Remove the given layer from the control.
        removeLayer: function(t) {
          t.off("add remove", this._onLayerChange, this);
          var e = this._getLayer(r(t));
          return e && this._layers.splice(this._layers.indexOf(e), 1), this._map ? this._update() : this;
        },
        // @method expand(): this
        // Expand the control container if collapsed.
        expand: function() {
          gt(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null;
          var t = this._map.getSize().y - (this._container.offsetTop + 50);
          return t < this._section.clientHeight ? (gt(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = t + "px") : zt(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this;
        },
        // @method collapse(): this
        // Collapse the control container if expanded.
        collapse: function() {
          return zt(this._container, "leaflet-control-layers-expanded"), this;
        },
        _initLayout: function() {
          var t = "leaflet-control-layers", e = this._container = Te("div", t), w = this.options.collapsed;
          e.setAttribute("aria-haspopup", !0), mn(e), Cn(e);
          var I = this._section = Te("section", t + "-list");
          w && (this._map.on("click", this.collapse, this), Ee(e, {
            mouseenter: function() {
              Ee(I, "click", an), this.expand(), setTimeout(function() {
                Ne(I, "click", an);
              });
            },
            mouseleave: this.collapse
          }, this));
          var Y = this._layersLink = Te("a", t + "-toggle", e);
          Y.href = "#", Y.title = "Layers", Y.setAttribute("role", "button"), Ee(Y, "click", an), Ee(Y, "focus", this.expand, this), w || this.expand(), this._baseLayersList = Te("div", t + "-base", I), this._separator = Te("div", t + "-separator", I), this._overlaysList = Te("div", t + "-overlays", I), e.appendChild(I);
        },
        _getLayer: function(t) {
          for (var e = 0; e < this._layers.length; e++)
            if (this._layers[e] && r(this._layers[e].layer) === t)
              return this._layers[e];
        },
        _addLayer: function(t, e, w) {
          this._map && t.on("add remove", this._onLayerChange, this), this._layers.push({
            layer: t,
            name: e,
            overlay: w
          }), this.options.sortLayers && this._layers.sort(i(function(I, Y) {
            return this.options.sortFunction(I.layer, Y.layer, I.name, Y.name);
          }, this)), this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed();
        },
        _update: function() {
          if (!this._container)
            return this;
          en(this._baseLayersList), en(this._overlaysList), this._layerControlInputs = [];
          var t, e, w, I, Y = 0;
          for (w = 0; w < this._layers.length; w++)
            I = this._layers[w], this._addItem(I), e = e || I.overlay, t = t || !I.overlay, Y += I.overlay ? 0 : 1;
          return this.options.hideSingleBase && (t = t && Y > 1, this._baseLayersList.style.display = t ? "" : "none"), this._separator.style.display = e && t ? "" : "none", this;
        },
        _onLayerChange: function(t) {
          this._handlingClick || this._update();
          var e = this._getLayer(r(t.target)), w = e.overlay ? t.type === "add" ? "overlayadd" : "overlayremove" : t.type === "add" ? "baselayerchange" : null;
          w && this._map.fire(w, e);
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
        _createRadioElement: function(t, e) {
          var w = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"' + (e ? ' checked="checked"' : "") + "/>", I = document.createElement("div");
          return I.innerHTML = w, I.firstChild;
        },
        _addItem: function(t) {
          var e = document.createElement("label"), w = this._map.hasLayer(t.layer), I;
          t.overlay ? (I = document.createElement("input"), I.type = "checkbox", I.className = "leaflet-control-layers-selector", I.defaultChecked = w) : I = this._createRadioElement("leaflet-base-layers_" + r(this), w), this._layerControlInputs.push(I), I.layerId = r(t.layer), Ee(I, "click", this._onInputClick, this);
          var Y = document.createElement("span");
          Y.innerHTML = " " + t.name;
          var dt = document.createElement("span");
          e.appendChild(dt), dt.appendChild(I), dt.appendChild(Y);
          var Nt = t.overlay ? this._overlaysList : this._baseLayersList;
          return Nt.appendChild(e), this._checkDisabledLayers(), e;
        },
        _onInputClick: function() {
          var t = this._layerControlInputs, e, w, I = [], Y = [];
          this._handlingClick = !0;
          for (var dt = t.length - 1; dt >= 0; dt--)
            e = t[dt], w = this._getLayer(e.layerId).layer, e.checked ? I.push(w) : e.checked || Y.push(w);
          for (dt = 0; dt < Y.length; dt++)
            this._map.hasLayer(Y[dt]) && this._map.removeLayer(Y[dt]);
          for (dt = 0; dt < I.length; dt++)
            this._map.hasLayer(I[dt]) || this._map.addLayer(I[dt]);
          this._handlingClick = !1, this._refocusOnMap();
        },
        _checkDisabledLayers: function() {
          for (var t = this._layerControlInputs, e, w, I = this._map.getZoom(), Y = t.length - 1; Y >= 0; Y--)
            e = t[Y], w = this._getLayer(e.layerId).layer, e.disabled = w.options.minZoom !== void 0 && I < w.options.minZoom || w.options.maxZoom !== void 0 && I > w.options.maxZoom;
        },
        _expandIfNotCollapsed: function() {
          return this._map && !this.options.collapsed && this.expand(), this;
        }
      }), Se = function(t, e, w) {
        return new Ht(t, e, w);
      }, Je = wt.extend({
        // @section
        // @aka Control.Zoom options
        options: {
          position: "topleft",
          // @option zoomInText: String = '<span aria-hidden="true">+</span>'
          // The text set on the 'zoom in' button.
          zoomInText: '<span aria-hidden="true">+</span>',
          // @option zoomInTitle: String = 'Zoom in'
          // The title set on the 'zoom in' button.
          zoomInTitle: "Zoom in",
          // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
          // The text set on the 'zoom out' button.
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          // @option zoomOutTitle: String = 'Zoom out'
          // The title set on the 'zoom out' button.
          zoomOutTitle: "Zoom out"
        },
        onAdd: function(t) {
          var e = "leaflet-control-zoom", w = Te("div", e + " leaflet-bar"), I = this.options;
          return this._zoomInButton = this._createButton(
            I.zoomInText,
            I.zoomInTitle,
            e + "-in",
            w,
            this._zoomIn
          ), this._zoomOutButton = this._createButton(
            I.zoomOutText,
            I.zoomOutTitle,
            e + "-out",
            w,
            this._zoomOut
          ), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), w;
        },
        onRemove: function(t) {
          t.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function() {
          return this._disabled = !0, this._updateDisabled(), this;
        },
        enable: function() {
          return this._disabled = !1, this._updateDisabled(), this;
        },
        _zoomIn: function(t) {
          !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1));
        },
        _zoomOut: function(t) {
          !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1));
        },
        _createButton: function(t, e, w, I, Y) {
          var dt = Te("a", w, I);
          return dt.innerHTML = t, dt.href = "#", dt.title = e, dt.setAttribute("role", "button"), dt.setAttribute("aria-label", e), mn(dt), Ee(dt, "click", Tt), Ee(dt, "click", Y, this), Ee(dt, "click", this._refocusOnMap, this), dt;
        },
        _updateDisabled: function() {
          var t = this._map, e = "leaflet-disabled";
          zt(this._zoomInButton, e), zt(this._zoomOutButton, e), this._zoomInButton.setAttribute("aria-disabled", "false"), this._zoomOutButton.setAttribute("aria-disabled", "false"), (this._disabled || t._zoom === t.getMinZoom()) && (gt(this._zoomOutButton, e), this._zoomOutButton.setAttribute("aria-disabled", "true")), (this._disabled || t._zoom === t.getMaxZoom()) && (gt(this._zoomInButton, e), this._zoomInButton.setAttribute("aria-disabled", "true"));
        }
      });
      xe.mergeOptions({
        zoomControl: !0
      }), xe.addInitHook(function() {
        this.options.zoomControl && (this.zoomControl = new Je(), this.addControl(this.zoomControl));
      });
      var nn = function(t) {
        return new Je(t);
      }, fn = wt.extend({
        // @section
        // @aka Control.Scale options
        options: {
          position: "bottomleft",
          // @option maxWidth: Number = 100
          // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
          maxWidth: 100,
          // @option metric: Boolean = True
          // Whether to show the metric scale line (m/km).
          metric: !0,
          // @option imperial: Boolean = True
          // Whether to show the imperial scale line (mi/ft).
          imperial: !0
          // @option updateWhenIdle: Boolean = false
          // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
        },
        onAdd: function(t) {
          var e = "leaflet-control-scale", w = Te("div", e), I = this.options;
          return this._addScales(I, e + "-line", w), t.on(I.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), w;
        },
        onRemove: function(t) {
          t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(t, e, w) {
          t.metric && (this._mScale = Te("div", e, w)), t.imperial && (this._iScale = Te("div", e, w));
        },
        _update: function() {
          var t = this._map, e = t.getSize().y / 2, w = t.distance(
            t.containerPointToLatLng([0, e]),
            t.containerPointToLatLng([this.options.maxWidth, e])
          );
          this._updateScales(w);
        },
        _updateScales: function(t) {
          this.options.metric && t && this._updateMetric(t), this.options.imperial && t && this._updateImperial(t);
        },
        _updateMetric: function(t) {
          var e = this._getRoundNum(t), w = e < 1e3 ? e + " m" : e / 1e3 + " km";
          this._updateScale(this._mScale, w, e / t);
        },
        _updateImperial: function(t) {
          var e = t * 3.2808399, w, I, Y;
          e > 5280 ? (w = e / 5280, I = this._getRoundNum(w), this._updateScale(this._iScale, I + " mi", I / w)) : (Y = this._getRoundNum(e), this._updateScale(this._iScale, Y + " ft", Y / e));
        },
        _updateScale: function(t, e, w) {
          t.style.width = Math.round(this.options.maxWidth * w) + "px", t.innerHTML = e;
        },
        _getRoundNum: function(t) {
          var e = Math.pow(10, (Math.floor(t) + "").length - 1), w = t / e;
          return w = w >= 10 ? 10 : w >= 5 ? 5 : w >= 3 ? 3 : w >= 2 ? 2 : 1, e * w;
        }
      }), Qe = function(t) {
        return new fn(t);
      }, hn = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>', En = wt.extend({
        // @section
        // @aka Control.Attribution options
        options: {
          position: "bottomright",
          // @option prefix: String|false = 'Leaflet'
          // The HTML text shown before the attributions. Pass `false` to disable.
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Et.inlineSvg ? hn + " " : "") + "Leaflet</a>"
        },
        initialize: function(t) {
          h(this, t), this._attributions = {};
        },
        onAdd: function(t) {
          t.attributionControl = this, this._container = Te("div", "leaflet-control-attribution"), mn(this._container);
          for (var e in t._layers)
            t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution());
          return this._update(), t.on("layeradd", this._addAttribution, this), this._container;
        },
        onRemove: function(t) {
          t.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function(t) {
          t.layer.getAttribution && (this.addAttribution(t.layer.getAttribution()), t.layer.once("remove", function() {
            this.removeAttribution(t.layer.getAttribution());
          }, this));
        },
        // @method setPrefix(prefix: String|false): this
        // The HTML text shown before the attributions. Pass `false` to disable.
        setPrefix: function(t) {
          return this.options.prefix = t, this._update(), this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
        addAttribution: function(t) {
          return t ? (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update(), this) : this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function(t) {
          return t ? (this._attributions[t] && (this._attributions[t]--, this._update()), this) : this;
        },
        _update: function() {
          if (this._map) {
            var t = [];
            for (var e in this._attributions)
              this._attributions[e] && t.push(e);
            var w = [];
            this.options.prefix && w.push(this.options.prefix), t.length && w.push(t.join(", ")), this._container.innerHTML = w.join(' <span aria-hidden="true">|</span> ');
          }
        }
      });
      xe.mergeOptions({
        attributionControl: !0
      }), xe.addInitHook(function() {
        this.options.attributionControl && new En().addTo(this);
      });
      var Sn = function(t) {
        return new En(t);
      };
      wt.Layers = Ht, wt.Zoom = Je, wt.Scale = fn, wt.Attribution = En, Bt.layers = Se, Bt.zoom = nn, Bt.scale = Qe, Bt.attribution = Sn;
      var xn = D.extend({
        initialize: function(t) {
          this._map = t;
        },
        // @method enable(): this
        // Enables the handler
        enable: function() {
          return this._enabled ? this : (this._enabled = !0, this.addHooks(), this);
        },
        // @method disable(): this
        // Disables the handler
        disable: function() {
          return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this;
        },
        // @method enabled(): Boolean
        // Returns `true` if the handler is enabled
        enabled: function() {
          return !!this._enabled;
        }
        // @section Extension methods
        // Classes inheriting from `Handler` must implement the two following methods:
        // @method addHooks()
        // Called when the handler is enabled, should add event hooks.
        // @method removeHooks()
        // Called when the handler is disabled, should remove the event hooks added previously.
      });
      xn.addTo = function(t, e) {
        return t.addHandler(e, this), this;
      };
      var tr = { Events: Z }, Vn = Et.touch ? "touchstart mousedown" : "mousedown", Rn = tt.extend({
        options: {
          // @section
          // @aka Draggable options
          // @option clickTolerance: Number = 3
          // The max number of pixels a user can shift the mouse pointer during a click
          // for it to be considered a valid click (as opposed to a mouse drag).
          clickTolerance: 3
        },
        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
        initialize: function(t, e, w, I) {
          h(this, I), this._element = t, this._dragStartTarget = e || t, this._preventOutline = w;
        },
        // @method enable()
        // Enables the dragging ability
        enable: function() {
          this._enabled || (Ee(this._dragStartTarget, Vn, this._onDown, this), this._enabled = !0);
        },
        // @method disable()
        // Disables the dragging ability
        disable: function() {
          this._enabled && (Rn._dragging === this && this.finishDrag(!0), Ne(this._dragStartTarget, Vn, this._onDown, this), this._enabled = !1, this._moved = !1);
        },
        _onDown: function(t) {
          if (this._enabled && (this._moved = !1, !st(this._element, "leaflet-zoom-anim"))) {
            if (t.touches && t.touches.length !== 1) {
              Rn._dragging === this && this.finishDrag();
              return;
            }
            if (!(Rn._dragging || t.shiftKey || t.which !== 1 && t.button !== 1 && !t.touches) && (Rn._dragging = this, this._preventOutline && $t(this._element), Mn(), gn(), !this._moving)) {
              this.fire("down");
              var e = t.touches ? t.touches[0] : t, w = ae(this._element);
              this._startPoint = new nt(e.clientX, e.clientY), this._startPos = le(this._element), this._parentScale = Be(w);
              var I = t.type === "mousedown";
              Ee(document, I ? "mousemove" : "touchmove", this._onMove, this), Ee(document, I ? "mouseup" : "touchend touchcancel", this._onUp, this);
            }
          }
        },
        _onMove: function(t) {
          if (this._enabled) {
            if (t.touches && t.touches.length > 1) {
              this._moved = !0;
              return;
            }
            var e = t.touches && t.touches.length === 1 ? t.touches[0] : t, w = new nt(e.clientX, e.clientY)._subtract(this._startPoint);
            !w.x && !w.y || Math.abs(w.x) + Math.abs(w.y) < this.options.clickTolerance || (w.x /= this._parentScale.x, w.y /= this._parentScale.y, an(t), this._moved || (this.fire("dragstart"), this._moved = !0, gt(document.body, "leaflet-dragging"), this._lastTarget = t.target || t.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), gt(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(w), this._moving = !0, this._lastEvent = t, this._updatePosition());
          }
        },
        _updatePosition: function() {
          var t = { originalEvent: this._lastEvent };
          this.fire("predrag", t), Ae(this._element, this._newPos), this.fire("drag", t);
        },
        _onUp: function() {
          this._enabled && this.finishDrag();
        },
        finishDrag: function(t) {
          zt(document.body, "leaflet-dragging"), this._lastTarget && (zt(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), Ne(document, "mousemove touchmove", this._onMove, this), Ne(document, "mouseup touchend touchcancel", this._onUp, this), Pn(), pe(), this._moved && this._moving && this.fire("dragend", {
            noInertia: t,
            distance: this._newPos.distanceTo(this._startPos)
          }), this._moving = !1, Rn._dragging = !1;
        }
      });
      function Pr(t, e) {
        if (!e || !t.length)
          return t.slice();
        var w = e * e;
        return t = li(t, w), t = si(t, w), t;
      }
      function jr(t, e, w) {
        return Math.sqrt(er(t, e, w, !0));
      }
      function ai(t, e, w) {
        return er(t, e, w);
      }
      function si(t, e) {
        var w = t.length, I = typeof Uint8Array != void 0 + "" ? Uint8Array : Array, Y = new I(w);
        Y[0] = Y[w - 1] = 1, vr(t, Y, e, 0, w - 1);
        var dt, Nt = [];
        for (dt = 0; dt < w; dt++)
          Y[dt] && Nt.push(t[dt]);
        return Nt;
      }
      function vr(t, e, w, I, Y) {
        var dt = 0, Nt, Kt, ee;
        for (Kt = I + 1; Kt <= Y - 1; Kt++)
          ee = er(t[Kt], t[I], t[Y], !0), ee > dt && (Nt = Kt, dt = ee);
        dt > w && (e[Nt] = 1, vr(t, e, w, I, Nt), vr(t, e, w, Nt, Y));
      }
      function li(t, e) {
        for (var w = [t[0]], I = 1, Y = 0, dt = t.length; I < dt; I++)
          ui(t[I], t[Y]) > e && (w.push(t[I]), Y = I);
        return Y < dt - 1 && w.push(t[dt - 1]), w;
      }
      var Cr;
      function Rr(t, e, w, I, Y) {
        var dt = I ? Cr : Gn(t, w), Nt = Gn(e, w), Kt, ee, ue;
        for (Cr = Nt; ; ) {
          if (!(dt | Nt))
            return [t, e];
          if (dt & Nt)
            return !1;
          Kt = dt || Nt, ee = ar(t, e, Kt, w, Y), ue = Gn(ee, w), Kt === dt ? (t = ee, dt = ue) : (e = ee, Nt = ue);
        }
      }
      function ar(t, e, w, I, Y) {
        var dt = e.x - t.x, Nt = e.y - t.y, Kt = I.min, ee = I.max, ue, Pe;
        return w & 8 ? (ue = t.x + dt * (ee.y - t.y) / Nt, Pe = ee.y) : w & 4 ? (ue = t.x + dt * (Kt.y - t.y) / Nt, Pe = Kt.y) : w & 2 ? (ue = ee.x, Pe = t.y + Nt * (ee.x - t.x) / dt) : w & 1 && (ue = Kt.x, Pe = t.y + Nt * (Kt.x - t.x) / dt), new nt(ue, Pe, Y);
      }
      function Gn(t, e) {
        var w = 0;
        return t.x < e.min.x ? w |= 1 : t.x > e.max.x && (w |= 2), t.y < e.min.y ? w |= 4 : t.y > e.max.y && (w |= 8), w;
      }
      function ui(t, e) {
        var w = e.x - t.x, I = e.y - t.y;
        return w * w + I * I;
      }
      function er(t, e, w, I) {
        var Y = e.x, dt = e.y, Nt = w.x - Y, Kt = w.y - dt, ee = Nt * Nt + Kt * Kt, ue;
        return ee > 0 && (ue = ((t.x - Y) * Nt + (t.y - dt) * Kt) / ee, ue > 1 ? (Y = w.x, dt = w.y) : ue > 0 && (Y += Nt * ue, dt += Kt * ue)), Nt = t.x - Y, Kt = t.y - dt, I ? Nt * Nt + Kt * Kt : new nt(Y, dt);
      }
      function Dn(t) {
        return !d(t[0]) || typeof t[0][0] != "object" && typeof t[0][0] != "undefined";
      }
      function Ir(t) {
        return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), Dn(t);
      }
      var ci = {
        __proto__: null,
        simplify: Pr,
        pointToSegmentDistance: jr,
        closestPointOnSegment: ai,
        clipSegment: Rr,
        _getEdgeIntersection: ar,
        _getBitCode: Gn,
        _sqClosestPointOnSegment: er,
        isFlat: Dn,
        _flat: Ir
      };
      function Mr(t, e, w) {
        var I, Y = [1, 4, 2, 8], dt, Nt, Kt, ee, ue, Pe, Xe, tn;
        for (dt = 0, Pe = t.length; dt < Pe; dt++)
          t[dt]._code = Gn(t[dt], e);
        for (Kt = 0; Kt < 4; Kt++) {
          for (Xe = Y[Kt], I = [], dt = 0, Pe = t.length, Nt = Pe - 1; dt < Pe; Nt = dt++)
            ee = t[dt], ue = t[Nt], ee._code & Xe ? ue._code & Xe || (tn = ar(ue, ee, Xe, e, w), tn._code = Gn(tn, e), I.push(tn)) : (ue._code & Xe && (tn = ar(ue, ee, Xe, e, w), tn._code = Gn(tn, e), I.push(tn)), I.push(ee));
          t = I;
        }
        return t;
      }
      var fi = {
        __proto__: null,
        clipPolygon: Mr
      }, br = {
        project: function(t) {
          return new nt(t.lng, t.lat);
        },
        unproject: function(t) {
          return new pt(t.y, t.x);
        },
        bounds: new V([-180, -90], [180, 90])
      }, wr = {
        R: 6378137,
        R_MINOR: 6356752314245179e-9,
        bounds: new V([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
        project: function(t) {
          var e = Math.PI / 180, w = this.R, I = t.lat * e, Y = this.R_MINOR / w, dt = Math.sqrt(1 - Y * Y), Nt = dt * Math.sin(I), Kt = Math.tan(Math.PI / 4 - I / 2) / Math.pow((1 - Nt) / (1 + Nt), dt / 2);
          return I = -w * Math.log(Math.max(Kt, 1e-10)), new nt(t.lng * e * w, I);
        },
        unproject: function(t) {
          for (var e = 180 / Math.PI, w = this.R, I = this.R_MINOR / w, Y = Math.sqrt(1 - I * I), dt = Math.exp(-t.y / w), Nt = Math.PI / 2 - 2 * Math.atan(dt), Kt = 0, ee = 0.1, ue; Kt < 15 && Math.abs(ee) > 1e-7; Kt++)
            ue = Y * Math.sin(Nt), ue = Math.pow((1 - ue) / (1 + ue), Y / 2), ee = Math.PI / 2 - 2 * Math.atan(dt * ue) - Nt, Nt += ee;
          return new pt(Nt * e, t.x * e / w);
        }
      }, hi = {
        __proto__: null,
        LonLat: br,
        Mercator: wr,
        SphericalMercator: Pt
      }, di = v({}, Q, {
        code: "EPSG:3395",
        projection: wr,
        transformation: function() {
          var t = 0.5 / (Math.PI * wr.R);
          return G(t, 0.5, -t, 0.5);
        }()
      }), Nr = v({}, Q, {
        code: "EPSG:4326",
        projection: br,
        transformation: G(1 / 180, 1, -1 / 180, 0.5)
      }), pi = v({}, bt, {
        projection: br,
        transformation: G(1, 0, -1, 0),
        scale: function(t) {
          return Math.pow(2, t);
        },
        zoom: function(t) {
          return Math.log(t) / Math.LN2;
        },
        distance: function(t, e) {
          var w = e.lng - t.lng, I = e.lat - t.lat;
          return Math.sqrt(w * w + I * I);
        },
        infinite: !0
      });
      bt.Earth = Q, bt.EPSG3395 = di, bt.EPSG3857 = lt, bt.EPSG900913 = It, bt.EPSG4326 = Nr, bt.Simple = pi;
      var In = tt.extend({
        // Classes extending `L.Layer` will inherit the following options:
        options: {
          // @option pane: String = 'overlayPane'
          // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
          pane: "overlayPane",
          // @option attribution: String = null
          // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
          attribution: null,
          bubblingMouseEvents: !0
        },
        /* @section
         * Classes extending `L.Layer` will inherit the following methods:
         *
         * @method addTo(map: Map|LayerGroup): this
         * Adds the layer to the given map or layer group.
         */
        addTo: function(t) {
          return t.addLayer(this), this;
        },
        // @method remove: this
        // Removes the layer from the map it is currently active on.
        remove: function() {
          return this.removeFrom(this._map || this._mapToAdd);
        },
        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        //
        // @alternative
        // @method removeFrom(group: LayerGroup): this
        // Removes the layer from the given `LayerGroup`
        removeFrom: function(t) {
          return t && t.removeLayer(this), this;
        },
        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function(t) {
          return this._map.getPane(t ? this.options[t] || t : this.options.pane);
        },
        addInteractiveTarget: function(t) {
          return this._map._targets[r(t)] = this, this;
        },
        removeInteractiveTarget: function(t) {
          return delete this._map._targets[r(t)], this;
        },
        // @method getAttribution: String
        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
        getAttribution: function() {
          return this.options.attribution;
        },
        _layerAdd: function(t) {
          var e = t.target;
          if (e.hasLayer(this)) {
            if (this._map = e, this._zoomAnimated = e._zoomAnimated, this.getEvents) {
              var w = this.getEvents();
              e.on(w, this), this.once("remove", function() {
                e.off(w, this);
              }, this);
            }
            this.onAdd(e), this.fire("add"), e.fire("layeradd", { layer: this });
          }
        }
      });
      xe.include({
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the map
        addLayer: function(t) {
          if (!t._layerAdd)
            throw new Error("The provided object is not a Layer.");
          var e = r(t);
          return this._layers[e] ? this : (this._layers[e] = t, t._mapToAdd = this, t.beforeAdd && t.beforeAdd(this), this.whenReady(t._layerAdd, t), this);
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function(t) {
          var e = r(t);
          return this._layers[e] ? (this._loaded && t.onRemove(this), delete this._layers[e], this._loaded && (this.fire("layerremove", { layer: t }), t.fire("remove")), t._map = t._mapToAdd = null, this) : this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function(t) {
          return r(t) in this._layers;
        },
        /* @method eachLayer(fn: Function, context?: Object): this
         * Iterates over the layers of the map, optionally specifying context of the iterator function.
         * ```
         * map.eachLayer(function(layer){
         *     layer.bindPopup('Hello');
         * });
         * ```
         */
        eachLayer: function(t, e) {
          for (var w in this._layers)
            t.call(e, this._layers[w]);
          return this;
        },
        _addLayers: function(t) {
          t = t ? d(t) ? t : [t] : [];
          for (var e = 0, w = t.length; e < w; e++)
            this.addLayer(t[e]);
        },
        _addZoomLimit: function(t) {
          (!isNaN(t.options.maxZoom) || !isNaN(t.options.minZoom)) && (this._zoomBoundLayers[r(t)] = t, this._updateZoomLevels());
        },
        _removeZoomLimit: function(t) {
          var e = r(t);
          this._zoomBoundLayers[e] && (delete this._zoomBoundLayers[e], this._updateZoomLevels());
        },
        _updateZoomLevels: function() {
          var t = 1 / 0, e = -1 / 0, w = this._getZoomSpan();
          for (var I in this._zoomBoundLayers) {
            var Y = this._zoomBoundLayers[I].options;
            t = Y.minZoom === void 0 ? t : Math.min(t, Y.minZoom), e = Y.maxZoom === void 0 ? e : Math.max(e, Y.maxZoom);
          }
          this._layersMaxZoom = e === -1 / 0 ? void 0 : e, this._layersMinZoom = t === 1 / 0 ? void 0 : t, w !== this._getZoomSpan() && this.fire("zoomlevelschange"), this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);
        }
      });
      var qn = In.extend({
        initialize: function(t, e) {
          h(this, e), this._layers = {};
          var w, I;
          if (t)
            for (w = 0, I = t.length; w < I; w++)
              this.addLayer(t[w]);
        },
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function(t) {
          var e = this.getLayerId(t);
          return this._layers[e] = t, this._map && this._map.addLayer(t), this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function(t) {
          var e = t in this._layers ? t : this.getLayerId(t);
          return this._map && this._layers[e] && this._map.removeLayer(this._layers[e]), delete this._layers[e], this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        // @alternative
        // @method hasLayer(id: Number): Boolean
        // Returns `true` if the given internal ID is currently added to the group.
        hasLayer: function(t) {
          var e = typeof t == "number" ? t : this.getLayerId(t);
          return e in this._layers;
        },
        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function() {
          return this.eachLayer(this.removeLayer, this);
        },
        // @method invoke(methodName: String, …): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function(t) {
          var e = Array.prototype.slice.call(arguments, 1), w, I;
          for (w in this._layers)
            I = this._layers[w], I[t] && I[t].apply(I, e);
          return this;
        },
        onAdd: function(t) {
          this.eachLayer(t.addLayer, t);
        },
        onRemove: function(t) {
          this.eachLayer(t.removeLayer, t);
        },
        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function(t, e) {
          for (var w in this._layers)
            t.call(e, this._layers[w]);
          return this;
        },
        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function(t) {
          return this._layers[t];
        },
        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function() {
          var t = [];
          return this.eachLayer(t.push, t), t;
        },
        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function(t) {
          return this.invoke("setZIndex", t);
        },
        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function(t) {
          return r(t);
        }
      }), mi = function(t, e) {
        return new qn(t, e);
      }, Kn = qn.extend({
        addLayer: function(t) {
          return this.hasLayer(t) ? this : (t.addEventParent(this), qn.prototype.addLayer.call(this, t), this.fire("layeradd", { layer: t }));
        },
        removeLayer: function(t) {
          return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), t.removeEventParent(this), qn.prototype.removeLayer.call(this, t), this.fire("layerremove", { layer: t })) : this;
        },
        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function(t) {
          return this.invoke("setStyle", t);
        },
        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function() {
          return this.invoke("bringToFront");
        },
        // @method bringToBack(): this
        // Brings the layer group to the back of all other layers
        bringToBack: function() {
          return this.invoke("bringToBack");
        },
        // @method getBounds(): LatLngBounds
        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
        getBounds: function() {
          var t = new xt();
          for (var e in this._layers) {
            var w = this._layers[e];
            t.extend(w.getBounds ? w.getBounds() : w.getLatLng());
          }
          return t;
        }
      }), gi = function(t, e) {
        return new Kn(t, e);
      }, Yn = D.extend({
        /* @section
         * @aka Icon options
         *
         * @option iconUrl: String = null
         * **(required)** The URL to the icon image (absolute or relative to your script path).
         *
         * @option iconRetinaUrl: String = null
         * The URL to a retina sized version of the icon image (absolute or relative to your
         * script path). Used for Retina screen devices.
         *
         * @option iconSize: Point = null
         * Size of the icon image in pixels.
         *
         * @option iconAnchor: Point = null
         * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
         * will be aligned so that this point is at the marker's geographical location. Centered
         * by default if size is specified, also can be set in CSS with negative margins.
         *
         * @option popupAnchor: Point = [0, 0]
         * The coordinates of the point from which popups will "open", relative to the icon anchor.
         *
         * @option tooltipAnchor: Point = [0, 0]
         * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
         *
         * @option shadowUrl: String = null
         * The URL to the icon shadow image. If not specified, no shadow image will be created.
         *
         * @option shadowRetinaUrl: String = null
         *
         * @option shadowSize: Point = null
         * Size of the shadow image in pixels.
         *
         * @option shadowAnchor: Point = null
         * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
         * as iconAnchor if not specified).
         *
         * @option className: String = ''
         * A custom class name to assign to both icon and shadow images. Empty by default.
         */
        options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1
        },
        initialize: function(t) {
          h(this, t);
        },
        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function(t) {
          return this._createIcon("icon", t);
        },
        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function(t) {
          return this._createIcon("shadow", t);
        },
        _createIcon: function(t, e) {
          var w = this._getIconUrl(t);
          if (!w) {
            if (t === "icon")
              throw new Error("iconUrl not set in Icon options (see the docs).");
            return null;
          }
          var I = this._createImg(w, e && e.tagName === "IMG" ? e : null);
          return this._setIconStyles(I, t), (this.options.crossOrigin || this.options.crossOrigin === "") && (I.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), I;
        },
        _setIconStyles: function(t, e) {
          var w = this.options, I = w[e + "Size"];
          typeof I == "number" && (I = [I, I]);
          var Y = ut(I), dt = ut(e === "shadow" && w.shadowAnchor || w.iconAnchor || Y && Y.divideBy(2, !0));
          t.className = "leaflet-marker-" + e + " " + (w.className || ""), dt && (t.style.marginLeft = -dt.x + "px", t.style.marginTop = -dt.y + "px"), Y && (t.style.width = Y.x + "px", t.style.height = Y.y + "px");
        },
        _createImg: function(t, e) {
          return e = e || document.createElement("img"), e.src = t, e;
        },
        _getIconUrl: function(t) {
          return Et.retina && this.options[t + "RetinaUrl"] || this.options[t + "Url"];
        }
      });
      function _i(t) {
        return new Yn(t);
      }
      var nr = Yn.extend({
        options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
        },
        _getIconUrl: function(t) {
          return typeof nr.imagePath != "string" && (nr.imagePath = this._detectIconPath()), (this.options.imagePath || nr.imagePath) + Yn.prototype._getIconUrl.call(this, t);
        },
        _stripUrl: function(t) {
          var e = function(w, I, Y) {
            var dt = I.exec(w);
            return dt && dt[Y];
          };
          return t = e(t, /^url\((['"])?(.+)\1\)$/, 2), t && e(t, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function() {
          var t = Te("div", "leaflet-default-icon-path", document.body), e = Le(t, "background-image") || Le(t, "backgroundImage");
          if (document.body.removeChild(t), e = this._stripUrl(e), e)
            return e;
          var w = document.querySelector('link[href$="leaflet.css"]');
          return w ? w.href.substring(0, w.href.length - 11 - 1) : "";
        }
      }), Dr = xn.extend({
        initialize: function(t) {
          this._marker = t;
        },
        addHooks: function() {
          var t = this._marker._icon;
          this._draggable || (this._draggable = new Rn(t, t, !0)), this._draggable.on({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).enable(), gt(t, "leaflet-marker-draggable");
        },
        removeHooks: function() {
          this._draggable.off({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).disable(), this._marker._icon && zt(this._marker._icon, "leaflet-marker-draggable");
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        _adjustPan: function(t) {
          var e = this._marker, w = e._map, I = this._marker.options.autoPanSpeed, Y = this._marker.options.autoPanPadding, dt = le(e._icon), Nt = w.getPixelBounds(), Kt = w.getPixelOrigin(), ee = ot(
            Nt.min._subtract(Kt).add(Y),
            Nt.max._subtract(Kt).subtract(Y)
          );
          if (!ee.contains(dt)) {
            var ue = ut(
              (Math.max(ee.max.x, dt.x) - ee.max.x) / (Nt.max.x - ee.max.x) - (Math.min(ee.min.x, dt.x) - ee.min.x) / (Nt.min.x - ee.min.x),
              (Math.max(ee.max.y, dt.y) - ee.max.y) / (Nt.max.y - ee.max.y) - (Math.min(ee.min.y, dt.y) - ee.min.y) / (Nt.min.y - ee.min.y)
            ).multiplyBy(I);
            w.panBy(ue, { animate: !1 }), this._draggable._newPos._add(ue), this._draggable._startPos._add(ue), Ae(e._icon, this._draggable._newPos), this._onDrag(t), this._panRequest = B(this._adjustPan.bind(this, t));
          }
        },
        _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function(t) {
          this._marker.options.autoPan && (X(this._panRequest), this._panRequest = B(this._adjustPan.bind(this, t)));
        },
        _onDrag: function(t) {
          var e = this._marker, w = e._shadow, I = le(e._icon), Y = e._map.layerPointToLatLng(I);
          w && Ae(w, I), e._latlng = Y, t.latlng = Y, t.oldLatLng = this._oldLatLng, e.fire("move", t).fire("drag", t);
        },
        _onDragEnd: function(t) {
          X(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", t);
        }
      }), sr = In.extend({
        // @section
        // @aka Marker options
        options: {
          // @option icon: Icon = *
          // Icon instance to use for rendering the marker.
          // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
          // If not specified, a common instance of `L.Icon.Default` is used.
          icon: new nr(),
          // Option inherited from "Interactive layer" abstract class
          interactive: !0,
          // @option keyboard: Boolean = true
          // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
          keyboard: !0,
          // @option title: String = ''
          // Text for the browser tooltip that appear on marker hover (no tooltip by default).
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          title: "",
          // @option alt: String = 'Marker'
          // Text for the `alt` attribute of the icon image.
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          alt: "Marker",
          // @option zIndexOffset: Number = 0
          // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
          zIndexOffset: 0,
          // @option opacity: Number = 1.0
          // The opacity of the marker.
          opacity: 1,
          // @option riseOnHover: Boolean = false
          // If `true`, the marker will get on top of others when you hover the mouse over it.
          riseOnHover: !1,
          // @option riseOffset: Number = 250
          // The z-index offset used for the `riseOnHover` feature.
          riseOffset: 250,
          // @option pane: String = 'markerPane'
          // `Map pane` where the markers icon will be added.
          pane: "markerPane",
          // @option shadowPane: String = 'shadowPane'
          // `Map pane` where the markers shadow will be added.
          shadowPane: "shadowPane",
          // @option bubblingMouseEvents: Boolean = false
          // When `true`, a mouse event on this marker will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: !1,
          // @option autoPanOnFocus: Boolean = true
          // When `true`, the map will pan whenever the marker is focused (via
          // e.g. pressing `tab` on the keyboard) to ensure the marker is
          // visible within the map's bounds
          autoPanOnFocus: !0,
          // @section Draggable marker options
          // @option draggable: Boolean = false
          // Whether the marker is draggable with mouse/touch or not.
          draggable: !1,
          // @option autoPan: Boolean = false
          // Whether to pan the map when dragging this marker near its edge or not.
          autoPan: !1,
          // @option autoPanPadding: Point = Point(50, 50)
          // Distance (in pixels to the left/right and to the top/bottom) of the
          // map edge to start panning the map.
          autoPanPadding: [50, 50],
          // @option autoPanSpeed: Number = 10
          // Number of pixels the map should pan by.
          autoPanSpeed: 10
        },
        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */
        initialize: function(t, e) {
          h(this, e), this._latlng = at(t);
        },
        onAdd: function(t) {
          this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation, this._zoomAnimated && t.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update();
        },
        onRemove: function(t) {
          this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow();
        },
        getEvents: function() {
          return {
            zoom: this.update,
            viewreset: this.update
          };
        },
        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function(t) {
          var e = this._latlng;
          return this._latlng = at(t), this.update(), this.fire("move", { oldLatLng: e, latlng: this._latlng });
        },
        // @method setZIndexOffset(offset: Number): this
        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
        setZIndexOffset: function(t) {
          return this.options.zIndexOffset = t, this.update();
        },
        // @method getIcon: Icon
        // Returns the current icon used by the marker
        getIcon: function() {
          return this.options.icon;
        },
        // @method setIcon(icon: Icon): this
        // Changes the marker icon.
        setIcon: function(t) {
          return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this;
        },
        getElement: function() {
          return this._icon;
        },
        update: function() {
          if (this._icon && this._map) {
            var t = this._map.latLngToLayerPoint(this._latlng).round();
            this._setPos(t);
          }
          return this;
        },
        _initIcon: function() {
          var t = this.options, e = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), w = t.icon.createIcon(this._icon), I = !1;
          w !== this._icon && (this._icon && this._removeIcon(), I = !0, t.title && (w.title = t.title), w.tagName === "IMG" && (w.alt = t.alt || "")), gt(w, e), t.keyboard && (w.tabIndex = "0", w.setAttribute("role", "button")), this._icon = w, t.riseOnHover && this.on({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          }), this.options.autoPanOnFocus && Ee(w, "focus", this._panOnFocus, this);
          var Y = t.icon.createShadow(this._shadow), dt = !1;
          Y !== this._shadow && (this._removeShadow(), dt = !0), Y && (gt(Y, e), Y.alt = ""), this._shadow = Y, t.opacity < 1 && this._updateOpacity(), I && this.getPane().appendChild(this._icon), this._initInteraction(), Y && dt && this.getPane(t.shadowPane).appendChild(this._shadow);
        },
        _removeIcon: function() {
          this.options.riseOnHover && this.off({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          }), this.options.autoPanOnFocus && Ne(this._icon, "focus", this._panOnFocus, this), Re(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null;
        },
        _removeShadow: function() {
          this._shadow && Re(this._shadow), this._shadow = null;
        },
        _setPos: function(t) {
          this._icon && Ae(this._icon, t), this._shadow && Ae(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex();
        },
        _updateZIndex: function(t) {
          this._icon && (this._icon.style.zIndex = this._zIndex + t);
        },
        _animateZoom: function(t) {
          var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round();
          this._setPos(e);
        },
        _initInteraction: function() {
          if (this.options.interactive && (gt(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), Dr)) {
            var t = this.options.draggable;
            this.dragging && (t = this.dragging.enabled(), this.dragging.disable()), this.dragging = new Dr(this), t && this.dragging.enable();
          }
        },
        // @method setOpacity(opacity: Number): this
        // Changes the opacity of the marker.
        setOpacity: function(t) {
          return this.options.opacity = t, this._map && this._updateOpacity(), this;
        },
        _updateOpacity: function() {
          var t = this.options.opacity;
          this._icon && vt(this._icon, t), this._shadow && vt(this._shadow, t);
        },
        _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
          this._updateZIndex(0);
        },
        _panOnFocus: function() {
          var t = this._map;
          if (t) {
            var e = this.options.icon.options, w = e.iconSize ? ut(e.iconSize) : ut(0, 0), I = e.iconAnchor ? ut(e.iconAnchor) : ut(0, 0);
            t.panInside(this._latlng, {
              paddingTopLeft: I,
              paddingBottomRight: w.subtract(I)
            });
          }
        },
        _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor;
        }
      });
      function yi(t, e) {
        return new sr(t, e);
      }
      var Fn = In.extend({
        // @section
        // @aka Path options
        options: {
          // @option stroke: Boolean = true
          // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
          stroke: !0,
          // @option color: String = '#3388ff'
          // Stroke color
          color: "#3388ff",
          // @option weight: Number = 3
          // Stroke width in pixels
          weight: 3,
          // @option opacity: Number = 1.0
          // Stroke opacity
          opacity: 1,
          // @option lineCap: String= 'round'
          // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
          lineCap: "round",
          // @option lineJoin: String = 'round'
          // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
          lineJoin: "round",
          // @option dashArray: String = null
          // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashArray: null,
          // @option dashOffset: String = null
          // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashOffset: null,
          // @option fill: Boolean = depends
          // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
          fill: !1,
          // @option fillColor: String = *
          // Fill color. Defaults to the value of the [`color`](#path-color) option
          fillColor: null,
          // @option fillOpacity: Number = 0.2
          // Fill opacity.
          fillOpacity: 0.2,
          // @option fillRule: String = 'evenodd'
          // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
          fillRule: "evenodd",
          // className: '',
          // Option inherited from "Interactive layer" abstract class
          interactive: !0,
          // @option bubblingMouseEvents: Boolean = true
          // When `true`, a mouse event on this path will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: !0
        },
        beforeAdd: function(t) {
          this._renderer = t.getRenderer(this);
        },
        onAdd: function() {
          this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);
        },
        onRemove: function() {
          this._renderer._removePath(this);
        },
        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function() {
          return this._map && this._renderer._updatePath(this), this;
        },
        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function(t) {
          return h(this, t), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && t && Object.prototype.hasOwnProperty.call(t, "weight") && this._updateBounds()), this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all path layers.
        bringToFront: function() {
          return this._renderer && this._renderer._bringToFront(this), this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all path layers.
        bringToBack: function() {
          return this._renderer && this._renderer._bringToBack(this), this;
        },
        getElement: function() {
          return this._path;
        },
        _reset: function() {
          this._project(), this._update();
        },
        _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
      }), lr = Fn.extend({
        // @section
        // @aka CircleMarker options
        options: {
          fill: !0,
          // @option radius: Number = 10
          // Radius of the circle marker, in pixels
          radius: 10
        },
        initialize: function(t, e) {
          h(this, e), this._latlng = at(t), this._radius = this.options.radius;
        },
        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function(t) {
          var e = this._latlng;
          return this._latlng = at(t), this.redraw(), this.fire("move", { oldLatLng: e, latlng: this._latlng });
        },
        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function() {
          return this._latlng;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function(t) {
          return this.options.radius = this._radius = t, this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function() {
          return this._radius;
        },
        setStyle: function(t) {
          var e = t && t.radius || this._radius;
          return Fn.prototype.setStyle.call(this, t), this.setRadius(e), this;
        },
        _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();
        },
        _updateBounds: function() {
          var t = this._radius, e = this._radiusY || t, w = this._clickTolerance(), I = [t + w, e + w];
          this._pxBounds = new V(this._point.subtract(I), this._point.add(I));
        },
        _update: function() {
          this._map && this._updatePath();
        },
        _updatePath: function() {
          this._renderer._updateCircle(this);
        },
        _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(t) {
          return t.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
      });
      function vi(t, e) {
        return new lr(t, e);
      }
      var Er = lr.extend({
        initialize: function(t, e, w) {
          if (typeof e == "number" && (e = v({}, w, { radius: e })), h(this, e), this._latlng = at(t), isNaN(this.options.radius))
            throw new Error("Circle radius cannot be NaN");
          this._mRadius = this.options.radius;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle. Units are in meters.
        setRadius: function(t) {
          return this._mRadius = t, this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of a circle. Units are in meters.
        getRadius: function() {
          return this._mRadius;
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          var t = [this._radius, this._radiusY || this._radius];
          return new xt(
            this._map.layerPointToLatLng(this._point.subtract(t)),
            this._map.layerPointToLatLng(this._point.add(t))
          );
        },
        setStyle: Fn.prototype.setStyle,
        _project: function() {
          var t = this._latlng.lng, e = this._latlng.lat, w = this._map, I = w.options.crs;
          if (I.distance === Q.distance) {
            var Y = Math.PI / 180, dt = this._mRadius / Q.R / Y, Nt = w.project([e + dt, t]), Kt = w.project([e - dt, t]), ee = Nt.add(Kt).divideBy(2), ue = w.unproject(ee).lat, Pe = Math.acos((Math.cos(dt * Y) - Math.sin(e * Y) * Math.sin(ue * Y)) / (Math.cos(e * Y) * Math.cos(ue * Y))) / Y;
            (isNaN(Pe) || Pe === 0) && (Pe = dt / Math.cos(Math.PI / 180 * e)), this._point = ee.subtract(w.getPixelOrigin()), this._radius = isNaN(Pe) ? 0 : ee.x - w.project([ue, t - Pe]).x, this._radiusY = ee.y - Nt.y;
          } else {
            var Xe = I.unproject(I.project(this._latlng).subtract([this._mRadius, 0]));
            this._point = w.latLngToLayerPoint(this._latlng), this._radius = this._point.x - w.latLngToLayerPoint(Xe).x;
          }
          this._updateBounds();
        }
      });
      function bi(t, e, w) {
        return new Er(t, e, w);
      }
      var $n = Fn.extend({
        // @section
        // @aka Polyline options
        options: {
          // @option smoothFactor: Number = 1.0
          // How much to simplify the polyline on each zoom level. More means
          // better performance and smoother look, and less means more accurate representation.
          smoothFactor: 1,
          // @option noClip: Boolean = false
          // Disable polyline clipping.
          noClip: !1
        },
        initialize: function(t, e) {
          h(this, e), this._setLatLngs(t);
        },
        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function() {
          return this._latlngs;
        },
        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function(t) {
          return this._setLatLngs(t), this.redraw();
        },
        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function() {
          return !this._latlngs.length;
        },
        // @method closestLayerPoint(p: Point): Point
        // Returns the point closest to `p` on the Polyline.
        closestLayerPoint: function(t) {
          for (var e = 1 / 0, w = null, I = er, Y, dt, Nt = 0, Kt = this._parts.length; Nt < Kt; Nt++)
            for (var ee = this._parts[Nt], ue = 1, Pe = ee.length; ue < Pe; ue++) {
              Y = ee[ue - 1], dt = ee[ue];
              var Xe = I(t, Y, dt, !0);
              Xe < e && (e = Xe, w = I(t, Y, dt));
            }
          return w && (w.distance = Math.sqrt(e)), w;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function() {
          if (!this._map)
            throw new Error("Must add layer to map before using getCenter()");
          var t, e, w, I, Y, dt, Nt, Kt = this._rings[0], ee = Kt.length;
          if (!ee)
            return null;
          for (t = 0, e = 0; t < ee - 1; t++)
            e += Kt[t].distanceTo(Kt[t + 1]) / 2;
          if (e === 0)
            return this._map.layerPointToLatLng(Kt[0]);
          for (t = 0, I = 0; t < ee - 1; t++)
            if (Y = Kt[t], dt = Kt[t + 1], w = Y.distanceTo(dt), I += w, I > e)
              return Nt = (I - e) / w, this._map.layerPointToLatLng([
                dt.x - Nt * (dt.x - Y.x),
                dt.y - Nt * (dt.y - Y.y)
              ]);
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          return this._bounds;
        },
        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function(t, e) {
          return e = e || this._defaultShape(), t = at(t), e.push(t), this._bounds.extend(t), this.redraw();
        },
        _setLatLngs: function(t) {
          this._bounds = new xt(), this._latlngs = this._convertLatLngs(t);
        },
        _defaultShape: function() {
          return Dn(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function(t) {
          for (var e = [], w = Dn(t), I = 0, Y = t.length; I < Y; I++)
            w ? (e[I] = at(t[I]), this._bounds.extend(e[I])) : e[I] = this._convertLatLngs(t[I]);
          return e;
        },
        _project: function() {
          var t = new V();
          this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t), this._bounds.isValid() && t.isValid() && (this._rawPxBounds = t, this._updateBounds());
        },
        _updateBounds: function() {
          var t = this._clickTolerance(), e = new nt(t, t);
          this._rawPxBounds && (this._pxBounds = new V([
            this._rawPxBounds.min.subtract(e),
            this._rawPxBounds.max.add(e)
          ]));
        },
        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function(t, e, w) {
          var I = t[0] instanceof pt, Y = t.length, dt, Nt;
          if (I) {
            for (Nt = [], dt = 0; dt < Y; dt++)
              Nt[dt] = this._map.latLngToLayerPoint(t[dt]), w.extend(Nt[dt]);
            e.push(Nt);
          } else
            for (dt = 0; dt < Y; dt++)
              this._projectLatlngs(t[dt], e, w);
        },
        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function() {
          var t = this._renderer._bounds;
          if (this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(t))) {
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var e = this._parts, w, I, Y, dt, Nt, Kt, ee;
            for (w = 0, Y = 0, dt = this._rings.length; w < dt; w++)
              for (ee = this._rings[w], I = 0, Nt = ee.length; I < Nt - 1; I++)
                Kt = Rr(ee[I], ee[I + 1], t, I, !0), Kt && (e[Y] = e[Y] || [], e[Y].push(Kt[0]), (Kt[1] !== ee[I + 1] || I === Nt - 2) && (e[Y].push(Kt[1]), Y++));
          }
        },
        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function() {
          for (var t = this._parts, e = this.options.smoothFactor, w = 0, I = t.length; w < I; w++)
            t[w] = Pr(t[w], e);
        },
        _update: function() {
          this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
        },
        _updatePath: function() {
          this._renderer._updatePoly(this);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(t, e) {
          var w, I, Y, dt, Nt, Kt, ee = this._clickTolerance();
          if (!this._pxBounds || !this._pxBounds.contains(t))
            return !1;
          for (w = 0, dt = this._parts.length; w < dt; w++)
            for (Kt = this._parts[w], I = 0, Nt = Kt.length, Y = Nt - 1; I < Nt; Y = I++)
              if (!(!e && I === 0) && jr(t, Kt[Y], Kt[I]) <= ee)
                return !0;
          return !1;
        }
      });
      function wi(t, e) {
        return new $n(t, e);
      }
      $n._flat = Ir;
      var Jn = $n.extend({
        options: {
          fill: !0
        },
        isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length;
        },
        getCenter: function() {
          if (!this._map)
            throw new Error("Must add layer to map before using getCenter()");
          var t, e, w, I, Y, dt, Nt, Kt, ee, ue = this._rings[0], Pe = ue.length;
          if (!Pe)
            return null;
          for (dt = Nt = Kt = 0, t = 0, e = Pe - 1; t < Pe; e = t++)
            w = ue[t], I = ue[e], Y = w.y * I.x - I.y * w.x, Nt += (w.x + I.x) * Y, Kt += (w.y + I.y) * Y, dt += Y * 3;
          return dt === 0 ? ee = ue[0] : ee = [Nt / dt, Kt / dt], this._map.layerPointToLatLng(ee);
        },
        _convertLatLngs: function(t) {
          var e = $n.prototype._convertLatLngs.call(this, t), w = e.length;
          return w >= 2 && e[0] instanceof pt && e[0].equals(e[w - 1]) && e.pop(), e;
        },
        _setLatLngs: function(t) {
          $n.prototype._setLatLngs.call(this, t), Dn(this._latlngs) && (this._latlngs = [this._latlngs]);
        },
        _defaultShape: function() {
          return Dn(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function() {
          var t = this._renderer._bounds, e = this.options.weight, w = new nt(e, e);
          if (t = new V(t.min.subtract(w), t.max.add(w)), this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(t))) {
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var I = 0, Y = this._rings.length, dt; I < Y; I++)
              dt = Mr(this._rings[I], t, !0), dt.length && this._parts.push(dt);
          }
        },
        _updatePath: function() {
          this._renderer._updatePoly(this, !0);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(t) {
          var e = !1, w, I, Y, dt, Nt, Kt, ee, ue;
          if (!this._pxBounds || !this._pxBounds.contains(t))
            return !1;
          for (dt = 0, ee = this._parts.length; dt < ee; dt++)
            for (w = this._parts[dt], Nt = 0, ue = w.length, Kt = ue - 1; Nt < ue; Kt = Nt++)
              I = w[Nt], Y = w[Kt], I.y > t.y != Y.y > t.y && t.x < (Y.x - I.x) * (t.y - I.y) / (Y.y - I.y) + I.x && (e = !e);
          return e || $n.prototype._containsPoint.call(this, t, !0);
        }
      });
      function Ei(t, e) {
        return new Jn(t, e);
      }
      var Bn = Kn.extend({
        /* @section
         * @aka GeoJSON options
         *
         * @option pointToLayer: Function = *
         * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
         * called when data is added, passing the GeoJSON point feature and its `LatLng`.
         * The default is to spawn a default `Marker`:
         * ```js
         * function(geoJsonPoint, latlng) {
         * 	return L.marker(latlng);
         * }
         * ```
         *
         * @option style: Function = *
         * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
         * called internally when data is added.
         * The default value is to not override any defaults:
         * ```js
         * function (geoJsonFeature) {
         * 	return {}
         * }
         * ```
         *
         * @option onEachFeature: Function = *
         * A `Function` that will be called once for each created `Feature`, after it has
         * been created and styled. Useful for attaching events and popups to features.
         * The default is to do nothing with the newly created layers:
         * ```js
         * function (feature, layer) {}
         * ```
         *
         * @option filter: Function = *
         * A `Function` that will be used to decide whether to include a feature or not.
         * The default is to include all features:
         * ```js
         * function (geoJsonFeature) {
         * 	return true;
         * }
         * ```
         * Note: dynamically changing the `filter` option will have effect only on newly
         * added data. It will _not_ re-evaluate already included features.
         *
         * @option coordsToLatLng: Function = *
         * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
         * The default is the `coordsToLatLng` static method.
         *
         * @option markersInheritOptions: Boolean = false
         * Whether default Markers for "Point" type Features inherit from group options.
         */
        initialize: function(t, e) {
          h(this, e), this._layers = {}, t && this.addData(t);
        },
        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function(t) {
          var e = d(t) ? t : t.features, w, I, Y;
          if (e) {
            for (w = 0, I = e.length; w < I; w++)
              Y = e[w], (Y.geometries || Y.geometry || Y.features || Y.coordinates) && this.addData(Y);
            return this;
          }
          var dt = this.options;
          if (dt.filter && !dt.filter(t))
            return this;
          var Nt = xr(t, dt);
          return Nt ? (Nt.feature = fr(t), Nt.defaultOptions = Nt.options, this.resetStyle(Nt), dt.onEachFeature && dt.onEachFeature(t, Nt), this.addLayer(Nt)) : this;
        },
        // @method resetStyle( <Path> layer? ): this
        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
        // If `layer` is omitted, the style of all features in the current layer is reset.
        resetStyle: function(t) {
          return t === void 0 ? this.eachLayer(this.resetStyle, this) : (t.options = v({}, t.defaultOptions), this._setLayerStyle(t, this.options.style), this);
        },
        // @method setStyle( <Function> style ): this
        // Changes styles of GeoJSON vector layers with the given style function.
        setStyle: function(t) {
          return this.eachLayer(function(e) {
            this._setLayerStyle(e, t);
          }, this);
        },
        _setLayerStyle: function(t, e) {
          t.setStyle && (typeof e == "function" && (e = e(t.feature)), t.setStyle(e));
        }
      });
      function xr(t, e) {
        var w = t.type === "Feature" ? t.geometry : t, I = w ? w.coordinates : null, Y = [], dt = e && e.pointToLayer, Nt = e && e.coordsToLatLng || Sr, Kt, ee, ue, Pe;
        if (!I && !w)
          return null;
        switch (w.type) {
          case "Point":
            return Kt = Nt(I), $r(dt, t, Kt, e);
          case "MultiPoint":
            for (ue = 0, Pe = I.length; ue < Pe; ue++)
              Kt = Nt(I[ue]), Y.push($r(dt, t, Kt, e));
            return new Kn(Y);
          case "LineString":
          case "MultiLineString":
            return ee = ur(I, w.type === "LineString" ? 0 : 1, Nt), new $n(ee, e);
          case "Polygon":
          case "MultiPolygon":
            return ee = ur(I, w.type === "Polygon" ? 1 : 2, Nt), new Jn(ee, e);
          case "GeometryCollection":
            for (ue = 0, Pe = w.geometries.length; ue < Pe; ue++) {
              var Xe = xr({
                geometry: w.geometries[ue],
                type: "Feature",
                properties: t.properties
              }, e);
              Xe && Y.push(Xe);
            }
            return new Kn(Y);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function $r(t, e, w, I) {
        return t ? t(e, w) : new sr(w, I && I.markersInheritOptions && I);
      }
      function Sr(t) {
        return new pt(t[1], t[0], t[2]);
      }
      function ur(t, e, w) {
        for (var I = [], Y = 0, dt = t.length, Nt; Y < dt; Y++)
          Nt = e ? ur(t[Y], e - 1, w) : (w || Sr)(t[Y]), I.push(Nt);
        return I;
      }
      function kr(t, e) {
        return t = at(t), t.alt !== void 0 ? [f(t.lng, e), f(t.lat, e), f(t.alt, e)] : [f(t.lng, e), f(t.lat, e)];
      }
      function cr(t, e, w, I) {
        for (var Y = [], dt = 0, Nt = t.length; dt < Nt; dt++)
          Y.push(e ? cr(t[dt], e - 1, w, I) : kr(t[dt], I));
        return !e && w && Y.push(Y[0]), Y;
      }
      function Xn(t, e) {
        return t.feature ? v({}, t.feature, { geometry: e }) : fr(e);
      }
      function fr(t) {
        return t.type === "Feature" || t.type === "FeatureCollection" ? t : {
          type: "Feature",
          properties: {},
          geometry: t
        };
      }
      var Tr = {
        toGeoJSON: function(t) {
          return Xn(this, {
            type: "Point",
            coordinates: kr(this.getLatLng(), t)
          });
        }
      };
      sr.include(Tr), Er.include(Tr), lr.include(Tr), $n.include({
        toGeoJSON: function(t) {
          var e = !Dn(this._latlngs), w = cr(this._latlngs, e ? 1 : 0, !1, t);
          return Xn(this, {
            type: (e ? "Multi" : "") + "LineString",
            coordinates: w
          });
        }
      }), Jn.include({
        toGeoJSON: function(t) {
          var e = !Dn(this._latlngs), w = e && !Dn(this._latlngs[0]), I = cr(this._latlngs, w ? 2 : e ? 1 : 0, !0, t);
          return e || (I = [I]), Xn(this, {
            type: (w ? "Multi" : "") + "Polygon",
            coordinates: I
          });
        }
      }), qn.include({
        toMultiPoint: function(t) {
          var e = [];
          return this.eachLayer(function(w) {
            e.push(w.toGeoJSON(t).geometry.coordinates);
          }), Xn(this, {
            type: "MultiPoint",
            coordinates: e
          });
        },
        // @method toGeoJSON(precision?: Number|false): Object
        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
        toGeoJSON: function(t) {
          var e = this.feature && this.feature.geometry && this.feature.geometry.type;
          if (e === "MultiPoint")
            return this.toMultiPoint(t);
          var w = e === "GeometryCollection", I = [];
          return this.eachLayer(function(Y) {
            if (Y.toGeoJSON) {
              var dt = Y.toGeoJSON(t);
              if (w)
                I.push(dt.geometry);
              else {
                var Nt = fr(dt);
                Nt.type === "FeatureCollection" ? I.push.apply(I, Nt.features) : I.push(Nt);
              }
            }
          }), w ? Xn(this, {
            geometries: I,
            type: "GeometryCollection"
          }) : {
            type: "FeatureCollection",
            features: I
          };
        }
      });
      function Br(t, e) {
        return new Bn(t, e);
      }
      var xi = Br, hr = In.extend({
        // @section
        // @aka ImageOverlay options
        options: {
          // @option opacity: Number = 1.0
          // The opacity of the image overlay.
          opacity: 1,
          // @option alt: String = ''
          // Text for the `alt` attribute of the image (useful for accessibility).
          alt: "",
          // @option interactive: Boolean = false
          // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
          interactive: !1,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the image.
          // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1,
          // @option errorOverlayUrl: String = ''
          // URL to the overlay image to show in place of the overlay that failed to load.
          errorOverlayUrl: "",
          // @option zIndex: Number = 1
          // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
          zIndex: 1,
          // @option className: String = ''
          // A custom class name to assign to the image. Empty by default.
          className: ""
        },
        initialize: function(t, e, w) {
          this._url = t, this._bounds = Ut(e), h(this, w);
        },
        onAdd: function() {
          this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (gt(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset();
        },
        onRemove: function() {
          Re(this._image), this.options.interactive && this.removeInteractiveTarget(this._image);
        },
        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function(t) {
          return this.options.opacity = t, this._image && this._updateOpacity(), this;
        },
        setStyle: function(t) {
          return t.opacity && this.setOpacity(t.opacity), this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function() {
          return this._map && cn(this._image), this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function() {
          return this._map && J(this._image), this;
        },
        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function(t) {
          return this._url = t, this._image && (this._image.src = t), this;
        },
        // @method setBounds(bounds: LatLngBounds): this
        // Update the bounds that this ImageOverlay covers
        setBounds: function(t) {
          return this._bounds = Ut(t), this._map && this._reset(), this;
        },
        getEvents: function() {
          var t = {
            zoom: this._reset,
            viewreset: this._reset
          };
          return this._zoomAnimated && (t.zoomanim = this._animateZoom), t;
        },
        // @method setZIndex(value: Number): this
        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
        setZIndex: function(t) {
          return this.options.zIndex = t, this._updateZIndex(), this;
        },
        // @method getBounds(): LatLngBounds
        // Get the bounds that this ImageOverlay covers
        getBounds: function() {
          return this._bounds;
        },
        // @method getElement(): HTMLElement
        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
        // used by this overlay.
        getElement: function() {
          return this._image;
        },
        _initImage: function() {
          var t = this._url.tagName === "IMG", e = this._image = t ? this._url : Te("img");
          if (gt(e, "leaflet-image-layer"), this._zoomAnimated && gt(e, "leaflet-zoom-animated"), this.options.className && gt(e, this.options.className), e.onselectstart = a, e.onmousemove = a, e.onload = i(this.fire, this, "load"), e.onerror = i(this._overlayOnError, this, "error"), (this.options.crossOrigin || this.options.crossOrigin === "") && (e.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), t) {
            this._url = e.src;
            return;
          }
          e.src = this._url, e.alt = this.options.alt;
        },
        _animateZoom: function(t) {
          var e = this._map.getZoomScale(t.zoom), w = this._map._latLngBoundsToNewLayerBounds(this._bounds, t.zoom, t.center).min;
          Ke(this._image, w, e);
        },
        _reset: function() {
          var t = this._image, e = new V(
            this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
            this._map.latLngToLayerPoint(this._bounds.getSouthEast())
          ), w = e.getSize();
          Ae(t, e.min), t.style.width = w.x + "px", t.style.height = w.y + "px";
        },
        _updateOpacity: function() {
          vt(this._image, this.options.opacity);
        },
        _updateZIndex: function() {
          this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._image.style.zIndex = this.options.zIndex);
        },
        _overlayOnError: function() {
          this.fire("error");
          var t = this.options.errorOverlayUrl;
          t && this._url !== t && (this._url = t, this._image.src = t);
        },
        // @method getCenter(): LatLng
        // Returns the center of the ImageOverlay.
        getCenter: function() {
          return this._bounds.getCenter();
        }
      }), Si = function(t, e, w) {
        return new hr(t, e, w);
      }, zr = hr.extend({
        // @section
        // @aka VideoOverlay options
        options: {
          // @option autoplay: Boolean = true
          // Whether the video starts playing automatically when loaded.
          // On some browsers autoplay will only work with `muted: true`
          autoplay: !0,
          // @option loop: Boolean = true
          // Whether the video will loop back to the beginning when played.
          loop: !0,
          // @option keepAspectRatio: Boolean = true
          // Whether the video will save aspect ratio after the projection.
          // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
          keepAspectRatio: !0,
          // @option muted: Boolean = false
          // Whether the video starts on mute when loaded.
          muted: !1,
          // @option playsInline: Boolean = true
          // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
          playsInline: !0
        },
        _initImage: function() {
          var t = this._url.tagName === "VIDEO", e = this._image = t ? this._url : Te("video");
          if (gt(e, "leaflet-image-layer"), this._zoomAnimated && gt(e, "leaflet-zoom-animated"), this.options.className && gt(e, this.options.className), e.onselectstart = a, e.onmousemove = a, e.onloadeddata = i(this.fire, this, "load"), t) {
            for (var w = e.getElementsByTagName("source"), I = [], Y = 0; Y < w.length; Y++)
              I.push(w[Y].src);
            this._url = w.length > 0 ? I : [e.src];
            return;
          }
          d(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(e.style, "objectFit") && (e.style.objectFit = "fill"), e.autoplay = !!this.options.autoplay, e.loop = !!this.options.loop, e.muted = !!this.options.muted, e.playsInline = !!this.options.playsInline;
          for (var dt = 0; dt < this._url.length; dt++) {
            var Nt = Te("source");
            Nt.src = this._url[dt], e.appendChild(Nt);
          }
        }
        // @method getElement(): HTMLVideoElement
        // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
        // used by this overlay.
      });
      function ki(t, e, w) {
        return new zr(t, e, w);
      }
      var Ur = hr.extend({
        _initImage: function() {
          var t = this._image = this._url;
          gt(t, "leaflet-image-layer"), this._zoomAnimated && gt(t, "leaflet-zoom-animated"), this.options.className && gt(t, this.options.className), t.onselectstart = a, t.onmousemove = a;
        }
        // @method getElement(): SVGElement
        // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
        // used by this overlay.
      });
      function Ti(t, e, w) {
        return new Ur(t, e, w);
      }
      var Nn = In.extend({
        // @section
        // @aka DivOverlay options
        options: {
          // @option interactive: Boolean = false
          // If true, the popup/tooltip will listen to the mouse events.
          interactive: !1,
          // @option offset: Point = Point(0, 0)
          // The offset of the overlay position.
          offset: [0, 0],
          // @option className: String = ''
          // A custom CSS class name to assign to the overlay.
          className: "",
          // @option pane: String = undefined
          // `Map pane` where the overlay will be added.
          pane: void 0
        },
        initialize: function(t, e) {
          h(this, t), this._source = e;
        },
        // @method openOn(map: Map): this
        // Adds the overlay to the map.
        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
        openOn: function(t) {
          return t = arguments.length ? t : this._source._map, t.hasLayer(this) || t.addLayer(this), this;
        },
        // @method close(): this
        // Closes the overlay.
        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
        // and `layer.closePopup()`/`.closeTooltip()`.
        close: function() {
          return this._map && this._map.removeLayer(this), this;
        },
        // @method toggle(layer?: Layer): this
        // Opens or closes the overlay bound to layer depending on its current state.
        // Argument may be omitted only for overlay bound to layer.
        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
        toggle: function(t) {
          return this._map ? this.close() : (arguments.length ? this._source = t : t = this._source, this._prepareOpen(), this.openOn(t._map)), this;
        },
        onAdd: function(t) {
          this._zoomAnimated = t._zoomAnimated, this._container || this._initLayout(), t._fadeAnimated && vt(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), t._fadeAnimated && vt(this._container, 1), this.bringToFront(), this.options.interactive && (gt(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container));
        },
        onRemove: function(t) {
          t._fadeAnimated ? (vt(this._container, 0), this._removeTimeout = setTimeout(i(Re, void 0, this._container), 200)) : Re(this._container), this.options.interactive && (zt(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container));
        },
        // @namespace DivOverlay
        // @method getLatLng: LatLng
        // Returns the geographical point of the overlay.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Sets the geographical point where the overlay will open.
        setLatLng: function(t) {
          return this._latlng = at(t), this._map && (this._updatePosition(), this._adjustPan()), this;
        },
        // @method getContent: String|HTMLElement
        // Returns the content of the overlay.
        getContent: function() {
          return this._content;
        },
        // @method setContent(htmlContent: String|HTMLElement|Function): this
        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
        // The function should return a `String` or `HTMLElement` to be used in the overlay.
        setContent: function(t) {
          return this._content = t, this.update(), this;
        },
        // @method getElement: String|HTMLElement
        // Returns the HTML container of the overlay.
        getElement: function() {
          return this._container;
        },
        // @method update: null
        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
        update: function() {
          this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());
        },
        getEvents: function() {
          var t = {
            zoom: this._updatePosition,
            viewreset: this._updatePosition
          };
          return this._zoomAnimated && (t.zoomanim = this._animateZoom), t;
        },
        // @method isOpen: Boolean
        // Returns `true` when the overlay is visible on the map.
        isOpen: function() {
          return !!this._map && this._map.hasLayer(this);
        },
        // @method bringToFront: this
        // Brings this overlay in front of other overlays (in the same map pane).
        bringToFront: function() {
          return this._map && cn(this._container), this;
        },
        // @method bringToBack: this
        // Brings this overlay to the back of other overlays (in the same map pane).
        bringToBack: function() {
          return this._map && J(this._container), this;
        },
        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
        _prepareOpen: function(t) {
          var e = this._source;
          if (!e._map)
            return !1;
          if (e instanceof Kn) {
            e = null;
            var w = this._source._layers;
            for (var I in w)
              if (w[I]._map) {
                e = w[I];
                break;
              }
            if (!e)
              return !1;
            this._source = e;
          }
          if (!t)
            if (e.getCenter)
              t = e.getCenter();
            else if (e.getLatLng)
              t = e.getLatLng();
            else if (e.getBounds)
              t = e.getBounds().getCenter();
            else
              throw new Error("Unable to get source layer LatLng.");
          return this.setLatLng(t), this._map && this.update(), !0;
        },
        _updateContent: function() {
          if (this._content) {
            var t = this._contentNode, e = typeof this._content == "function" ? this._content(this._source || this) : this._content;
            if (typeof e == "string")
              t.innerHTML = e;
            else {
              for (; t.hasChildNodes(); )
                t.removeChild(t.firstChild);
              t.appendChild(e);
            }
            this.fire("contentupdate");
          }
        },
        _updatePosition: function() {
          if (this._map) {
            var t = this._map.latLngToLayerPoint(this._latlng), e = ut(this.options.offset), w = this._getAnchor();
            this._zoomAnimated ? Ae(this._container, t.add(w)) : e = e.add(t).add(w);
            var I = this._containerBottom = -e.y, Y = this._containerLeft = -Math.round(this._containerWidth / 2) + e.x;
            this._container.style.bottom = I + "px", this._container.style.left = Y + "px";
          }
        },
        _getAnchor: function() {
          return [0, 0];
        }
      });
      xe.include({
        _initOverlay: function(t, e, w, I) {
          var Y = e;
          return Y instanceof t || (Y = new t(I).setContent(e)), w && Y.setLatLng(w), Y;
        }
      }), In.include({
        _initOverlay: function(t, e, w, I) {
          var Y = w;
          return Y instanceof t ? (h(Y, I), Y._source = this) : (Y = e && !I ? e : new t(I, this), Y.setContent(w)), Y;
        }
      });
      var dr = Nn.extend({
        // @section
        // @aka Popup options
        options: {
          // @option pane: String = 'popupPane'
          // `Map pane` where the popup will be added.
          pane: "popupPane",
          // @option offset: Point = Point(0, 7)
          // The offset of the popup position.
          offset: [0, 7],
          // @option maxWidth: Number = 300
          // Max width of the popup, in pixels.
          maxWidth: 300,
          // @option minWidth: Number = 50
          // Min width of the popup, in pixels.
          minWidth: 50,
          // @option maxHeight: Number = null
          // If set, creates a scrollable container of the given height
          // inside a popup if its content exceeds it.
          maxHeight: null,
          // @option autoPan: Boolean = true
          // Set it to `false` if you don't want the map to do panning animation
          // to fit the opened popup.
          autoPan: !0,
          // @option autoPanPaddingTopLeft: Point = null
          // The margin between the popup and the top left corner of the map
          // view after autopanning was performed.
          autoPanPaddingTopLeft: null,
          // @option autoPanPaddingBottomRight: Point = null
          // The margin between the popup and the bottom right corner of the map
          // view after autopanning was performed.
          autoPanPaddingBottomRight: null,
          // @option autoPanPadding: Point = Point(5, 5)
          // Equivalent of setting both top left and bottom right autopan padding to the same value.
          autoPanPadding: [5, 5],
          // @option keepInView: Boolean = false
          // Set it to `true` if you want to prevent users from panning the popup
          // off of the screen while it is open.
          keepInView: !1,
          // @option closeButton: Boolean = true
          // Controls the presence of a close button in the popup.
          closeButton: !0,
          // @option autoClose: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the popup closing when another popup is opened.
          autoClose: !0,
          // @option closeOnEscapeKey: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the ESC key for closing of the popup.
          closeOnEscapeKey: !0,
          // @option closeOnClick: Boolean = *
          // Set it if you want to override the default behavior of the popup closing when user clicks
          // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
          // @option className: String = ''
          // A custom CSS class name to assign to the popup.
          className: ""
        },
        // @namespace Popup
        // @method openOn(map: Map): this
        // Alternative to `map.openPopup(popup)`.
        // Adds the popup to the map and closes the previous one.
        openOn: function(t) {
          return t = arguments.length ? t : this._source._map, !t.hasLayer(this) && t._popup && t._popup.options.autoClose && t.removeLayer(t._popup), t._popup = this, Nn.prototype.openOn.call(this, t);
        },
        onAdd: function(t) {
          Nn.prototype.onAdd.call(this, t), t.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, !0), this._source instanceof Fn || this._source.on("preclick", Ve));
        },
        onRemove: function(t) {
          Nn.prototype.onRemove.call(this, t), t.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, !0), this._source instanceof Fn || this._source.off("preclick", Ve));
        },
        getEvents: function() {
          var t = Nn.prototype.getEvents.call(this);
          return (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this.close), this.options.keepInView && (t.moveend = this._adjustPan), t;
        },
        _initLayout: function() {
          var t = "leaflet-popup", e = this._container = Te(
            "div",
            t + " " + (this.options.className || "") + " leaflet-zoom-animated"
          ), w = this._wrapper = Te("div", t + "-content-wrapper", e);
          if (this._contentNode = Te("div", t + "-content", w), mn(e), Cn(this._contentNode), Ee(e, "contextmenu", Ve), this._tipContainer = Te("div", t + "-tip-container", e), this._tip = Te("div", t + "-tip", this._tipContainer), this.options.closeButton) {
            var I = this._closeButton = Te("a", t + "-close-button", e);
            I.setAttribute("role", "button"), I.setAttribute("aria-label", "Close popup"), I.href = "#close", I.innerHTML = '<span aria-hidden="true">&#215;</span>', Ee(I, "click", this.close, this);
          }
        },
        _updateLayout: function() {
          var t = this._contentNode, e = t.style;
          e.width = "", e.whiteSpace = "nowrap";
          var w = t.offsetWidth;
          w = Math.min(w, this.options.maxWidth), w = Math.max(w, this.options.minWidth), e.width = w + 1 + "px", e.whiteSpace = "", e.height = "";
          var I = t.offsetHeight, Y = this.options.maxHeight, dt = "leaflet-popup-scrolled";
          Y && I > Y ? (e.height = Y + "px", gt(t, dt)) : zt(t, dt), this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function(t) {
          var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center), w = this._getAnchor();
          Ae(this._container, e.add(w));
        },
        _adjustPan: function(t) {
          if (this.options.autoPan) {
            this._map._panAnim && this._map._panAnim.stop();
            var e = this._map, w = parseInt(Le(this._container, "marginBottom"), 10) || 0, I = this._container.offsetHeight + w, Y = this._containerWidth, dt = new nt(this._containerLeft, -I - this._containerBottom);
            dt._add(le(this._container));
            var Nt = e.layerPointToContainerPoint(dt), Kt = ut(this.options.autoPanPadding), ee = ut(this.options.autoPanPaddingTopLeft || Kt), ue = ut(this.options.autoPanPaddingBottomRight || Kt), Pe = e.getSize(), Xe = 0, tn = 0;
            Nt.x + Y + ue.x > Pe.x && (Xe = Nt.x + Y - Pe.x + ue.x), Nt.x - Xe - ee.x < 0 && (Xe = Nt.x - ee.x), Nt.y + I + ue.y > Pe.y && (tn = Nt.y + I - Pe.y + ue.y), Nt.y - tn - ee.y < 0 && (tn = Nt.y - ee.y), (Xe || tn) && e.fire("autopanstart").panBy([Xe, tn], { animate: t && t.type === "moveend" });
          }
        },
        _getAnchor: function() {
          return ut(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
        }
      }), Ai = function(t, e) {
        return new dr(t, e);
      };
      xe.mergeOptions({
        closePopupOnClick: !0
      }), xe.include({
        // @method openPopup(popup: Popup): this
        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
        // @alternative
        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
        // Creates a popup with the specified content and options and opens it in the given point on a map.
        openPopup: function(t, e, w) {
          return this._initOverlay(dr, t, e, w).openOn(this), this;
        },
        // @method closePopup(popup?: Popup): this
        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
        closePopup: function(t) {
          return t = arguments.length ? t : this._popup, t && t.close(), this;
        }
      }), In.include({
        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
        // Binds a popup to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindPopup: function(t, e) {
          return this._popup = this._initOverlay(dr, this._popup, t, e), this._popupHandlersAdded || (this.on({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          }), this._popupHandlersAdded = !0), this;
        },
        // @method unbindPopup(): this
        // Removes the popup previously bound with `bindPopup`.
        unbindPopup: function() {
          return this._popup && (this.off({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          }), this._popupHandlersAdded = !1, this._popup = null), this;
        },
        // @method openPopup(latlng?: LatLng): this
        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
        openPopup: function(t) {
          return this._popup && this._popup._prepareOpen(t) && this._popup.openOn(this._map), this;
        },
        // @method closePopup(): this
        // Closes the popup bound to this layer if it is open.
        closePopup: function() {
          return this._popup && this._popup.close(), this;
        },
        // @method togglePopup(): this
        // Opens or closes the popup bound to this layer depending on its current state.
        togglePopup: function() {
          return this._popup && this._popup.toggle(this), this;
        },
        // @method isPopupOpen(): boolean
        // Returns `true` if the popup bound to this layer is currently open.
        isPopupOpen: function() {
          return this._popup ? this._popup.isOpen() : !1;
        },
        // @method setPopupContent(content: String|HTMLElement|Popup): this
        // Sets the content of the popup bound to this layer.
        setPopupContent: function(t) {
          return this._popup && this._popup.setContent(t), this;
        },
        // @method getPopup(): Popup
        // Returns the popup bound to this layer.
        getPopup: function() {
          return this._popup;
        },
        _openPopup: function(t) {
          if (!(!this._popup || !this._map)) {
            Tt(t);
            var e = t.layer || t.target;
            if (this._popup._source === e && !(e instanceof Fn)) {
              this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(t.latlng);
              return;
            }
            this._popup._source = e, this.openPopup(t.latlng);
          }
        },
        _movePopup: function(t) {
          this._popup.setLatLng(t.latlng);
        },
        _onKeyPress: function(t) {
          t.originalEvent.keyCode === 13 && this._openPopup(t);
        }
      });
      var pr = Nn.extend({
        // @section
        // @aka Tooltip options
        options: {
          // @option pane: String = 'tooltipPane'
          // `Map pane` where the tooltip will be added.
          pane: "tooltipPane",
          // @option offset: Point = Point(0, 0)
          // Optional offset of the tooltip position.
          offset: [0, 0],
          // @option direction: String = 'auto'
          // Direction where to open the tooltip. Possible values are: `right`, `left`,
          // `top`, `bottom`, `center`, `auto`.
          // `auto` will dynamically switch between `right` and `left` according to the tooltip
          // position on the map.
          direction: "auto",
          // @option permanent: Boolean = false
          // Whether to open the tooltip permanently or only on mouseover.
          permanent: !1,
          // @option sticky: Boolean = false
          // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
          sticky: !1,
          // @option opacity: Number = 0.9
          // Tooltip container opacity.
          opacity: 0.9
        },
        onAdd: function(t) {
          Nn.prototype.onAdd.call(this, t), this.setOpacity(this.options.opacity), t.fire("tooltipopen", { tooltip: this }), this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", { tooltip: this }, !0));
        },
        onRemove: function(t) {
          Nn.prototype.onRemove.call(this, t), t.fire("tooltipclose", { tooltip: this }), this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", { tooltip: this }, !0));
        },
        getEvents: function() {
          var t = Nn.prototype.getEvents.call(this);
          return this.options.permanent || (t.preclick = this.close), t;
        },
        _initLayout: function() {
          var t = "leaflet-tooltip", e = t + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = Te("div", e);
        },
        _updateLayout: function() {
        },
        _adjustPan: function() {
        },
        _setPosition: function(t) {
          var e, w, I = this._map, Y = this._container, dt = I.latLngToContainerPoint(I.getCenter()), Nt = I.layerPointToContainerPoint(t), Kt = this.options.direction, ee = Y.offsetWidth, ue = Y.offsetHeight, Pe = ut(this.options.offset), Xe = this._getAnchor();
          Kt === "top" ? (e = ee / 2, w = ue) : Kt === "bottom" ? (e = ee / 2, w = 0) : Kt === "center" ? (e = ee / 2, w = ue / 2) : Kt === "right" ? (e = 0, w = ue / 2) : Kt === "left" ? (e = ee, w = ue / 2) : Nt.x < dt.x ? (Kt = "right", e = 0, w = ue / 2) : (Kt = "left", e = ee + (Pe.x + Xe.x) * 2, w = ue / 2), t = t.subtract(ut(e, w, !0)).add(Pe).add(Xe), zt(Y, "leaflet-tooltip-right"), zt(Y, "leaflet-tooltip-left"), zt(Y, "leaflet-tooltip-top"), zt(Y, "leaflet-tooltip-bottom"), gt(Y, "leaflet-tooltip-" + Kt), Ae(Y, t);
        },
        _updatePosition: function() {
          var t = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(t);
        },
        setOpacity: function(t) {
          this.options.opacity = t, this._container && vt(this._container, t);
        },
        _animateZoom: function(t) {
          var e = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
          this._setPosition(e);
        },
        _getAnchor: function() {
          return ut(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
        }
      }), Oi = function(t, e) {
        return new pr(t, e);
      };
      xe.include({
        // @method openTooltip(tooltip: Tooltip): this
        // Opens the specified tooltip.
        // @alternative
        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
        // Creates a tooltip with the specified content and options and open it.
        openTooltip: function(t, e, w) {
          return this._initOverlay(pr, t, e, w).openOn(this), this;
        },
        // @method closeTooltip(tooltip: Tooltip): this
        // Closes the tooltip given as parameter.
        closeTooltip: function(t) {
          return t.close(), this;
        }
      }), In.include({
        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
        // Binds a tooltip to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindTooltip: function(t, e) {
          return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(pr, this._tooltip, t, e), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this;
        },
        // @method unbindTooltip(): this
        // Removes the tooltip previously bound with `bindTooltip`.
        unbindTooltip: function() {
          return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this;
        },
        _initTooltipInteractions: function(t) {
          if (!(!t && this._tooltipHandlersAdded)) {
            var e = t ? "off" : "on", w = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            this._tooltip.options.permanent ? w.add = this._openTooltip : (w.mouseover = this._openTooltip, w.mouseout = this.closeTooltip, w.click = this._openTooltip), this._tooltip.options.sticky && (w.mousemove = this._moveTooltip), this[e](w), this._tooltipHandlersAdded = !t;
          }
        },
        // @method openTooltip(latlng?: LatLng): this
        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
        openTooltip: function(t) {
          return this._tooltip && this._tooltip._prepareOpen(t) && this._tooltip.openOn(this._map), this;
        },
        // @method closeTooltip(): this
        // Closes the tooltip bound to this layer if it is open.
        closeTooltip: function() {
          if (this._tooltip)
            return this._tooltip.close();
        },
        // @method toggleTooltip(): this
        // Opens or closes the tooltip bound to this layer depending on its current state.
        toggleTooltip: function() {
          return this._tooltip && this._tooltip.toggle(this), this;
        },
        // @method isTooltipOpen(): boolean
        // Returns `true` if the tooltip bound to this layer is currently open.
        isTooltipOpen: function() {
          return this._tooltip.isOpen();
        },
        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
        // Sets the content of the tooltip bound to this layer.
        setTooltipContent: function(t) {
          return this._tooltip && this._tooltip.setContent(t), this;
        },
        // @method getTooltip(): Tooltip
        // Returns the tooltip bound to this layer.
        getTooltip: function() {
          return this._tooltip;
        },
        _openTooltip: function(t) {
          !this._tooltip || !this._map || this._map.dragging && this._map.dragging.moving() || (this._tooltip._source = t.layer || t.target, this.openTooltip(this._tooltip.options.sticky ? t.latlng : void 0));
        },
        _moveTooltip: function(t) {
          var e = t.latlng, w, I;
          this._tooltip.options.sticky && t.originalEvent && (w = this._map.mouseEventToContainerPoint(t.originalEvent), I = this._map.containerPointToLayerPoint(w), e = this._map.layerPointToLatLng(I)), this._tooltip.setLatLng(e);
        }
      });
      var Fr = Yn.extend({
        options: {
          // @section
          // @aka DivIcon options
          iconSize: [12, 12],
          // also can be set through CSS
          // iconAnchor: (Point),
          // popupAnchor: (Point),
          // @option html: String|HTMLElement = ''
          // Custom HTML code to put inside the div element, empty by default. Alternatively,
          // an instance of `HTMLElement`.
          html: !1,
          // @option bgPos: Point = [0, 0]
          // Optional relative position of the background, in pixels
          bgPos: null,
          className: "leaflet-div-icon"
        },
        createIcon: function(t) {
          var e = t && t.tagName === "DIV" ? t : document.createElement("div"), w = this.options;
          if (w.html instanceof Element ? (en(e), e.appendChild(w.html)) : e.innerHTML = w.html !== !1 ? w.html : "", w.bgPos) {
            var I = ut(w.bgPos);
            e.style.backgroundPosition = -I.x + "px " + -I.y + "px";
          }
          return this._setIconStyles(e, "icon"), e;
        },
        createShadow: function() {
          return null;
        }
      });
      function Li(t) {
        return new Fr(t);
      }
      Yn.Default = nr;
      var rr = In.extend({
        // @section
        // @aka GridLayer options
        options: {
          // @option tileSize: Number|Point = 256
          // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
          tileSize: 256,
          // @option opacity: Number = 1.0
          // Opacity of the tiles. Can be used in the `createTile()` function.
          opacity: 1,
          // @option updateWhenIdle: Boolean = (depends)
          // Load new tiles only when panning ends.
          // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
          // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
          // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
          updateWhenIdle: Et.mobile,
          // @option updateWhenZooming: Boolean = true
          // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
          updateWhenZooming: !0,
          // @option updateInterval: Number = 200
          // Tiles will not update more than once every `updateInterval` milliseconds when panning.
          updateInterval: 200,
          // @option zIndex: Number = 1
          // The explicit zIndex of the tile layer.
          zIndex: 1,
          // @option bounds: LatLngBounds = undefined
          // If set, tiles will only be loaded inside the set `LatLngBounds`.
          bounds: null,
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = undefined
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: void 0,
          // @option maxNativeZoom: Number = undefined
          // Maximum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
          // from `maxNativeZoom` level and auto-scaled.
          maxNativeZoom: void 0,
          // @option minNativeZoom: Number = undefined
          // Minimum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
          // from `minNativeZoom` level and auto-scaled.
          minNativeZoom: void 0,
          // @option noWrap: Boolean = false
          // Whether the layer is wrapped around the antimeridian. If `true`, the
          // GridLayer will only be displayed once at low zoom levels. Has no
          // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
          // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
          // tiles outside the CRS limits.
          noWrap: !1,
          // @option pane: String = 'tilePane'
          // `Map pane` where the grid layer will be added.
          pane: "tilePane",
          // @option className: String = ''
          // A custom class name to assign to the tile layer. Empty by default.
          className: "",
          // @option keepBuffer: Number = 2
          // When panning the map, keep this many rows and columns of tiles before unloading them.
          keepBuffer: 2
        },
        initialize: function(t) {
          h(this, t);
        },
        onAdd: function() {
          this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView();
        },
        beforeAdd: function(t) {
          t._addZoomLimit(this);
        },
        onRemove: function(t) {
          this._removeAllTiles(), Re(this._container), t._removeZoomLimit(this), this._container = null, this._tileZoom = void 0;
        },
        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function() {
          return this._map && (cn(this._container), this._setAutoZIndex(Math.max)), this;
        },
        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function() {
          return this._map && (J(this._container), this._setAutoZIndex(Math.min)), this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function() {
          return this._container;
        },
        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function(t) {
          return this.options.opacity = t, this._updateOpacity(), this;
        },
        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function(t) {
          return this.options.zIndex = t, this._updateZIndex(), this;
        },
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function() {
          return this._loading;
        },
        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function() {
          if (this._map) {
            this._removeAllTiles();
            var t = this._clampZoom(this._map.getZoom());
            t !== this._tileZoom && (this._tileZoom = t, this._updateLevels()), this._update();
          }
          return this;
        },
        getEvents: function() {
          var t = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
          };
          return this.options.updateWhenIdle || (this._onMove || (this._onMove = o(this._onMoveEnd, this.options.updateInterval, this)), t.move = this._onMove), this._zoomAnimated && (t.zoomanim = this._animateZoom), t;
        },
        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overridden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function() {
          return document.createElement("div");
        },
        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function() {
          var t = this.options.tileSize;
          return t instanceof nt ? t : new nt(t, t);
        },
        _updateZIndex: function() {
          this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._container.style.zIndex = this.options.zIndex);
        },
        _setAutoZIndex: function(t) {
          for (var e = this.getPane().children, w = -t(-1 / 0, 1 / 0), I = 0, Y = e.length, dt; I < Y; I++)
            dt = e[I].style.zIndex, e[I] !== this._container && dt && (w = t(w, +dt));
          isFinite(w) && (this.options.zIndex = w + t(-1, 1), this._updateZIndex());
        },
        _updateOpacity: function() {
          if (this._map && !Et.ielt9) {
            vt(this._container, this.options.opacity);
            var t = +/* @__PURE__ */ new Date(), e = !1, w = !1;
            for (var I in this._tiles) {
              var Y = this._tiles[I];
              if (!(!Y.current || !Y.loaded)) {
                var dt = Math.min(1, (t - Y.loaded) / 200);
                vt(Y.el, dt), dt < 1 ? e = !0 : (Y.active ? w = !0 : this._onOpaqueTile(Y), Y.active = !0);
              }
            }
            w && !this._noPrune && this._pruneTiles(), e && (X(this._fadeFrame), this._fadeFrame = B(this._updateOpacity, this));
          }
        },
        _onOpaqueTile: a,
        _initContainer: function() {
          this._container || (this._container = Te("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));
        },
        _updateLevels: function() {
          var t = this._tileZoom, e = this.options.maxZoom;
          if (t !== void 0) {
            for (var w in this._levels)
              w = Number(w), this._levels[w].el.children.length || w === t ? (this._levels[w].el.style.zIndex = e - Math.abs(t - w), this._onUpdateLevel(w)) : (Re(this._levels[w].el), this._removeTilesAtZoom(w), this._onRemoveLevel(w), delete this._levels[w]);
            var I = this._levels[t], Y = this._map;
            return I || (I = this._levels[t] = {}, I.el = Te("div", "leaflet-tile-container leaflet-zoom-animated", this._container), I.el.style.zIndex = e, I.origin = Y.project(Y.unproject(Y.getPixelOrigin()), t).round(), I.zoom = t, this._setZoomTransform(I, Y.getCenter(), Y.getZoom()), a(I.el.offsetWidth), this._onCreateLevel(I)), this._level = I, I;
          }
        },
        _onUpdateLevel: a,
        _onRemoveLevel: a,
        _onCreateLevel: a,
        _pruneTiles: function() {
          if (this._map) {
            var t, e, w = this._map.getZoom();
            if (w > this.options.maxZoom || w < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (t in this._tiles)
              e = this._tiles[t], e.retain = e.current;
            for (t in this._tiles)
              if (e = this._tiles[t], e.current && !e.active) {
                var I = e.coords;
                this._retainParent(I.x, I.y, I.z, I.z - 5) || this._retainChildren(I.x, I.y, I.z, I.z + 2);
              }
            for (t in this._tiles)
              this._tiles[t].retain || this._removeTile(t);
          }
        },
        _removeTilesAtZoom: function(t) {
          for (var e in this._tiles)
            this._tiles[e].coords.z === t && this._removeTile(e);
        },
        _removeAllTiles: function() {
          for (var t in this._tiles)
            this._removeTile(t);
        },
        _invalidateAll: function() {
          for (var t in this._levels)
            Re(this._levels[t].el), this._onRemoveLevel(Number(t)), delete this._levels[t];
          this._removeAllTiles(), this._tileZoom = void 0;
        },
        _retainParent: function(t, e, w, I) {
          var Y = Math.floor(t / 2), dt = Math.floor(e / 2), Nt = w - 1, Kt = new nt(+Y, +dt);
          Kt.z = +Nt;
          var ee = this._tileCoordsToKey(Kt), ue = this._tiles[ee];
          return ue && ue.active ? (ue.retain = !0, !0) : (ue && ue.loaded && (ue.retain = !0), Nt > I ? this._retainParent(Y, dt, Nt, I) : !1);
        },
        _retainChildren: function(t, e, w, I) {
          for (var Y = 2 * t; Y < 2 * t + 2; Y++)
            for (var dt = 2 * e; dt < 2 * e + 2; dt++) {
              var Nt = new nt(Y, dt);
              Nt.z = w + 1;
              var Kt = this._tileCoordsToKey(Nt), ee = this._tiles[Kt];
              if (ee && ee.active) {
                ee.retain = !0;
                continue;
              } else
                ee && ee.loaded && (ee.retain = !0);
              w + 1 < I && this._retainChildren(Y, dt, w + 1, I);
            }
        },
        _resetView: function(t) {
          var e = t && (t.pinch || t.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), e, e);
        },
        _animateZoom: function(t) {
          this._setView(t.center, t.zoom, !0, t.noUpdate);
        },
        _clampZoom: function(t) {
          var e = this.options;
          return e.minNativeZoom !== void 0 && t < e.minNativeZoom ? e.minNativeZoom : e.maxNativeZoom !== void 0 && e.maxNativeZoom < t ? e.maxNativeZoom : t;
        },
        _setView: function(t, e, w, I) {
          var Y = Math.round(e);
          this.options.maxZoom !== void 0 && Y > this.options.maxZoom || this.options.minZoom !== void 0 && Y < this.options.minZoom ? Y = void 0 : Y = this._clampZoom(Y);
          var dt = this.options.updateWhenZooming && Y !== this._tileZoom;
          (!I || dt) && (this._tileZoom = Y, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), Y !== void 0 && this._update(t), w || this._pruneTiles(), this._noPrune = !!w), this._setZoomTransforms(t, e);
        },
        _setZoomTransforms: function(t, e) {
          for (var w in this._levels)
            this._setZoomTransform(this._levels[w], t, e);
        },
        _setZoomTransform: function(t, e, w) {
          var I = this._map.getZoomScale(w, t.zoom), Y = t.origin.multiplyBy(I).subtract(this._map._getNewPixelOrigin(e, w)).round();
          Et.any3d ? Ke(t.el, Y, I) : Ae(t.el, Y);
        },
        _resetGrid: function() {
          var t = this._map, e = t.options.crs, w = this._tileSize = this.getTileSize(), I = this._tileZoom, Y = this._map.getPixelWorldBounds(this._tileZoom);
          Y && (this._globalTileRange = this._pxBoundsToTileRange(Y)), this._wrapX = e.wrapLng && !this.options.noWrap && [
            Math.floor(t.project([0, e.wrapLng[0]], I).x / w.x),
            Math.ceil(t.project([0, e.wrapLng[1]], I).x / w.y)
          ], this._wrapY = e.wrapLat && !this.options.noWrap && [
            Math.floor(t.project([e.wrapLat[0], 0], I).y / w.x),
            Math.ceil(t.project([e.wrapLat[1], 0], I).y / w.y)
          ];
        },
        _onMoveEnd: function() {
          !this._map || this._map._animatingZoom || this._update();
        },
        _getTiledPixelBounds: function(t) {
          var e = this._map, w = e._animatingZoom ? Math.max(e._animateToZoom, e.getZoom()) : e.getZoom(), I = e.getZoomScale(w, this._tileZoom), Y = e.project(t, this._tileZoom).floor(), dt = e.getSize().divideBy(I * 2);
          return new V(Y.subtract(dt), Y.add(dt));
        },
        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function(t) {
          var e = this._map;
          if (e) {
            var w = this._clampZoom(e.getZoom());
            if (t === void 0 && (t = e.getCenter()), this._tileZoom !== void 0) {
              var I = this._getTiledPixelBounds(t), Y = this._pxBoundsToTileRange(I), dt = Y.getCenter(), Nt = [], Kt = this.options.keepBuffer, ee = new V(
                Y.getBottomLeft().subtract([Kt, -Kt]),
                Y.getTopRight().add([Kt, -Kt])
              );
              if (!(isFinite(Y.min.x) && isFinite(Y.min.y) && isFinite(Y.max.x) && isFinite(Y.max.y)))
                throw new Error("Attempted to load an infinite number of tiles");
              for (var ue in this._tiles) {
                var Pe = this._tiles[ue].coords;
                (Pe.z !== this._tileZoom || !ee.contains(new nt(Pe.x, Pe.y))) && (this._tiles[ue].current = !1);
              }
              if (Math.abs(w - this._tileZoom) > 1) {
                this._setView(t, w);
                return;
              }
              for (var Xe = Y.min.y; Xe <= Y.max.y; Xe++)
                for (var tn = Y.min.x; tn <= Y.max.x; tn++) {
                  var Un = new nt(tn, Xe);
                  if (Un.z = this._tileZoom, !!this._isValidTile(Un)) {
                    var Hn = this._tiles[this._tileCoordsToKey(Un)];
                    Hn ? Hn.current = !0 : Nt.push(Un);
                  }
                }
              if (Nt.sort(function(Zn, Ar) {
                return Zn.distanceTo(dt) - Ar.distanceTo(dt);
              }), Nt.length !== 0) {
                this._loading || (this._loading = !0, this.fire("loading"));
                var gr = document.createDocumentFragment();
                for (tn = 0; tn < Nt.length; tn++)
                  this._addTile(Nt[tn], gr);
                this._level.el.appendChild(gr);
              }
            }
          }
        },
        _isValidTile: function(t) {
          var e = this._map.options.crs;
          if (!e.infinite) {
            var w = this._globalTileRange;
            if (!e.wrapLng && (t.x < w.min.x || t.x > w.max.x) || !e.wrapLat && (t.y < w.min.y || t.y > w.max.y))
              return !1;
          }
          if (!this.options.bounds)
            return !0;
          var I = this._tileCoordsToBounds(t);
          return Ut(this.options.bounds).overlaps(I);
        },
        _keyToBounds: function(t) {
          return this._tileCoordsToBounds(this._keyToTileCoords(t));
        },
        _tileCoordsToNwSe: function(t) {
          var e = this._map, w = this.getTileSize(), I = t.scaleBy(w), Y = I.add(w), dt = e.unproject(I, t.z), Nt = e.unproject(Y, t.z);
          return [dt, Nt];
        },
        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function(t) {
          var e = this._tileCoordsToNwSe(t), w = new xt(e[0], e[1]);
          return this.options.noWrap || (w = this._map.wrapLatLngBounds(w)), w;
        },
        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function(t) {
          return t.x + ":" + t.y + ":" + t.z;
        },
        // converts tile cache key to coordinates
        _keyToTileCoords: function(t) {
          var e = t.split(":"), w = new nt(+e[0], +e[1]);
          return w.z = +e[2], w;
        },
        _removeTile: function(t) {
          var e = this._tiles[t];
          e && (Re(e.el), delete this._tiles[t], this.fire("tileunload", {
            tile: e.el,
            coords: this._keyToTileCoords(t)
          }));
        },
        _initTile: function(t) {
          gt(t, "leaflet-tile");
          var e = this.getTileSize();
          t.style.width = e.x + "px", t.style.height = e.y + "px", t.onselectstart = a, t.onmousemove = a, Et.ielt9 && this.options.opacity < 1 && vt(t, this.options.opacity);
        },
        _addTile: function(t, e) {
          var w = this._getTilePos(t), I = this._tileCoordsToKey(t), Y = this.createTile(this._wrapCoords(t), i(this._tileReady, this, t));
          this._initTile(Y), this.createTile.length < 2 && B(i(this._tileReady, this, t, null, Y)), Ae(Y, w), this._tiles[I] = {
            el: Y,
            coords: t,
            current: !0
          }, e.appendChild(Y), this.fire("tileloadstart", {
            tile: Y,
            coords: t
          });
        },
        _tileReady: function(t, e, w) {
          e && this.fire("tileerror", {
            error: e,
            tile: w,
            coords: t
          });
          var I = this._tileCoordsToKey(t);
          w = this._tiles[I], w && (w.loaded = +/* @__PURE__ */ new Date(), this._map._fadeAnimated ? (vt(w.el, 0), X(this._fadeFrame), this._fadeFrame = B(this._updateOpacity, this)) : (w.active = !0, this._pruneTiles()), e || (gt(w.el, "leaflet-tile-loaded"), this.fire("tileload", {
            tile: w.el,
            coords: t
          })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), Et.ielt9 || !this._map._fadeAnimated ? B(this._pruneTiles, this) : setTimeout(i(this._pruneTiles, this), 250)));
        },
        _getTilePos: function(t) {
          return t.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function(t) {
          var e = new nt(
            this._wrapX ? u(t.x, this._wrapX) : t.x,
            this._wrapY ? u(t.y, this._wrapY) : t.y
          );
          return e.z = t.z, e;
        },
        _pxBoundsToTileRange: function(t) {
          var e = this.getTileSize();
          return new V(
            t.min.unscaleBy(e).floor(),
            t.max.unscaleBy(e).ceil().subtract([1, 1])
          );
        },
        _noTilesToLoad: function() {
          for (var t in this._tiles)
            if (!this._tiles[t].loaded)
              return !1;
          return !0;
        }
      });
      function Pi(t) {
        return new rr(t);
      }
      var Qn = rr.extend({
        // @section
        // @aka TileLayer options
        options: {
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = 18
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: 18,
          // @option subdomains: String|String[] = 'abc'
          // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
          subdomains: "abc",
          // @option errorTileUrl: String = ''
          // URL to the tile image to show in place of the tile that failed to load.
          errorTileUrl: "",
          // @option zoomOffset: Number = 0
          // The zoom number used in tile URLs will be offset with this value.
          zoomOffset: 0,
          // @option tms: Boolean = false
          // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
          tms: !1,
          // @option zoomReverse: Boolean = false
          // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
          zoomReverse: !1,
          // @option detectRetina: Boolean = false
          // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
          detectRetina: !1,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1,
          // @option referrerPolicy: Boolean|String = false
          // Whether the referrerPolicy attribute will be added to the tiles.
          // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
          // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
          // (e.g. to validate an API token).
          // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
          referrerPolicy: !1
        },
        initialize: function(t, e) {
          this._url = t, e = h(this, e), e.detectRetina && Et.retina && e.maxZoom > 0 && (e.tileSize = Math.floor(e.tileSize / 2), e.zoomReverse ? (e.zoomOffset--, e.minZoom++) : (e.zoomOffset++, e.maxZoom--), e.minZoom = Math.max(0, e.minZoom)), typeof e.subdomains == "string" && (e.subdomains = e.subdomains.split("")), this.on("tileunload", this._onTileRemove);
        },
        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        // If the URL does not change, the layer will not be redrawn unless
        // the noRedraw parameter is set to false.
        setUrl: function(t, e) {
          return this._url === t && e === void 0 && (e = !0), this._url = t, e || this.redraw(), this;
        },
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function(t, e) {
          var w = document.createElement("img");
          return Ee(w, "load", i(this._tileOnLoad, this, e, w)), Ee(w, "error", i(this._tileOnError, this, e, w)), (this.options.crossOrigin || this.options.crossOrigin === "") && (w.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), typeof this.options.referrerPolicy == "string" && (w.referrerPolicy = this.options.referrerPolicy), w.alt = "", w.setAttribute("role", "presentation"), w.src = this.getTileUrl(t), w;
        },
        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function(t) {
          var e = {
            r: Et.retina ? "@2x" : "",
            s: this._getSubdomain(t),
            x: t.x,
            y: t.y,
            z: this._getZoomForUrl()
          };
          if (this._map && !this._map.options.crs.infinite) {
            var w = this._globalTileRange.max.y - t.y;
            this.options.tms && (e.y = w), e["-y"] = w;
          }
          return S(this._url, v(e, this.options));
        },
        _tileOnLoad: function(t, e) {
          Et.ielt9 ? setTimeout(i(t, this, null, e), 0) : t(null, e);
        },
        _tileOnError: function(t, e, w) {
          var I = this.options.errorTileUrl;
          I && e.getAttribute("src") !== I && (e.src = I), t(w, e);
        },
        _onTileRemove: function(t) {
          t.tile.onload = null;
        },
        _getZoomForUrl: function() {
          var t = this._tileZoom, e = this.options.maxZoom, w = this.options.zoomReverse, I = this.options.zoomOffset;
          return w && (t = e - t), t + I;
        },
        _getSubdomain: function(t) {
          var e = Math.abs(t.x + t.y) % this.options.subdomains.length;
          return this.options.subdomains[e];
        },
        // stops loading all tiles in the background layer
        _abortLoading: function() {
          var t, e;
          for (t in this._tiles)
            if (this._tiles[t].coords.z !== this._tileZoom && (e = this._tiles[t].el, e.onload = a, e.onerror = a, !e.complete)) {
              e.src = k;
              var w = this._tiles[t].coords;
              Re(e), delete this._tiles[t], this.fire("tileabort", {
                tile: e,
                coords: w
              });
            }
        },
        _removeTile: function(t) {
          var e = this._tiles[t];
          if (e)
            return e.el.setAttribute("src", k), rr.prototype._removeTile.call(this, t);
        },
        _tileReady: function(t, e, w) {
          if (!(!this._map || w && w.getAttribute("src") === k))
            return rr.prototype._tileReady.call(this, t, e, w);
        }
      });
      function Zr(t, e) {
        return new Qn(t, e);
      }
      var Gr = Qn.extend({
        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          // @option layers: String = ''
          // **(required)** Comma-separated list of WMS layers to show.
          layers: "",
          // @option styles: String = ''
          // Comma-separated list of WMS styles.
          styles: "",
          // @option format: String = 'image/jpeg'
          // WMS image format (use `'image/png'` for layers with transparency).
          format: "image/jpeg",
          // @option transparent: Boolean = false
          // If `true`, the WMS service will return images with transparency.
          transparent: !1,
          // @option version: String = '1.1.1'
          // Version of the WMS service to use
          version: "1.1.1"
        },
        options: {
          // @option crs: CRS = null
          // Coordinate Reference System to use for the WMS requests, defaults to
          // map CRS. Don't change this if you're not sure what it means.
          crs: null,
          // @option uppercase: Boolean = false
          // If `true`, WMS request parameter keys will be uppercase.
          uppercase: !1
        },
        initialize: function(t, e) {
          this._url = t;
          var w = v({}, this.defaultWmsParams);
          for (var I in e)
            I in this.options || (w[I] = e[I]);
          e = h(this, e);
          var Y = e.detectRetina && Et.retina ? 2 : 1, dt = this.getTileSize();
          w.width = dt.x * Y, w.height = dt.y * Y, this.wmsParams = w;
        },
        onAdd: function(t) {
          this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
          var e = this._wmsVersion >= 1.3 ? "crs" : "srs";
          this.wmsParams[e] = this._crs.code, Qn.prototype.onAdd.call(this, t);
        },
        getTileUrl: function(t) {
          var e = this._tileCoordsToNwSe(t), w = this._crs, I = ot(w.project(e[0]), w.project(e[1])), Y = I.min, dt = I.max, Nt = (this._wmsVersion >= 1.3 && this._crs === Nr ? [Y.y, Y.x, dt.y, dt.x] : [Y.x, Y.y, dt.x, dt.y]).join(","), Kt = Qn.prototype.getTileUrl.call(this, t);
          return Kt + _(this.wmsParams, Kt, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + Nt;
        },
        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function(t, e) {
          return v(this.wmsParams, t), e || this.redraw(), this;
        }
      });
      function ji(t, e) {
        return new Gr(t, e);
      }
      Qn.WMS = Gr, Zr.wms = ji;
      var zn = In.extend({
        // @section
        // @aka Renderer options
        options: {
          // @option padding: Number = 0.1
          // How much to extend the clip area around the map view (relative to its size)
          // e.g. 0.1 would be 10% of map view in each direction
          padding: 0.1
        },
        initialize: function(t) {
          h(this, t), r(this), this._layers = this._layers || {};
        },
        onAdd: function() {
          this._container || (this._initContainer(), this._zoomAnimated && gt(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this);
        },
        onRemove: function() {
          this.off("update", this._updatePaths, this), this._destroyContainer();
        },
        getEvents: function() {
          var t = {
            viewreset: this._reset,
            zoom: this._onZoom,
            moveend: this._update,
            zoomend: this._onZoomEnd
          };
          return this._zoomAnimated && (t.zoomanim = this._onAnimZoom), t;
        },
        _onAnimZoom: function(t) {
          this._updateTransform(t.center, t.zoom);
        },
        _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function(t, e) {
          var w = this._map.getZoomScale(e, this._zoom), I = this._map.getSize().multiplyBy(0.5 + this.options.padding), Y = this._map.project(this._center, e), dt = I.multiplyBy(-w).add(Y).subtract(this._map._getNewPixelOrigin(t, e));
          Et.any3d ? Ke(this._container, dt, w) : Ae(this._container, dt);
        },
        _reset: function() {
          this._update(), this._updateTransform(this._center, this._zoom);
          for (var t in this._layers)
            this._layers[t]._reset();
        },
        _onZoomEnd: function() {
          for (var t in this._layers)
            this._layers[t]._project();
        },
        _updatePaths: function() {
          for (var t in this._layers)
            this._layers[t]._update();
        },
        _update: function() {
          var t = this.options.padding, e = this._map.getSize(), w = this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round();
          this._bounds = new V(w, w.add(e.multiplyBy(1 + t * 2)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();
        }
      }), Hr = zn.extend({
        // @section
        // @aka Canvas options
        options: {
          // @option tolerance: Number = 0
          // How much to extend the click tolerance around a path/object on the map.
          tolerance: 0
        },
        getEvents: function() {
          var t = zn.prototype.getEvents.call(this);
          return t.viewprereset = this._onViewPreReset, t;
        },
        _onViewPreReset: function() {
          this._postponeUpdatePaths = !0;
        },
        onAdd: function() {
          zn.prototype.onAdd.call(this), this._draw();
        },
        _initContainer: function() {
          var t = this._container = document.createElement("canvas");
          Ee(t, "mousemove", this._onMouseMove, this), Ee(t, "click dblclick mousedown mouseup contextmenu", this._onClick, this), Ee(t, "mouseout", this._handleMouseOut, this), t._leaflet_disable_events = !0, this._ctx = t.getContext("2d");
        },
        _destroyContainer: function() {
          X(this._redrawRequest), delete this._ctx, Re(this._container), Ne(this._container), delete this._container;
        },
        _updatePaths: function() {
          if (!this._postponeUpdatePaths) {
            var t;
            this._redrawBounds = null;
            for (var e in this._layers)
              t = this._layers[e], t._update();
            this._redraw();
          }
        },
        _update: function() {
          if (!(this._map._animatingZoom && this._bounds)) {
            zn.prototype._update.call(this);
            var t = this._bounds, e = this._container, w = t.getSize(), I = Et.retina ? 2 : 1;
            Ae(e, t.min), e.width = I * w.x, e.height = I * w.y, e.style.width = w.x + "px", e.style.height = w.y + "px", Et.retina && this._ctx.scale(2, 2), this._ctx.translate(-t.min.x, -t.min.y), this.fire("update");
          }
        },
        _reset: function() {
          zn.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths());
        },
        _initPath: function(t) {
          this._updateDashArray(t), this._layers[r(t)] = t;
          var e = t._order = {
            layer: t,
            prev: this._drawLast,
            next: null
          };
          this._drawLast && (this._drawLast.next = e), this._drawLast = e, this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function(t) {
          this._requestRedraw(t);
        },
        _removePath: function(t) {
          var e = t._order, w = e.next, I = e.prev;
          w ? w.prev = I : this._drawLast = I, I ? I.next = w : this._drawFirst = w, delete t._order, delete this._layers[r(t)], this._requestRedraw(t);
        },
        _updatePath: function(t) {
          this._extendRedrawBounds(t), t._project(), t._update(), this._requestRedraw(t);
        },
        _updateStyle: function(t) {
          this._updateDashArray(t), this._requestRedraw(t);
        },
        _updateDashArray: function(t) {
          if (typeof t.options.dashArray == "string") {
            var e = t.options.dashArray.split(/[, ]+/), w = [], I, Y;
            for (Y = 0; Y < e.length; Y++) {
              if (I = Number(e[Y]), isNaN(I))
                return;
              w.push(I);
            }
            t.options._dashArray = w;
          } else
            t.options._dashArray = t.options.dashArray;
        },
        _requestRedraw: function(t) {
          this._map && (this._extendRedrawBounds(t), this._redrawRequest = this._redrawRequest || B(this._redraw, this));
        },
        _extendRedrawBounds: function(t) {
          if (t._pxBounds) {
            var e = (t.options.weight || 0) + 1;
            this._redrawBounds = this._redrawBounds || new V(), this._redrawBounds.extend(t._pxBounds.min.subtract([e, e])), this._redrawBounds.extend(t._pxBounds.max.add([e, e]));
          }
        },
        _redraw: function() {
          this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null;
        },
        _clear: function() {
          var t = this._redrawBounds;
          if (t) {
            var e = t.getSize();
            this._ctx.clearRect(t.min.x, t.min.y, e.x, e.y);
          } else
            this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore();
        },
        _draw: function() {
          var t, e = this._redrawBounds;
          if (this._ctx.save(), e) {
            var w = e.getSize();
            this._ctx.beginPath(), this._ctx.rect(e.min.x, e.min.y, w.x, w.y), this._ctx.clip();
          }
          this._drawing = !0;
          for (var I = this._drawFirst; I; I = I.next)
            t = I.layer, (!e || t._pxBounds && t._pxBounds.intersects(e)) && t._updatePath();
          this._drawing = !1, this._ctx.restore();
        },
        _updatePoly: function(t, e) {
          if (this._drawing) {
            var w, I, Y, dt, Nt = t._parts, Kt = Nt.length, ee = this._ctx;
            if (Kt) {
              for (ee.beginPath(), w = 0; w < Kt; w++) {
                for (I = 0, Y = Nt[w].length; I < Y; I++)
                  dt = Nt[w][I], ee[I ? "lineTo" : "moveTo"](dt.x, dt.y);
                e && ee.closePath();
              }
              this._fillStroke(ee, t);
            }
          }
        },
        _updateCircle: function(t) {
          if (!(!this._drawing || t._empty())) {
            var e = t._point, w = this._ctx, I = Math.max(Math.round(t._radius), 1), Y = (Math.max(Math.round(t._radiusY), 1) || I) / I;
            Y !== 1 && (w.save(), w.scale(1, Y)), w.beginPath(), w.arc(e.x, e.y / Y, I, 0, Math.PI * 2, !1), Y !== 1 && w.restore(), this._fillStroke(w, t);
          }
        },
        _fillStroke: function(t, e) {
          var w = e.options;
          w.fill && (t.globalAlpha = w.fillOpacity, t.fillStyle = w.fillColor || w.color, t.fill(w.fillRule || "evenodd")), w.stroke && w.weight !== 0 && (t.setLineDash && t.setLineDash(e.options && e.options._dashArray || []), t.globalAlpha = w.opacity, t.lineWidth = w.weight, t.strokeStyle = w.color, t.lineCap = w.lineCap, t.lineJoin = w.lineJoin, t.stroke());
        },
        // Canvas obviously doesn't have mouse events for individual drawn objects,
        // so we emulate that by calculating what's under the mouse on mousemove/click manually
        _onClick: function(t) {
          for (var e = this._map.mouseEventToLayerPoint(t), w, I, Y = this._drawFirst; Y; Y = Y.next)
            w = Y.layer, w.options.interactive && w._containsPoint(e) && (!(t.type === "click" || t.type === "preclick") || !this._map._draggableMoved(w)) && (I = w);
          this._fireEvent(I ? [I] : !1, t);
        },
        _onMouseMove: function(t) {
          if (!(!this._map || this._map.dragging.moving() || this._map._animatingZoom)) {
            var e = this._map.mouseEventToLayerPoint(t);
            this._handleMouseHover(t, e);
          }
        },
        _handleMouseOut: function(t) {
          var e = this._hoveredLayer;
          e && (zt(this._container, "leaflet-interactive"), this._fireEvent([e], t, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = !1);
        },
        _handleMouseHover: function(t, e) {
          if (!this._mouseHoverThrottled) {
            for (var w, I, Y = this._drawFirst; Y; Y = Y.next)
              w = Y.layer, w.options.interactive && w._containsPoint(e) && (I = w);
            I !== this._hoveredLayer && (this._handleMouseOut(t), I && (gt(this._container, "leaflet-interactive"), this._fireEvent([I], t, "mouseover"), this._hoveredLayer = I)), this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : !1, t), this._mouseHoverThrottled = !0, setTimeout(i(function() {
              this._mouseHoverThrottled = !1;
            }, this), 32);
          }
        },
        _fireEvent: function(t, e, w) {
          this._map._fireDOMEvent(e, w || e.type, t);
        },
        _bringToFront: function(t) {
          var e = t._order;
          if (e) {
            var w = e.next, I = e.prev;
            if (w)
              w.prev = I;
            else
              return;
            I ? I.next = w : w && (this._drawFirst = w), e.prev = this._drawLast, this._drawLast.next = e, e.next = null, this._drawLast = e, this._requestRedraw(t);
          }
        },
        _bringToBack: function(t) {
          var e = t._order;
          if (e) {
            var w = e.next, I = e.prev;
            if (I)
              I.next = w;
            else
              return;
            w ? w.prev = I : I && (this._drawLast = I), e.prev = null, e.next = this._drawFirst, this._drawFirst.prev = e, this._drawFirst = e, this._requestRedraw(t);
          }
        }
      });
      function Wr(t) {
        return Et.canvas ? new Hr(t) : null;
      }
      var ir = function() {
        try {
          return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(t) {
            return document.createElement("<lvml:" + t + ' class="lvml">');
          };
        } catch (t) {
        }
        return function(t) {
          return document.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }(), Ci = {
        _initContainer: function() {
          this._container = Te("div", "leaflet-vml-container");
        },
        _update: function() {
          this._map._animatingZoom || (zn.prototype._update.call(this), this.fire("update"));
        },
        _initPath: function(t) {
          var e = t._container = ir("shape");
          gt(e, "leaflet-vml-shape " + (this.options.className || "")), e.coordsize = "1 1", t._path = ir("path"), e.appendChild(t._path), this._updateStyle(t), this._layers[r(t)] = t;
        },
        _addPath: function(t) {
          var e = t._container;
          this._container.appendChild(e), t.options.interactive && t.addInteractiveTarget(e);
        },
        _removePath: function(t) {
          var e = t._container;
          Re(e), t.removeInteractiveTarget(e), delete this._layers[r(t)];
        },
        _updateStyle: function(t) {
          var e = t._stroke, w = t._fill, I = t.options, Y = t._container;
          Y.stroked = !!I.stroke, Y.filled = !!I.fill, I.stroke ? (e || (e = t._stroke = ir("stroke")), Y.appendChild(e), e.weight = I.weight + "px", e.color = I.color, e.opacity = I.opacity, I.dashArray ? e.dashStyle = d(I.dashArray) ? I.dashArray.join(" ") : I.dashArray.replace(/( *, *)/g, " ") : e.dashStyle = "", e.endcap = I.lineCap.replace("butt", "flat"), e.joinstyle = I.lineJoin) : e && (Y.removeChild(e), t._stroke = null), I.fill ? (w || (w = t._fill = ir("fill")), Y.appendChild(w), w.color = I.fillColor || I.color, w.opacity = I.fillOpacity) : w && (Y.removeChild(w), t._fill = null);
        },
        _updateCircle: function(t) {
          var e = t._point.round(), w = Math.round(t._radius), I = Math.round(t._radiusY || w);
          this._setPath(t, t._empty() ? "M0 0" : "AL " + e.x + "," + e.y + " " + w + "," + I + " 0," + 65535 * 360);
        },
        _setPath: function(t, e) {
          t._path.v = e;
        },
        _bringToFront: function(t) {
          cn(t._container);
        },
        _bringToBack: function(t) {
          J(t._container);
        }
      }, mr = Et.vml ? ir : Ft, or = zn.extend({
        _initContainer: function() {
          this._container = mr("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = mr("g"), this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function() {
          Re(this._container), Ne(this._container), delete this._container, delete this._rootGroup, delete this._svgSize;
        },
        _update: function() {
          if (!(this._map._animatingZoom && this._bounds)) {
            zn.prototype._update.call(this);
            var t = this._bounds, e = t.getSize(), w = this._container;
            (!this._svgSize || !this._svgSize.equals(e)) && (this._svgSize = e, w.setAttribute("width", e.x), w.setAttribute("height", e.y)), Ae(w, t.min), w.setAttribute("viewBox", [t.min.x, t.min.y, e.x, e.y].join(" ")), this.fire("update");
          }
        },
        // methods below are called by vector layers implementations
        _initPath: function(t) {
          var e = t._path = mr("path");
          t.options.className && gt(e, t.options.className), t.options.interactive && gt(e, "leaflet-interactive"), this._updateStyle(t), this._layers[r(t)] = t;
        },
        _addPath: function(t) {
          this._rootGroup || this._initContainer(), this._rootGroup.appendChild(t._path), t.addInteractiveTarget(t._path);
        },
        _removePath: function(t) {
          Re(t._path), t.removeInteractiveTarget(t._path), delete this._layers[r(t)];
        },
        _updatePath: function(t) {
          t._project(), t._update();
        },
        _updateStyle: function(t) {
          var e = t._path, w = t.options;
          e && (w.stroke ? (e.setAttribute("stroke", w.color), e.setAttribute("stroke-opacity", w.opacity), e.setAttribute("stroke-width", w.weight), e.setAttribute("stroke-linecap", w.lineCap), e.setAttribute("stroke-linejoin", w.lineJoin), w.dashArray ? e.setAttribute("stroke-dasharray", w.dashArray) : e.removeAttribute("stroke-dasharray"), w.dashOffset ? e.setAttribute("stroke-dashoffset", w.dashOffset) : e.removeAttribute("stroke-dashoffset")) : e.setAttribute("stroke", "none"), w.fill ? (e.setAttribute("fill", w.fillColor || w.color), e.setAttribute("fill-opacity", w.fillOpacity), e.setAttribute("fill-rule", w.fillRule || "evenodd")) : e.setAttribute("fill", "none"));
        },
        _updatePoly: function(t, e) {
          this._setPath(t, H(t._parts, e));
        },
        _updateCircle: function(t) {
          var e = t._point, w = Math.max(Math.round(t._radius), 1), I = Math.max(Math.round(t._radiusY), 1) || w, Y = "a" + w + "," + I + " 0 1,0 ", dt = t._empty() ? "M0 0" : "M" + (e.x - w) + "," + e.y + Y + w * 2 + ",0 " + Y + -w * 2 + ",0 ";
          this._setPath(t, dt);
        },
        _setPath: function(t, e) {
          t._path.setAttribute("d", e);
        },
        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
        _bringToFront: function(t) {
          cn(t._path);
        },
        _bringToBack: function(t) {
          J(t._path);
        }
      });
      Et.vml && or.include(Ci);
      function Vr(t) {
        return Et.svg || Et.vml ? new or(t) : null;
      }
      xe.include({
        // @namespace Map; @method getRenderer(layer: Path): Renderer
        // Returns the instance of `Renderer` that should be used to render the given
        // `Path`. It will ensure that the `renderer` options of the map and paths
        // are respected, and that the renderers do exist on the map.
        getRenderer: function(t) {
          var e = t.options.renderer || this._getPaneRenderer(t.options.pane) || this.options.renderer || this._renderer;
          return e || (e = this._renderer = this._createRenderer()), this.hasLayer(e) || this.addLayer(e), e;
        },
        _getPaneRenderer: function(t) {
          if (t === "overlayPane" || t === void 0)
            return !1;
          var e = this._paneRenderers[t];
          return e === void 0 && (e = this._createRenderer({ pane: t }), this._paneRenderers[t] = e), e;
        },
        _createRenderer: function(t) {
          return this.options.preferCanvas && Wr(t) || Vr(t);
        }
      });
      var qr = Jn.extend({
        initialize: function(t, e) {
          Jn.prototype.initialize.call(this, this._boundsToLatLngs(t), e);
        },
        // @method setBounds(latLngBounds: LatLngBounds): this
        // Redraws the rectangle with the passed bounds.
        setBounds: function(t) {
          return this.setLatLngs(this._boundsToLatLngs(t));
        },
        _boundsToLatLngs: function(t) {
          return t = Ut(t), [
            t.getSouthWest(),
            t.getNorthWest(),
            t.getNorthEast(),
            t.getSouthEast()
          ];
        }
      });
      function Ri(t, e) {
        return new qr(t, e);
      }
      or.create = mr, or.pointsToPath = H, Bn.geometryToLayer = xr, Bn.coordsToLatLng = Sr, Bn.coordsToLatLngs = ur, Bn.latLngToCoords = kr, Bn.latLngsToCoords = cr, Bn.getFeature = Xn, Bn.asFeature = fr, xe.mergeOptions({
        // @option boxZoom: Boolean = true
        // Whether the map can be zoomed to a rectangular area specified by
        // dragging the mouse while pressing the shift key.
        boxZoom: !0
      });
      var Kr = xn.extend({
        initialize: function(t) {
          this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._resetStateTimeout = 0, t.on("unload", this._destroy, this);
        },
        addHooks: function() {
          Ee(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
          Ne(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function() {
          return this._moved;
        },
        _destroy: function() {
          Re(this._pane), delete this._pane;
        },
        _resetState: function() {
          this._resetStateTimeout = 0, this._moved = !1;
        },
        _clearDeferredResetState: function() {
          this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
        },
        _onMouseDown: function(t) {
          if (!t.shiftKey || t.which !== 1 && t.button !== 1)
            return !1;
          this._clearDeferredResetState(), this._resetState(), gn(), Mn(), this._startPoint = this._map.mouseEventToContainerPoint(t), Ee(document, {
            contextmenu: Tt,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseMove: function(t) {
          this._moved || (this._moved = !0, this._box = Te("div", "leaflet-zoom-box", this._container), gt(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(t);
          var e = new V(this._point, this._startPoint), w = e.getSize();
          Ae(this._box, e.min), this._box.style.width = w.x + "px", this._box.style.height = w.y + "px";
        },
        _finish: function() {
          this._moved && (Re(this._box), zt(this._container, "leaflet-crosshair")), pe(), Pn(), Ne(document, {
            contextmenu: Tt,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseUp: function(t) {
          if (!(t.which !== 1 && t.button !== 1) && (this._finish(), !!this._moved)) {
            this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(i(this._resetState, this), 0);
            var e = new xt(
              this._map.containerPointToLatLng(this._startPoint),
              this._map.containerPointToLatLng(this._point)
            );
            this._map.fitBounds(e).fire("boxzoomend", { boxZoomBounds: e });
          }
        },
        _onKeyDown: function(t) {
          t.keyCode === 27 && (this._finish(), this._clearDeferredResetState(), this._resetState());
        }
      });
      xe.addInitHook("addHandler", "boxZoom", Kr), xe.mergeOptions({
        // @option doubleClickZoom: Boolean|String = true
        // Whether the map can be zoomed in by double clicking on it and
        // zoomed out by double clicking while holding shift. If passed
        // `'center'`, double-click zoom will zoom to the center of the
        //  view regardless of where the mouse was.
        doubleClickZoom: !0
      });
      var Yr = xn.extend({
        addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(t) {
          var e = this._map, w = e.getZoom(), I = e.options.zoomDelta, Y = t.originalEvent.shiftKey ? w - I : w + I;
          e.options.doubleClickZoom === "center" ? e.setZoom(Y) : e.setZoomAround(t.containerPoint, Y);
        }
      });
      xe.addInitHook("addHandler", "doubleClickZoom", Yr), xe.mergeOptions({
        // @option dragging: Boolean = true
        // Whether the map is draggable with mouse/touch or not.
        dragging: !0,
        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default.
        inertia: !0,
        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second².
        inertiaDeceleration: 3400,
        // px/s^2
        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: 1 / 0,
        // px/s
        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,
        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: !1,
        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0
      });
      var Jr = xn.extend({
        addHooks: function() {
          if (!this._draggable) {
            var t = this._map;
            this._draggable = new Rn(t._mapPane, t._container), this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this), this._draggable.on("predrag", this._onPreDragLimit, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), t.on("zoomend", this._onZoomEnd, this), t.whenReady(this._onZoomEnd, this));
          }
          gt(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [];
        },
        removeHooks: function() {
          zt(this._map._container, "leaflet-grab"), zt(this._map._container, "leaflet-touch-drag"), this._draggable.disable();
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        moving: function() {
          return this._draggable && this._draggable._moving;
        },
        _onDragStart: function() {
          var t = this._map;
          if (t._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
            var e = Ut(this._map.options.maxBounds);
            this._offsetLimit = ot(
              this._map.latLngToContainerPoint(e.getNorthWest()).multiplyBy(-1),
              this._map.latLngToContainerPoint(e.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
            ), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
          } else
            this._offsetLimit = null;
          t.fire("movestart").fire("dragstart"), t.options.inertia && (this._positions = [], this._times = []);
        },
        _onDrag: function(t) {
          if (this._map.options.inertia) {
            var e = this._lastTime = +/* @__PURE__ */ new Date(), w = this._lastPos = this._draggable._absPos || this._draggable._newPos;
            this._positions.push(w), this._times.push(e), this._prunePositions(e);
          }
          this._map.fire("move", t).fire("drag", t);
        },
        _prunePositions: function(t) {
          for (; this._positions.length > 1 && t - this._times[0] > 50; )
            this._positions.shift(), this._times.shift();
        },
        _onZoomEnd: function() {
          var t = this._map.getSize().divideBy(2), e = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function(t, e) {
          return t - (t - e) * this._viscosity;
        },
        _onPreDragLimit: function() {
          if (!(!this._viscosity || !this._offsetLimit)) {
            var t = this._draggable._newPos.subtract(this._draggable._startPos), e = this._offsetLimit;
            t.x < e.min.x && (t.x = this._viscousLimit(t.x, e.min.x)), t.y < e.min.y && (t.y = this._viscousLimit(t.y, e.min.y)), t.x > e.max.x && (t.x = this._viscousLimit(t.x, e.max.x)), t.y > e.max.y && (t.y = this._viscousLimit(t.y, e.max.y)), this._draggable._newPos = this._draggable._startPos.add(t);
          }
        },
        _onPreDragWrap: function() {
          var t = this._worldWidth, e = Math.round(t / 2), w = this._initialWorldOffset, I = this._draggable._newPos.x, Y = (I - e + w) % t + e - w, dt = (I + e + w) % t - e - w, Nt = Math.abs(Y + w) < Math.abs(dt + w) ? Y : dt;
          this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = Nt;
        },
        _onDragEnd: function(t) {
          var e = this._map, w = e.options, I = !w.inertia || t.noInertia || this._times.length < 2;
          if (e.fire("dragend", t), I)
            e.fire("moveend");
          else {
            this._prunePositions(+/* @__PURE__ */ new Date());
            var Y = this._lastPos.subtract(this._positions[0]), dt = (this._lastTime - this._times[0]) / 1e3, Nt = w.easeLinearity, Kt = Y.multiplyBy(Nt / dt), ee = Kt.distanceTo([0, 0]), ue = Math.min(w.inertiaMaxSpeed, ee), Pe = Kt.multiplyBy(ue / ee), Xe = ue / (w.inertiaDeceleration * Nt), tn = Pe.multiplyBy(-Xe / 2).round();
            !tn.x && !tn.y ? e.fire("moveend") : (tn = e._limitOffset(tn, e.options.maxBounds), B(function() {
              e.panBy(tn, {
                duration: Xe,
                easeLinearity: Nt,
                noMoveStart: !0,
                animate: !0
              });
            }));
          }
        }
      });
      xe.addInitHook("addHandler", "dragging", Jr), xe.mergeOptions({
        // @option keyboard: Boolean = true
        // Makes the map focusable and allows users to navigate the map with keyboard
        // arrows and `+`/`-` keys.
        keyboard: !0,
        // @option keyboardPanDelta: Number = 80
        // Amount of pixels to pan when pressing an arrow key.
        keyboardPanDelta: 80
      });
      var Xr = xn.extend({
        keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
        },
        initialize: function(t) {
          this._map = t, this._setPanDelta(t.options.keyboardPanDelta), this._setZoomDelta(t.options.zoomDelta);
        },
        addHooks: function() {
          var t = this._map._container;
          t.tabIndex <= 0 && (t.tabIndex = "0"), Ee(t, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this), this._map.on({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        removeHooks: function() {
          this._removeHooks(), Ne(this._map._container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this), this._map.off({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        _onMouseDown: function() {
          if (!this._focused) {
            var t = document.body, e = document.documentElement, w = t.scrollTop || e.scrollTop, I = t.scrollLeft || e.scrollLeft;
            this._map._container.focus(), window.scrollTo(I, w);
          }
        },
        _onFocus: function() {
          this._focused = !0, this._map.fire("focus");
        },
        _onBlur: function() {
          this._focused = !1, this._map.fire("blur");
        },
        _setPanDelta: function(t) {
          var e = this._panKeys = {}, w = this.keyCodes, I, Y;
          for (I = 0, Y = w.left.length; I < Y; I++)
            e[w.left[I]] = [-1 * t, 0];
          for (I = 0, Y = w.right.length; I < Y; I++)
            e[w.right[I]] = [t, 0];
          for (I = 0, Y = w.down.length; I < Y; I++)
            e[w.down[I]] = [0, t];
          for (I = 0, Y = w.up.length; I < Y; I++)
            e[w.up[I]] = [0, -1 * t];
        },
        _setZoomDelta: function(t) {
          var e = this._zoomKeys = {}, w = this.keyCodes, I, Y;
          for (I = 0, Y = w.zoomIn.length; I < Y; I++)
            e[w.zoomIn[I]] = t;
          for (I = 0, Y = w.zoomOut.length; I < Y; I++)
            e[w.zoomOut[I]] = -t;
        },
        _addHooks: function() {
          Ee(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
          Ne(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(t) {
          if (!(t.altKey || t.ctrlKey || t.metaKey)) {
            var e = t.keyCode, w = this._map, I;
            if (e in this._panKeys)
              (!w._panAnim || !w._panAnim._inProgress) && (I = this._panKeys[e], t.shiftKey && (I = ut(I).multiplyBy(3)), w.panBy(I), w.options.maxBounds && w.panInsideBounds(w.options.maxBounds));
            else if (e in this._zoomKeys)
              w.setZoom(w.getZoom() + (t.shiftKey ? 3 : 1) * this._zoomKeys[e]);
            else if (e === 27 && w._popup && w._popup.options.closeOnEscapeKey)
              w.closePopup();
            else
              return;
            Tt(t);
          }
        }
      });
      xe.addInitHook("addHandler", "keyboard", Xr), xe.mergeOptions({
        // @section Mouse wheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: !0,
        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,
        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
      });
      var Qr = xn.extend({
        addHooks: function() {
          Ee(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0;
        },
        removeHooks: function() {
          Ne(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function(t) {
          var e = fe(t), w = this._map.options.wheelDebounceTime;
          this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +/* @__PURE__ */ new Date());
          var I = Math.max(w - (+/* @__PURE__ */ new Date() - this._startTime), 0);
          clearTimeout(this._timer), this._timer = setTimeout(i(this._performZoom, this), I), Tt(t);
        },
        _performZoom: function() {
          var t = this._map, e = t.getZoom(), w = this._map.options.zoomSnap || 0;
          t._stop();
          var I = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), Y = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(I)))) / Math.LN2, dt = w ? Math.ceil(Y / w) * w : Y, Nt = t._limitZoom(e + (this._delta > 0 ? dt : -dt)) - e;
          this._delta = 0, this._startTime = null, Nt && (t.options.scrollWheelZoom === "center" ? t.setZoom(e + Nt) : t.setZoomAround(this._lastMousePos, e + Nt));
        }
      });
      xe.addInitHook("addHandler", "scrollWheelZoom", Qr);
      var Ii = 600;
      xe.mergeOptions({
        // @section Touch interaction options
        // @option tapHold: Boolean
        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
        tapHold: Et.touchNative && Et.safari && Et.mobile,
        // @option tapTolerance: Number = 15
        // The max number of pixels a user can shift his finger during touch
        // for it to be considered a valid tap.
        tapTolerance: 15
      });
      var ti = xn.extend({
        addHooks: function() {
          Ee(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
          Ne(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(t) {
          if (clearTimeout(this._holdTimeout), t.touches.length === 1) {
            var e = t.touches[0];
            this._startPos = this._newPos = new nt(e.clientX, e.clientY), this._holdTimeout = setTimeout(i(function() {
              this._cancel(), this._isTapValid() && (Ee(document, "touchend", an), Ee(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", e));
            }, this), Ii), Ee(document, "touchend touchcancel contextmenu", this._cancel, this), Ee(document, "touchmove", this._onMove, this);
          }
        },
        _cancelClickPrevent: function t() {
          Ne(document, "touchend", an), Ne(document, "touchend touchcancel", t);
        },
        _cancel: function() {
          clearTimeout(this._holdTimeout), Ne(document, "touchend touchcancel contextmenu", this._cancel, this), Ne(document, "touchmove", this._onMove, this);
        },
        _onMove: function(t) {
          var e = t.touches[0];
          this._newPos = new nt(e.clientX, e.clientY);
        },
        _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function(t, e) {
          var w = new MouseEvent(t, {
            bubbles: !0,
            cancelable: !0,
            view: window,
            // detail: 1,
            screenX: e.screenX,
            screenY: e.screenY,
            clientX: e.clientX,
            clientY: e.clientY
            // button: 2,
            // buttons: 2
          });
          w._simulated = !0, e.target.dispatchEvent(w);
        }
      });
      xe.addInitHook("addHandler", "tapHold", ti), xe.mergeOptions({
        // @section Touch interaction options
        // @option touchZoom: Boolean|String = *
        // Whether the map can be zoomed by touch-dragging with two fingers. If
        // passed `'center'`, it will zoom to the center of the view regardless of
        // where the touch events (fingers) were. Enabled for touch-capable web
        // browsers.
        touchZoom: Et.touch,
        // @option bounceAtZoomLimits: Boolean = true
        // Set it to false if you don't want the map to zoom beyond min/max zoom
        // and then bounce back when pinch-zooming.
        bounceAtZoomLimits: !0
      });
      var ei = xn.extend({
        addHooks: function() {
          gt(this._map._container, "leaflet-touch-zoom"), Ee(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
          zt(this._map._container, "leaflet-touch-zoom"), Ne(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(t) {
          var e = this._map;
          if (!(!t.touches || t.touches.length !== 2 || e._animatingZoom || this._zooming)) {
            var w = e.mouseEventToContainerPoint(t.touches[0]), I = e.mouseEventToContainerPoint(t.touches[1]);
            this._centerPoint = e.getSize()._divideBy(2), this._startLatLng = e.containerPointToLatLng(this._centerPoint), e.options.touchZoom !== "center" && (this._pinchStartLatLng = e.containerPointToLatLng(w.add(I)._divideBy(2))), this._startDist = w.distanceTo(I), this._startZoom = e.getZoom(), this._moved = !1, this._zooming = !0, e._stop(), Ee(document, "touchmove", this._onTouchMove, this), Ee(document, "touchend touchcancel", this._onTouchEnd, this), an(t);
          }
        },
        _onTouchMove: function(t) {
          if (!(!t.touches || t.touches.length !== 2 || !this._zooming)) {
            var e = this._map, w = e.mouseEventToContainerPoint(t.touches[0]), I = e.mouseEventToContainerPoint(t.touches[1]), Y = w.distanceTo(I) / this._startDist;
            if (this._zoom = e.getScaleZoom(Y, this._startZoom), !e.options.bounceAtZoomLimits && (this._zoom < e.getMinZoom() && Y < 1 || this._zoom > e.getMaxZoom() && Y > 1) && (this._zoom = e._limitZoom(this._zoom)), e.options.touchZoom === "center") {
              if (this._center = this._startLatLng, Y === 1)
                return;
            } else {
              var dt = w._add(I)._divideBy(2)._subtract(this._centerPoint);
              if (Y === 1 && dt.x === 0 && dt.y === 0)
                return;
              this._center = e.unproject(e.project(this._pinchStartLatLng, this._zoom).subtract(dt), this._zoom);
            }
            this._moved || (e._moveStart(!0, !1), this._moved = !0), X(this._animRequest);
            var Nt = i(e._move, e, this._center, this._zoom, { pinch: !0, round: !1 });
            this._animRequest = B(Nt, this, !0), an(t);
          }
        },
        _onTouchEnd: function() {
          if (!this._moved || !this._zooming) {
            this._zooming = !1;
            return;
          }
          this._zooming = !1, X(this._animRequest), Ne(document, "touchmove", this._onTouchMove, this), Ne(document, "touchend touchcancel", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom));
        }
      });
      xe.addInitHook("addHandler", "touchZoom", ei), xe.BoxZoom = Kr, xe.DoubleClickZoom = Yr, xe.Drag = Jr, xe.Keyboard = Xr, xe.ScrollWheelZoom = Qr, xe.TapHold = ti, xe.TouchZoom = ei, c.Bounds = V, c.Browser = Et, c.CRS = bt, c.Canvas = Hr, c.Circle = Er, c.CircleMarker = lr, c.Class = D, c.Control = wt, c.DivIcon = Fr, c.DivOverlay = Nn, c.DomEvent = me, c.DomUtil = Fe, c.Draggable = Rn, c.Evented = tt, c.FeatureGroup = Kn, c.GeoJSON = Bn, c.GridLayer = rr, c.Handler = xn, c.Icon = Yn, c.ImageOverlay = hr, c.LatLng = pt, c.LatLngBounds = xt, c.Layer = In, c.LayerGroup = qn, c.LineUtil = ci, c.Map = xe, c.Marker = sr, c.Mixin = tr, c.Path = Fn, c.Point = nt, c.PolyUtil = fi, c.Polygon = Jn, c.Polyline = $n, c.Popup = dr, c.PosAnimation = Ze, c.Projection = hi, c.Rectangle = qr, c.Renderer = zn, c.SVG = or, c.SVGOverlay = Ur, c.TileLayer = Qn, c.Tooltip = pr, c.Transformation = q, c.Util = K, c.VideoOverlay = zr, c.bind = i, c.bounds = ot, c.canvas = Wr, c.circle = bi, c.circleMarker = vi, c.control = Bt, c.divIcon = Li, c.extend = v, c.featureGroup = gi, c.geoJSON = Br, c.geoJson = xi, c.gridLayer = Pi, c.icon = _i, c.imageOverlay = Si, c.latLng = at, c.latLngBounds = Ut, c.layerGroup = mi, c.map = ze, c.marker = yi, c.point = ut, c.polygon = Ei, c.polyline = wi, c.popup = Ai, c.rectangle = Ri, c.setOptions = h, c.stamp = r, c.svg = Vr, c.svgOverlay = Ti, c.tileLayer = Zr, c.tooltip = Oi, c.transformation = G, c.version = p, c.videoOverlay = ki;
      var Mi = window.L;
      c.noConflict = function() {
        return window.L = Mi, this;
      }, window.L = c;
    });
  }(leafletSrc, leafletSrcExports$1)), leafletSrcExports$1;
}
var leafletSrcExports = requireLeafletSrc();
const L$1 = /* @__PURE__ */ getDefaultExportFromCjs(leafletSrcExports);
/* @preserve MIT LICENSE, Copyright (c) 2014-2015, Justin Manley */
(function(x, C, c) {
  x.L.Toolbar2 = (L.Layer || L.Class).extend({ statics: { baseClass: "leaflet-toolbar" }, options: { className: "", filter: function() {
    return !0;
  }, actions: [] }, initialize: function(v) {
    L.setOptions(this, v), this._toolbar_type = this.constructor._toolbar_class_id;
  }, addTo: function(v) {
    return this._arguments = [].slice.call(arguments), v.addLayer(this), this;
  }, onAdd: function(v) {
    var n = v._toolbars[this._toolbar_type];
    this._calculateDepth() === 0 && (n && v.removeLayer(n), v._toolbars[this._toolbar_type] = this);
  }, onRemove: function(v) {
    this._calculateDepth() === 0 && delete v._toolbars[this._toolbar_type];
  }, appendToContainer: function(v) {
    var n, i, s, r, o = this.constructor.baseClass + "-" + this._calculateDepth() + " " + this.options.className;
    for (this._container = v, this._ul = L.DomUtil.create("ul", o, v), this._disabledEvents = ["click", "mousemove", "dblclick", "mousedown", "mouseup", "touchstart"], i = 0, r = this._disabledEvents.length; i < r; i++)
      L.DomEvent.on(this._ul, this._disabledEvents[i], L.DomEvent.stopPropagation);
    for (n = 0, s = this.options.actions.length; n < s; n++)
      new (this._getActionConstructor(this.options.actions[n]))()._createIcon(this, this._ul, this._arguments);
  }, _getActionConstructor: function(v) {
    var n = this._arguments, i = this;
    return v.extend({ initialize: function() {
      v.prototype.initialize.apply(this, n);
    }, enable: function(s) {
      i._active && i._active.disable(), i._active = this, v.prototype.enable.call(this, s);
    } });
  }, _hide: function() {
    this._ul.style.display = "none";
  }, _show: function() {
    this._ul.style.display = "block";
  }, _calculateDepth: function() {
    for (var v = 0, n = this.parentToolbar; n; )
      v += 1, n = n.parentToolbar;
    return v;
  } }), L.Evented || L.Toolbar2.include(L.Mixin.Events), L.toolbar = {};
  var p = 0;
  L.Toolbar2.extend = function(v) {
    var n = L.extend({}, v.statics, { _toolbar_class_id: p });
    return p += 1, L.extend(v, { statics: n }), L.Class.extend.call(this, v);
  }, L.Map.addInitHook(function() {
    this._toolbars = {};
  }), L.Toolbar2.Action = L.Handler.extend({ statics: { baseClass: "leaflet-toolbar-icon" }, options: { toolbarIcon: { html: "", className: "", tooltip: "" }, subToolbar: new L.Toolbar2() }, initialize: function(v) {
    var n = L.Toolbar2.Action.prototype.options.toolbarIcon;
    L.setOptions(this, v), this.options.toolbarIcon = L.extend({}, n, this.options.toolbarIcon);
  }, enable: function(v) {
    v && L.DomEvent.preventDefault(v), this._enabled || (this._enabled = !0, this.addHooks && this.addHooks());
  }, disable: function() {
    this._enabled && (this._enabled = !1, this.removeHooks && this.removeHooks());
  }, _createIcon: function(v, n, i) {
    var s = this.options.toolbarIcon;
    this.toolbar = v, this._icon = L.DomUtil.create("li", "", n), this._link = L.DomUtil.create("a", "", this._icon), this._link.innerHTML = s.html, this._link.setAttribute("href", "#"), this._link.setAttribute("title", s.tooltip), L.DomUtil.addClass(this._link, this.constructor.baseClass), s.className && L.DomUtil.addClass(this._link, s.className), L.DomEvent.on(this._link, "click", this.enable, this), this._addSubToolbar(v, this._icon, i);
  }, _addSubToolbar: function(v, n, i) {
    var s = this.options.subToolbar, r = this.addHooks, o = this.removeHooks;
    s.parentToolbar = v, s.options.actions.length > 0 && ((i = [].slice.call(i)).push(this), s.addTo.apply(s, i), s.appendToContainer(n), this.addHooks = function(u) {
      typeof r == "function" && r.call(this, u), s._show();
    }, this.removeHooks = function(u) {
      typeof o == "function" && o.call(this, u), s._hide();
    });
  } }), L.toolbarAction = function(v) {
    return new L.Toolbar2.Action(v);
  }, L.Toolbar2.Action.extendOptions = function(v) {
    return this.extend({ options: v });
  }, L.Toolbar2.Control = L.Toolbar2.extend({ statics: { baseClass: "leaflet-control-toolbar " + L.Toolbar2.baseClass }, initialize: function(v) {
    L.Toolbar2.prototype.initialize.call(this, v), this._control = new L.Control.Toolbar(this.options);
  }, onAdd: function(v) {
    this._control.addTo(v), L.Toolbar2.prototype.onAdd.call(this, v), this.appendToContainer(this._control.getContainer());
  }, onRemove: function(v) {
    L.Toolbar2.prototype.onRemove.call(this, v), this._control.remove ? this._control.remove() : this._control.removeFrom(v);
  } }), L.Control.Toolbar = L.Control.extend({ onAdd: function() {
    return L.DomUtil.create("div", "");
  } }), L.toolbar.control = function(v) {
    return new L.Toolbar2.Control(v);
  }, L.Toolbar2.Popup = L.Toolbar2.extend({ statics: { baseClass: "leaflet-popup-toolbar " + L.Toolbar2.baseClass }, options: { anchor: [0, 0] }, initialize: function(v, n) {
    L.Toolbar2.prototype.initialize.call(this, n), this._marker = new L.Marker(v, { icon: new L.DivIcon({ className: this.options.className, iconAnchor: [0, 0] }) });
  }, onAdd: function(v) {
    this._map = v, this._marker.addTo(v), L.Toolbar2.prototype.onAdd.call(this, v), this.appendToContainer(this._marker._icon), this._setStyles();
  }, onRemove: function(v) {
    v.removeLayer(this._marker), L.Toolbar2.prototype.onRemove.call(this, v), delete this._map;
  }, setLatLng: function(v) {
    return this._marker.setLatLng(v), this;
  }, _setStyles: function() {
    for (var v, n, i, s = this._container, r = this._ul, o = L.point(this.options.anchor), u = r.querySelectorAll(".leaflet-toolbar-icon"), a = [], f = 0, y = 0, T = u.length; y < T; y++)
      u[y].parentNode.parentNode === r && (a.push(parseInt(L.DomUtil.getStyle(u[y], "height"), 10)), f += Math.ceil(parseFloat(L.DomUtil.getStyle(u[y], "width"))), f += Math.ceil(parseFloat(L.DomUtil.getStyle(u[y], "border-right-width"))));
    r.style.width = f + "px", this._tipContainer = L.DomUtil.create("div", "leaflet-toolbar-tip-container", s), this._tipContainer.style.width = f + Math.ceil(parseFloat(L.DomUtil.getStyle(r, "border-left-width"))) + "px", this._tip = L.DomUtil.create("div", "leaflet-toolbar-tip", this._tipContainer), v = Math.max.apply(void 0, a), r.style.height = v + "px", n = parseInt(L.DomUtil.getStyle(this._tip, "width"), 10), i = new L.Point(f / 2, v + 1.414 * n), s.style.marginLeft = o.x - i.x + "px", s.style.marginTop = o.y - i.y + "px";
  } }), L.toolbar.popup = function(v) {
    return new L.Toolbar2.Popup(v);
  };
})(window);
var leaflet_markerclusterSrcExports = {}, leaflet_markerclusterSrc = {
  get exports() {
    return leaflet_markerclusterSrcExports;
  },
  set exports(x) {
    leaflet_markerclusterSrcExports = x;
  }
};
(function(x, C) {
  (function(c, p) {
    p(C);
  })(commonjsGlobal, function(c) {
    var p = L.MarkerClusterGroup = L.FeatureGroup.extend({
      options: {
        maxClusterRadius: 80,
        //A cluster will cover at most this many pixels from its center
        iconCreateFunction: null,
        clusterPane: L.Marker.prototype.options.pane,
        spiderfyOnEveryZoom: !1,
        spiderfyOnMaxZoom: !0,
        showCoverageOnHover: !0,
        zoomToBoundsOnClick: !0,
        singleMarkerMode: !1,
        disableClusteringAtZoom: null,
        // Setting this to false prevents the removal of any clusters outside of the viewpoint, which
        // is the default behaviour for performance reasons.
        removeOutsideVisibleBounds: !0,
        // Set to false to disable all animations (zoom and spiderfy).
        // If false, option animateAddingMarkers below has no effect.
        // If L.DomUtil.TRANSITION is falsy, this option has no effect.
        animate: !0,
        //Whether to animate adding markers after adding the MarkerClusterGroup to the map
        // If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.
        animateAddingMarkers: !1,
        // Make it possible to provide custom function to calculate spiderfy shape positions
        spiderfyShapePositions: null,
        //Increase to increase the distance away that spiderfied markers appear from the center
        spiderfyDistanceMultiplier: 1,
        // Make it possible to specify a polyline options on a spider leg
        spiderLegPolylineOptions: { weight: 1.5, color: "#222", opacity: 0.5 },
        // When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts
        chunkedLoading: !1,
        chunkInterval: 200,
        // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)
        chunkDelay: 50,
        // at the end of each interval, give n milliseconds back to system/browser
        chunkProgress: null,
        // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)
        //Options to pass to the L.Polygon constructor
        polygonOptions: {}
      },
      initialize: function(n) {
        L.Util.setOptions(this, n), this.options.iconCreateFunction || (this.options.iconCreateFunction = this._defaultIconCreateFunction), this._featureGroup = L.featureGroup(), this._featureGroup.addEventParent(this), this._nonPointGroup = L.featureGroup(), this._nonPointGroup.addEventParent(this), this._inZoomAnimation = 0, this._needsClustering = [], this._needsRemoving = [], this._currentShownBounds = null, this._queue = [], this._childMarkerEventHandlers = {
          dragstart: this._childMarkerDragStart,
          move: this._childMarkerMoved,
          dragend: this._childMarkerDragEnd
        };
        var i = L.DomUtil.TRANSITION && this.options.animate;
        L.extend(this, i ? this._withAnimation : this._noAnimation), this._markerCluster = i ? L.MarkerCluster : L.MarkerClusterNonAnimated;
      },
      addLayer: function(n) {
        if (n instanceof L.LayerGroup)
          return this.addLayers([n]);
        if (!n.getLatLng)
          return this._nonPointGroup.addLayer(n), this.fire("layeradd", { layer: n }), this;
        if (!this._map)
          return this._needsClustering.push(n), this.fire("layeradd", { layer: n }), this;
        if (this.hasLayer(n))
          return this;
        this._unspiderfy && this._unspiderfy(), this._addLayer(n, this._maxZoom), this.fire("layeradd", { layer: n }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons();
        var i = n, s = this._zoom;
        if (n.__parent)
          for (; i.__parent._zoom >= s; )
            i = i.__parent;
        return this._currentShownBounds.contains(i.getLatLng()) && (this.options.animateAddingMarkers ? this._animationAddLayer(n, i) : this._animationAddLayerNonAnimated(n, i)), this;
      },
      removeLayer: function(n) {
        return n instanceof L.LayerGroup ? this.removeLayers([n]) : n.getLatLng ? this._map ? n.__parent ? (this._unspiderfy && (this._unspiderfy(), this._unspiderfyLayer(n)), this._removeLayer(n, !0), this.fire("layerremove", { layer: n }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), n.off(this._childMarkerEventHandlers, this), this._featureGroup.hasLayer(n) && (this._featureGroup.removeLayer(n), n.clusterShow && n.clusterShow()), this) : this : (!this._arraySplice(this._needsClustering, n) && this.hasLayer(n) && this._needsRemoving.push({ layer: n, latlng: n._latlng }), this.fire("layerremove", { layer: n }), this) : (this._nonPointGroup.removeLayer(n), this.fire("layerremove", { layer: n }), this);
      },
      //Takes an array of markers and adds them in bulk
      addLayers: function(n, i) {
        if (!L.Util.isArray(n))
          return this.addLayer(n);
        var s = this._featureGroup, r = this._nonPointGroup, o = this.options.chunkedLoading, u = this.options.chunkInterval, a = this.options.chunkProgress, f = n.length, y = 0, T = !0, h;
        if (this._map) {
          var _ = (/* @__PURE__ */ new Date()).getTime(), g = L.bind(function() {
            var d = (/* @__PURE__ */ new Date()).getTime();
            for (this._map && this._unspiderfy && this._unspiderfy(); y < f; y++) {
              if (o && y % 200 === 0) {
                var b = (/* @__PURE__ */ new Date()).getTime() - d;
                if (b > u)
                  break;
              }
              if (h = n[y], h instanceof L.LayerGroup) {
                T && (n = n.slice(), T = !1), this._extractNonGroupLayers(h, n), f = n.length;
                continue;
              }
              if (!h.getLatLng) {
                r.addLayer(h), i || this.fire("layeradd", { layer: h });
                continue;
              }
              if (!this.hasLayer(h) && (this._addLayer(h, this._maxZoom), i || this.fire("layeradd", { layer: h }), h.__parent && h.__parent.getChildCount() === 2)) {
                var k = h.__parent.getAllChildMarkers(), O = k[0] === h ? k[1] : k[0];
                s.removeLayer(O);
              }
            }
            a && a(y, f, (/* @__PURE__ */ new Date()).getTime() - _), y === f ? (this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds)) : setTimeout(g, this.options.chunkDelay);
          }, this);
          g();
        } else
          for (var S = this._needsClustering; y < f; y++) {
            if (h = n[y], h instanceof L.LayerGroup) {
              T && (n = n.slice(), T = !1), this._extractNonGroupLayers(h, n), f = n.length;
              continue;
            }
            if (!h.getLatLng) {
              r.addLayer(h);
              continue;
            }
            this.hasLayer(h) || S.push(h);
          }
        return this;
      },
      //Takes an array of markers and removes them in bulk
      removeLayers: function(n) {
        var i, s, r = n.length, o = this._featureGroup, u = this._nonPointGroup, a = !0;
        if (!this._map) {
          for (i = 0; i < r; i++) {
            if (s = n[i], s instanceof L.LayerGroup) {
              a && (n = n.slice(), a = !1), this._extractNonGroupLayers(s, n), r = n.length;
              continue;
            }
            this._arraySplice(this._needsClustering, s), u.removeLayer(s), this.hasLayer(s) && this._needsRemoving.push({ layer: s, latlng: s._latlng }), this.fire("layerremove", { layer: s });
          }
          return this;
        }
        if (this._unspiderfy) {
          this._unspiderfy();
          var f = n.slice(), y = r;
          for (i = 0; i < y; i++) {
            if (s = f[i], s instanceof L.LayerGroup) {
              this._extractNonGroupLayers(s, f), y = f.length;
              continue;
            }
            this._unspiderfyLayer(s);
          }
        }
        for (i = 0; i < r; i++) {
          if (s = n[i], s instanceof L.LayerGroup) {
            a && (n = n.slice(), a = !1), this._extractNonGroupLayers(s, n), r = n.length;
            continue;
          }
          if (!s.__parent) {
            u.removeLayer(s), this.fire("layerremove", { layer: s });
            continue;
          }
          this._removeLayer(s, !0, !0), this.fire("layerremove", { layer: s }), o.hasLayer(s) && (o.removeLayer(s), s.clusterShow && s.clusterShow());
        }
        return this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds), this;
      },
      //Removes all layers from the MarkerClusterGroup
      clearLayers: function() {
        return this._map || (this._needsClustering = [], this._needsRemoving = [], delete this._gridClusters, delete this._gridUnclustered), this._noanimationUnspiderfy && this._noanimationUnspiderfy(), this._featureGroup.clearLayers(), this._nonPointGroup.clearLayers(), this.eachLayer(function(n) {
          n.off(this._childMarkerEventHandlers, this), delete n.__parent;
        }, this), this._map && this._generateInitialClusters(), this;
      },
      //Override FeatureGroup.getBounds as it doesn't work
      getBounds: function() {
        var n = new L.LatLngBounds();
        this._topClusterLevel && n.extend(this._topClusterLevel._bounds);
        for (var i = this._needsClustering.length - 1; i >= 0; i--)
          n.extend(this._needsClustering[i].getLatLng());
        return n.extend(this._nonPointGroup.getBounds()), n;
      },
      //Overrides LayerGroup.eachLayer
      eachLayer: function(n, i) {
        var s = this._needsClustering.slice(), r = this._needsRemoving, o, u, a;
        for (this._topClusterLevel && this._topClusterLevel.getAllChildMarkers(s), u = s.length - 1; u >= 0; u--) {
          for (o = !0, a = r.length - 1; a >= 0; a--)
            if (r[a].layer === s[u]) {
              o = !1;
              break;
            }
          o && n.call(i, s[u]);
        }
        this._nonPointGroup.eachLayer(n, i);
      },
      //Overrides LayerGroup.getLayers
      getLayers: function() {
        var n = [];
        return this.eachLayer(function(i) {
          n.push(i);
        }), n;
      },
      //Overrides LayerGroup.getLayer, WARNING: Really bad performance
      getLayer: function(n) {
        var i = null;
        return n = parseInt(n, 10), this.eachLayer(function(s) {
          L.stamp(s) === n && (i = s);
        }), i;
      },
      //Returns true if the given layer is in this MarkerClusterGroup
      hasLayer: function(n) {
        if (!n)
          return !1;
        var i, s = this._needsClustering;
        for (i = s.length - 1; i >= 0; i--)
          if (s[i] === n)
            return !0;
        for (s = this._needsRemoving, i = s.length - 1; i >= 0; i--)
          if (s[i].layer === n)
            return !1;
        return !!(n.__parent && n.__parent._group === this) || this._nonPointGroup.hasLayer(n);
      },
      //Zoom down to show the given layer (spiderfying if necessary) then calls the callback
      zoomToShowLayer: function(n, i) {
        var s = this._map;
        typeof i != "function" && (i = function() {
        });
        var r = function() {
          (s.hasLayer(n) || s.hasLayer(n.__parent)) && !this._inZoomAnimation && (this._map.off("moveend", r, this), this.off("animationend", r, this), s.hasLayer(n) ? i() : n.__parent._icon && (this.once("spiderfied", i, this), n.__parent.spiderfy()));
        };
        n._icon && this._map.getBounds().contains(n.getLatLng()) ? i() : n.__parent._zoom < Math.round(this._map._zoom) ? (this._map.on("moveend", r, this), this._map.panTo(n.getLatLng())) : (this._map.on("moveend", r, this), this.on("animationend", r, this), n.__parent.zoomToBounds());
      },
      //Overrides FeatureGroup.onAdd
      onAdd: function(n) {
        this._map = n;
        var i, s, r;
        if (!isFinite(this._map.getMaxZoom()))
          throw "Map has no maxZoom specified";
        for (this._featureGroup.addTo(n), this._nonPointGroup.addTo(n), this._gridClusters || this._generateInitialClusters(), this._maxLat = n.options.crs.projection.MAX_LATITUDE, i = 0, s = this._needsRemoving.length; i < s; i++)
          r = this._needsRemoving[i], r.newlatlng = r.layer._latlng, r.layer._latlng = r.latlng;
        for (i = 0, s = this._needsRemoving.length; i < s; i++)
          r = this._needsRemoving[i], this._removeLayer(r.layer, !0), r.layer._latlng = r.newlatlng;
        this._needsRemoving = [], this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds(), this._map.on("zoomend", this._zoomEnd, this), this._map.on("moveend", this._moveEnd, this), this._spiderfierOnAdd && this._spiderfierOnAdd(), this._bindEvents(), s = this._needsClustering, this._needsClustering = [], this.addLayers(s, !0);
      },
      //Overrides FeatureGroup.onRemove
      onRemove: function(n) {
        n.off("zoomend", this._zoomEnd, this), n.off("moveend", this._moveEnd, this), this._unbindEvents(), this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", ""), this._spiderfierOnRemove && this._spiderfierOnRemove(), delete this._maxLat, this._hideCoverage(), this._featureGroup.remove(), this._nonPointGroup.remove(), this._featureGroup.clearLayers(), this._map = null;
      },
      getVisibleParent: function(n) {
        for (var i = n; i && !i._icon; )
          i = i.__parent;
        return i || null;
      },
      //Remove the given object from the given array
      _arraySplice: function(n, i) {
        for (var s = n.length - 1; s >= 0; s--)
          if (n[s] === i)
            return n.splice(s, 1), !0;
      },
      /**
       * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.
       * @param marker to be removed from _gridUnclustered.
       * @param z integer bottom start zoom level (included)
       * @private
       */
      _removeFromGridUnclustered: function(n, i) {
        for (var s = this._map, r = this._gridUnclustered, o = Math.floor(this._map.getMinZoom()); i >= o && r[i].removeObject(n, s.project(n.getLatLng(), i)); i--)
          ;
      },
      _childMarkerDragStart: function(n) {
        n.target.__dragStart = n.target._latlng;
      },
      _childMarkerMoved: function(n) {
        if (!this._ignoreMove && !n.target.__dragStart) {
          var i = n.target._popup && n.target._popup.isOpen();
          this._moveChild(n.target, n.oldLatLng, n.latlng), i && n.target.openPopup();
        }
      },
      _moveChild: function(n, i, s) {
        n._latlng = i, this.removeLayer(n), n._latlng = s, this.addLayer(n);
      },
      _childMarkerDragEnd: function(n) {
        var i = n.target.__dragStart;
        delete n.target.__dragStart, i && this._moveChild(n.target, i, n.target._latlng);
      },
      //Internal function for removing a marker from everything.
      //dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
      _removeLayer: function(n, i, s) {
        var r = this._gridClusters, o = this._gridUnclustered, u = this._featureGroup, a = this._map, f = Math.floor(this._map.getMinZoom());
        i && this._removeFromGridUnclustered(n, this._maxZoom);
        var y = n.__parent, T = y._markers, h;
        for (this._arraySplice(T, n); y && (y._childCount--, y._boundsNeedUpdate = !0, !(y._zoom < f)); )
          i && y._childCount <= 1 ? (h = y._markers[0] === n ? y._markers[1] : y._markers[0], r[y._zoom].removeObject(y, a.project(y._cLatLng, y._zoom)), o[y._zoom].addObject(h, a.project(h.getLatLng(), y._zoom)), this._arraySplice(y.__parent._childClusters, y), y.__parent._markers.push(h), h.__parent = y.__parent, y._icon && (u.removeLayer(y), s || u.addLayer(h))) : y._iconNeedsUpdate = !0, y = y.__parent;
        delete n.__parent;
      },
      _isOrIsParent: function(n, i) {
        for (; i; ) {
          if (n === i)
            return !0;
          i = i.parentNode;
        }
        return !1;
      },
      //Override L.Evented.fire
      fire: function(n, i, s) {
        if (i && i.layer instanceof L.MarkerCluster) {
          if (i.originalEvent && this._isOrIsParent(i.layer._icon, i.originalEvent.relatedTarget))
            return;
          n = "cluster" + n;
        }
        L.FeatureGroup.prototype.fire.call(this, n, i, s);
      },
      //Override L.Evented.listens
      listens: function(n, i) {
        return L.FeatureGroup.prototype.listens.call(this, n, i) || L.FeatureGroup.prototype.listens.call(this, "cluster" + n, i);
      },
      //Default functionality
      _defaultIconCreateFunction: function(n) {
        var i = n.getChildCount(), s = " marker-cluster-";
        return i < 10 ? s += "small" : i < 100 ? s += "medium" : s += "large", new L.DivIcon({ html: "<div><span>" + i + "</span></div>", className: "marker-cluster" + s, iconSize: new L.Point(40, 40) });
      },
      _bindEvents: function() {
        var n = this._map, i = this.options.spiderfyOnMaxZoom, s = this.options.showCoverageOnHover, r = this.options.zoomToBoundsOnClick, o = this.options.spiderfyOnEveryZoom;
        (i || r || o) && this.on("clusterclick clusterkeypress", this._zoomOrSpiderfy, this), s && (this.on("clustermouseover", this._showCoverage, this), this.on("clustermouseout", this._hideCoverage, this), n.on("zoomend", this._hideCoverage, this));
      },
      _zoomOrSpiderfy: function(n) {
        var i = n.layer, s = i;
        if (!(n.type === "clusterkeypress" && n.originalEvent && n.originalEvent.keyCode !== 13)) {
          for (; s._childClusters.length === 1; )
            s = s._childClusters[0];
          s._zoom === this._maxZoom && s._childCount === i._childCount && this.options.spiderfyOnMaxZoom ? i.spiderfy() : this.options.zoomToBoundsOnClick && i.zoomToBounds(), this.options.spiderfyOnEveryZoom && i.spiderfy(), n.originalEvent && n.originalEvent.keyCode === 13 && this._map._container.focus();
        }
      },
      _showCoverage: function(n) {
        var i = this._map;
        this._inZoomAnimation || (this._shownPolygon && i.removeLayer(this._shownPolygon), n.layer.getChildCount() > 2 && n.layer !== this._spiderfied && (this._shownPolygon = new L.Polygon(n.layer.getConvexHull(), this.options.polygonOptions), i.addLayer(this._shownPolygon)));
      },
      _hideCoverage: function() {
        this._shownPolygon && (this._map.removeLayer(this._shownPolygon), this._shownPolygon = null);
      },
      _unbindEvents: function() {
        var n = this.options.spiderfyOnMaxZoom, i = this.options.showCoverageOnHover, s = this.options.zoomToBoundsOnClick, r = this.options.spiderfyOnEveryZoom, o = this._map;
        (n || s || r) && this.off("clusterclick clusterkeypress", this._zoomOrSpiderfy, this), i && (this.off("clustermouseover", this._showCoverage, this), this.off("clustermouseout", this._hideCoverage, this), o.off("zoomend", this._hideCoverage, this));
      },
      _zoomEnd: function() {
        this._map && (this._mergeSplitClusters(), this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds());
      },
      _moveEnd: function() {
        if (!this._inZoomAnimation) {
          var n = this._getExpandedVisibleBounds();
          this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, n), this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), n), this._currentShownBounds = n;
        }
      },
      _generateInitialClusters: function() {
        var n = Math.ceil(this._map.getMaxZoom()), i = Math.floor(this._map.getMinZoom()), s = this.options.maxClusterRadius, r = s;
        typeof s != "function" && (r = function() {
          return s;
        }), this.options.disableClusteringAtZoom !== null && (n = this.options.disableClusteringAtZoom - 1), this._maxZoom = n, this._gridClusters = {}, this._gridUnclustered = {};
        for (var o = n; o >= i; o--)
          this._gridClusters[o] = new L.DistanceGrid(r(o)), this._gridUnclustered[o] = new L.DistanceGrid(r(o));
        this._topClusterLevel = new this._markerCluster(this, i - 1);
      },
      //Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
      _addLayer: function(n, i) {
        var s = this._gridClusters, r = this._gridUnclustered, o = Math.floor(this._map.getMinZoom()), u, a;
        for (this.options.singleMarkerMode && this._overrideMarkerIcon(n), n.on(this._childMarkerEventHandlers, this); i >= o; i--) {
          u = this._map.project(n.getLatLng(), i);
          var f = s[i].getNearObject(u);
          if (f) {
            f._addChild(n), n.__parent = f;
            return;
          }
          if (f = r[i].getNearObject(u), f) {
            var y = f.__parent;
            y && this._removeLayer(f, !1);
            var T = new this._markerCluster(this, i, f, n);
            s[i].addObject(T, this._map.project(T._cLatLng, i)), f.__parent = T, n.__parent = T;
            var h = T;
            for (a = i - 1; a > y._zoom; a--)
              h = new this._markerCluster(this, a, h), s[a].addObject(h, this._map.project(f.getLatLng(), a));
            y._addChild(h), this._removeFromGridUnclustered(f, i);
            return;
          }
          r[i].addObject(n, u);
        }
        this._topClusterLevel._addChild(n), n.__parent = this._topClusterLevel;
      },
      /**
       * Refreshes the icon of all "dirty" visible clusters.
       * Non-visible "dirty" clusters will be updated when they are added to the map.
       * @private
       */
      _refreshClustersIcons: function() {
        this._featureGroup.eachLayer(function(n) {
          n instanceof L.MarkerCluster && n._iconNeedsUpdate && n._updateIcon();
        });
      },
      //Enqueue code to fire after the marker expand/contract has happened
      _enqueue: function(n) {
        this._queue.push(n), this._queueTimeout || (this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300));
      },
      _processQueue: function() {
        for (var n = 0; n < this._queue.length; n++)
          this._queue[n].call(this);
        this._queue.length = 0, clearTimeout(this._queueTimeout), this._queueTimeout = null;
      },
      //Merge and split any existing clusters that are too big or small
      _mergeSplitClusters: function() {
        var n = Math.round(this._map._zoom);
        this._processQueue(), this._zoom < n && this._currentShownBounds.intersects(this._getExpandedVisibleBounds()) ? (this._animationStart(), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds()), this._animationZoomIn(this._zoom, n)) : this._zoom > n ? (this._animationStart(), this._animationZoomOut(this._zoom, n)) : this._moveEnd();
      },
      //Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)
      _getExpandedVisibleBounds: function() {
        if (this.options.removeOutsideVisibleBounds) {
          if (L.Browser.mobile)
            return this._checkBoundsMaxLat(this._map.getBounds());
        } else
          return this._mapBoundsInfinite;
        return this._checkBoundsMaxLat(this._map.getBounds().pad(1));
      },
      /**
       * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude
       * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).
       * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without
       * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,
       * making the user think that MCG "eats" them and never displays them again.
       * @param bounds L.LatLngBounds
       * @returns {L.LatLngBounds}
       * @private
       */
      _checkBoundsMaxLat: function(n) {
        var i = this._maxLat;
        return i !== void 0 && (n.getNorth() >= i && (n._northEast.lat = 1 / 0), n.getSouth() <= -i && (n._southWest.lat = -1 / 0)), n;
      },
      //Shared animation code
      _animationAddLayerNonAnimated: function(n, i) {
        if (i === n)
          this._featureGroup.addLayer(n);
        else if (i._childCount === 2) {
          i._addToMap();
          var s = i.getAllChildMarkers();
          this._featureGroup.removeLayer(s[0]), this._featureGroup.removeLayer(s[1]);
        } else
          i._updateIcon();
      },
      /**
       * Extracts individual (i.e. non-group) layers from a Layer Group.
       * @param group to extract layers from.
       * @param output {Array} in which to store the extracted layers.
       * @returns {*|Array}
       * @private
       */
      _extractNonGroupLayers: function(n, i) {
        var s = n.getLayers(), r = 0, o;
        for (i = i || []; r < s.length; r++) {
          if (o = s[r], o instanceof L.LayerGroup) {
            this._extractNonGroupLayers(o, i);
            continue;
          }
          i.push(o);
        }
        return i;
      },
      /**
       * Implements the singleMarkerMode option.
       * @param layer Marker to re-style using the Clusters iconCreateFunction.
       * @returns {L.Icon} The newly created icon.
       * @private
       */
      _overrideMarkerIcon: function(n) {
        var i = n.options.icon = this.options.iconCreateFunction({
          getChildCount: function() {
            return 1;
          },
          getAllChildMarkers: function() {
            return [n];
          }
        });
        return i;
      }
    });
    L.MarkerClusterGroup.include({
      _mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-1 / 0, -1 / 0), new L.LatLng(1 / 0, 1 / 0))
    }), L.MarkerClusterGroup.include({
      _noAnimation: {
        //Non Animated versions of everything
        _animationStart: function() {
        },
        _animationZoomIn: function(n, i) {
          this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), n), this._topClusterLevel._recursivelyAddChildrenToMap(null, i, this._getExpandedVisibleBounds()), this.fire("animationend");
        },
        _animationZoomOut: function(n, i) {
          this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), n), this._topClusterLevel._recursivelyAddChildrenToMap(null, i, this._getExpandedVisibleBounds()), this.fire("animationend");
        },
        _animationAddLayer: function(n, i) {
          this._animationAddLayerNonAnimated(n, i);
        }
      },
      _withAnimation: {
        //Animated versions here
        _animationStart: function() {
          this._map._mapPane.className += " leaflet-cluster-anim", this._inZoomAnimation++;
        },
        _animationZoomIn: function(n, i) {
          var s = this._getExpandedVisibleBounds(), r = this._featureGroup, o = Math.floor(this._map.getMinZoom()), u;
          this._ignoreMove = !0, this._topClusterLevel._recursively(s, n, o, function(a) {
            var f = a._latlng, y = a._markers, T;
            for (s.contains(f) || (f = null), a._isSingleParent() && n + 1 === i ? (r.removeLayer(a), a._recursivelyAddChildrenToMap(null, i, s)) : (a.clusterHide(), a._recursivelyAddChildrenToMap(f, i, s)), u = y.length - 1; u >= 0; u--)
              T = y[u], s.contains(T._latlng) || r.removeLayer(T);
          }), this._forceLayout(), this._topClusterLevel._recursivelyBecomeVisible(s, i), r.eachLayer(function(a) {
            !(a instanceof L.MarkerCluster) && a._icon && a.clusterShow();
          }), this._topClusterLevel._recursively(s, n, i, function(a) {
            a._recursivelyRestoreChildPositions(i);
          }), this._ignoreMove = !1, this._enqueue(function() {
            this._topClusterLevel._recursively(s, n, o, function(a) {
              r.removeLayer(a), a.clusterShow();
            }), this._animationEnd();
          });
        },
        _animationZoomOut: function(n, i) {
          this._animationZoomOutSingle(this._topClusterLevel, n - 1, i), this._topClusterLevel._recursivelyAddChildrenToMap(null, i, this._getExpandedVisibleBounds()), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), n, this._getExpandedVisibleBounds());
        },
        _animationAddLayer: function(n, i) {
          var s = this, r = this._featureGroup;
          r.addLayer(n), i !== n && (i._childCount > 2 ? (i._updateIcon(), this._forceLayout(), this._animationStart(), n._setPos(this._map.latLngToLayerPoint(i.getLatLng())), n.clusterHide(), this._enqueue(function() {
            r.removeLayer(n), n.clusterShow(), s._animationEnd();
          })) : (this._forceLayout(), s._animationStart(), s._animationZoomOutSingle(i, this._map.getMaxZoom(), this._zoom)));
        }
      },
      // Private methods for animated versions.
      _animationZoomOutSingle: function(n, i, s) {
        var r = this._getExpandedVisibleBounds(), o = Math.floor(this._map.getMinZoom());
        n._recursivelyAnimateChildrenInAndAddSelfToMap(r, o, i + 1, s);
        var u = this;
        this._forceLayout(), n._recursivelyBecomeVisible(r, s), this._enqueue(function() {
          if (n._childCount === 1) {
            var a = n._markers[0];
            this._ignoreMove = !0, a.setLatLng(a.getLatLng()), this._ignoreMove = !1, a.clusterShow && a.clusterShow();
          } else
            n._recursively(r, s, o, function(f) {
              f._recursivelyRemoveChildrenFromMap(r, o, i + 1);
            });
          u._animationEnd();
        });
      },
      _animationEnd: function() {
        this._map && (this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", "")), this._inZoomAnimation--, this.fire("animationend");
      },
      //Force a browser layout of stuff in the map
      // Should apply the current opacity and location to all elements so we can update them again for an animation
      _forceLayout: function() {
        L.Util.falseFn(document.body.offsetWidth);
      }
    }), L.markerClusterGroup = function(n) {
      return new L.MarkerClusterGroup(n);
    };
    var v = L.MarkerCluster = L.Marker.extend({
      options: L.Icon.prototype.options,
      initialize: function(n, i, s, r) {
        L.Marker.prototype.initialize.call(
          this,
          s ? s._cLatLng || s.getLatLng() : new L.LatLng(0, 0),
          { icon: this, pane: n.options.clusterPane }
        ), this._group = n, this._zoom = i, this._markers = [], this._childClusters = [], this._childCount = 0, this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._bounds = new L.LatLngBounds(), s && this._addChild(s), r && this._addChild(r);
      },
      //Recursively retrieve all child markers of this cluster
      getAllChildMarkers: function(n, i) {
        n = n || [];
        for (var s = this._childClusters.length - 1; s >= 0; s--)
          this._childClusters[s].getAllChildMarkers(n, i);
        for (var r = this._markers.length - 1; r >= 0; r--)
          i && this._markers[r].__dragStart || n.push(this._markers[r]);
        return n;
      },
      //Returns the count of how many child markers we have
      getChildCount: function() {
        return this._childCount;
      },
      //Zoom to the minimum of showing all of the child markers, or the extents of this cluster
      zoomToBounds: function(n) {
        for (var i = this._childClusters.slice(), s = this._group._map, r = s.getBoundsZoom(this._bounds), o = this._zoom + 1, u = s.getZoom(), a; i.length > 0 && r > o; ) {
          o++;
          var f = [];
          for (a = 0; a < i.length; a++)
            f = f.concat(i[a]._childClusters);
          i = f;
        }
        r > o ? this._group._map.setView(this._latlng, o) : r <= u ? this._group._map.setView(this._latlng, u + 1) : this._group._map.fitBounds(this._bounds, n);
      },
      getBounds: function() {
        var n = new L.LatLngBounds();
        return n.extend(this._bounds), n;
      },
      _updateIcon: function() {
        this._iconNeedsUpdate = !0, this._icon && this.setIcon(this);
      },
      //Cludge for Icon, we pretend to be an icon for performance
      createIcon: function() {
        return this._iconNeedsUpdate && (this._iconObj = this._group.options.iconCreateFunction(this), this._iconNeedsUpdate = !1), this._iconObj.createIcon();
      },
      createShadow: function() {
        return this._iconObj.createShadow();
      },
      _addChild: function(n, i) {
        this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._setClusterCenter(n), n instanceof L.MarkerCluster ? (i || (this._childClusters.push(n), n.__parent = this), this._childCount += n._childCount) : (i || this._markers.push(n), this._childCount++), this.__parent && this.__parent._addChild(n, !0);
      },
      /**
       * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.
       * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.
       * @private
       */
      _setClusterCenter: function(n) {
        this._cLatLng || (this._cLatLng = n._cLatLng || n._latlng);
      },
      /**
       * Assigns impossible bounding values so that the next extend entirely determines the new bounds.
       * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.
       * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.
       * @private
       */
      _resetBounds: function() {
        var n = this._bounds;
        n._southWest && (n._southWest.lat = 1 / 0, n._southWest.lng = 1 / 0), n._northEast && (n._northEast.lat = -1 / 0, n._northEast.lng = -1 / 0);
      },
      _recalculateBounds: function() {
        var n = this._markers, i = this._childClusters, s = 0, r = 0, o = this._childCount, u, a, f, y;
        if (o !== 0) {
          for (this._resetBounds(), u = 0; u < n.length; u++)
            f = n[u]._latlng, this._bounds.extend(f), s += f.lat, r += f.lng;
          for (u = 0; u < i.length; u++)
            a = i[u], a._boundsNeedUpdate && a._recalculateBounds(), this._bounds.extend(a._bounds), f = a._wLatLng, y = a._childCount, s += f.lat * y, r += f.lng * y;
          this._latlng = this._wLatLng = new L.LatLng(s / o, r / o), this._boundsNeedUpdate = !1;
        }
      },
      //Set our markers position as given and add it to the map
      _addToMap: function(n) {
        n && (this._backupLatlng = this._latlng, this.setLatLng(n)), this._group._featureGroup.addLayer(this);
      },
      _recursivelyAnimateChildrenIn: function(n, i, s) {
        this._recursively(
          n,
          this._group._map.getMinZoom(),
          s - 1,
          function(r) {
            var o = r._markers, u, a;
            for (u = o.length - 1; u >= 0; u--)
              a = o[u], a._icon && (a._setPos(i), a.clusterHide());
          },
          function(r) {
            var o = r._childClusters, u, a;
            for (u = o.length - 1; u >= 0; u--)
              a = o[u], a._icon && (a._setPos(i), a.clusterHide());
          }
        );
      },
      _recursivelyAnimateChildrenInAndAddSelfToMap: function(n, i, s, r) {
        this._recursively(
          n,
          r,
          i,
          function(o) {
            o._recursivelyAnimateChildrenIn(n, o._group._map.latLngToLayerPoint(o.getLatLng()).round(), s), o._isSingleParent() && s - 1 === r ? (o.clusterShow(), o._recursivelyRemoveChildrenFromMap(n, i, s)) : o.clusterHide(), o._addToMap();
          }
        );
      },
      _recursivelyBecomeVisible: function(n, i) {
        this._recursively(n, this._group._map.getMinZoom(), i, null, function(s) {
          s.clusterShow();
        });
      },
      _recursivelyAddChildrenToMap: function(n, i, s) {
        this._recursively(
          s,
          this._group._map.getMinZoom() - 1,
          i,
          function(r) {
            if (i !== r._zoom)
              for (var o = r._markers.length - 1; o >= 0; o--) {
                var u = r._markers[o];
                s.contains(u._latlng) && (n && (u._backupLatlng = u.getLatLng(), u.setLatLng(n), u.clusterHide && u.clusterHide()), r._group._featureGroup.addLayer(u));
              }
          },
          function(r) {
            r._addToMap(n);
          }
        );
      },
      _recursivelyRestoreChildPositions: function(n) {
        for (var i = this._markers.length - 1; i >= 0; i--) {
          var s = this._markers[i];
          s._backupLatlng && (s.setLatLng(s._backupLatlng), delete s._backupLatlng);
        }
        if (n - 1 === this._zoom)
          for (var r = this._childClusters.length - 1; r >= 0; r--)
            this._childClusters[r]._restorePosition();
        else
          for (var o = this._childClusters.length - 1; o >= 0; o--)
            this._childClusters[o]._recursivelyRestoreChildPositions(n);
      },
      _restorePosition: function() {
        this._backupLatlng && (this.setLatLng(this._backupLatlng), delete this._backupLatlng);
      },
      //exceptBounds: If set, don't remove any markers/clusters in it
      _recursivelyRemoveChildrenFromMap: function(n, i, s, r) {
        var o, u;
        this._recursively(
          n,
          i - 1,
          s - 1,
          function(a) {
            for (u = a._markers.length - 1; u >= 0; u--)
              o = a._markers[u], (!r || !r.contains(o._latlng)) && (a._group._featureGroup.removeLayer(o), o.clusterShow && o.clusterShow());
          },
          function(a) {
            for (u = a._childClusters.length - 1; u >= 0; u--)
              o = a._childClusters[u], (!r || !r.contains(o._latlng)) && (a._group._featureGroup.removeLayer(o), o.clusterShow && o.clusterShow());
          }
        );
      },
      //Run the given functions recursively to this and child clusters
      // boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to
      // zoomLevelToStart: zoom level to start running functions (inclusive)
      // zoomLevelToStop: zoom level to stop running functions (inclusive)
      // runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level
      // runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level
      _recursively: function(n, i, s, r, o) {
        var u = this._childClusters, a = this._zoom, f, y;
        if (i <= a && (r && r(this), o && a === s && o(this)), a < i || a < s)
          for (f = u.length - 1; f >= 0; f--)
            y = u[f], y._boundsNeedUpdate && y._recalculateBounds(), n.intersects(y._bounds) && y._recursively(n, i, s, r, o);
      },
      //Returns true if we are the parent of only one cluster and that cluster is the same as us
      _isSingleParent: function() {
        return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
      }
    });
    L.Marker.include({
      clusterHide: function() {
        var n = this.options.opacity;
        return this.setOpacity(0), this.options.opacity = n, this;
      },
      clusterShow: function() {
        return this.setOpacity(this.options.opacity);
      }
    }), L.DistanceGrid = function(n) {
      this._cellSize = n, this._sqCellSize = n * n, this._grid = {}, this._objectPoint = {};
    }, L.DistanceGrid.prototype = {
      addObject: function(n, i) {
        var s = this._getCoord(i.x), r = this._getCoord(i.y), o = this._grid, u = o[r] = o[r] || {}, a = u[s] = u[s] || [], f = L.Util.stamp(n);
        this._objectPoint[f] = i, a.push(n);
      },
      updateObject: function(n, i) {
        this.removeObject(n), this.addObject(n, i);
      },
      //Returns true if the object was found
      removeObject: function(n, i) {
        var s = this._getCoord(i.x), r = this._getCoord(i.y), o = this._grid, u = o[r] = o[r] || {}, a = u[s] = u[s] || [], f, y;
        for (delete this._objectPoint[L.Util.stamp(n)], f = 0, y = a.length; f < y; f++)
          if (a[f] === n)
            return a.splice(f, 1), y === 1 && delete u[s], !0;
      },
      eachObject: function(n, i) {
        var s, r, o, u, a, f, y, T = this._grid;
        for (s in T) {
          a = T[s];
          for (r in a)
            for (f = a[r], o = 0, u = f.length; o < u; o++)
              y = n.call(i, f[o]), y && (o--, u--);
        }
      },
      getNearObject: function(n) {
        var i = this._getCoord(n.x), s = this._getCoord(n.y), r, o, u, a, f, y, T, h, _ = this._objectPoint, g = this._sqCellSize, S = null;
        for (r = s - 1; r <= s + 1; r++)
          if (a = this._grid[r], a) {
            for (o = i - 1; o <= i + 1; o++)
              if (f = a[o], f)
                for (u = 0, y = f.length; u < y; u++)
                  T = f[u], h = this._sqDist(_[L.Util.stamp(T)], n), (h < g || h <= g && S === null) && (g = h, S = T);
          }
        return S;
      },
      _getCoord: function(n) {
        var i = Math.floor(n / this._cellSize);
        return isFinite(i) ? i : n;
      },
      _sqDist: function(n, i) {
        var s = i.x - n.x, r = i.y - n.y;
        return s * s + r * r;
      }
    }, function() {
      L.QuickHull = {
        /*
         * @param {Object} cpt a point to be measured from the baseline
         * @param {Array} bl the baseline, as represented by a two-element
         *   array of latlng objects.
         * @returns {Number} an approximate distance measure
         */
        getDistant: function(n, i) {
          var s = i[1].lat - i[0].lat, r = i[0].lng - i[1].lng;
          return r * (n.lat - i[0].lat) + s * (n.lng - i[0].lng);
        },
        /*
         * @param {Array} baseLine a two-element array of latlng objects
         *   representing the baseline to project from
         * @param {Array} latLngs an array of latlng objects
         * @returns {Object} the maximum point and all new points to stay
         *   in consideration for the hull.
         */
        findMostDistantPointFromBaseLine: function(n, i) {
          var s = 0, r = null, o = [], u, a, f;
          for (u = i.length - 1; u >= 0; u--) {
            if (a = i[u], f = this.getDistant(a, n), f > 0)
              o.push(a);
            else
              continue;
            f > s && (s = f, r = a);
          }
          return { maxPoint: r, newPoints: o };
        },
        /*
         * Given a baseline, compute the convex hull of latLngs as an array
         * of latLngs.
         *
         * @param {Array} latLngs
         * @returns {Array}
         */
        buildConvexHull: function(n, i) {
          var s = [], r = this.findMostDistantPointFromBaseLine(n, i);
          return r.maxPoint ? (s = s.concat(
            this.buildConvexHull([n[0], r.maxPoint], r.newPoints)
          ), s = s.concat(
            this.buildConvexHull([r.maxPoint, n[1]], r.newPoints)
          ), s) : [n[0]];
        },
        /*
         * Given an array of latlngs, compute a convex hull as an array
         * of latlngs
         *
         * @param {Array} latLngs
         * @returns {Array}
         */
        getConvexHull: function(n) {
          var i = !1, s = !1, r = !1, o = !1, u = null, a = null, f = null, y = null, T = null, h = null, _;
          for (_ = n.length - 1; _ >= 0; _--) {
            var g = n[_];
            (i === !1 || g.lat > i) && (u = g, i = g.lat), (s === !1 || g.lat < s) && (a = g, s = g.lat), (r === !1 || g.lng > r) && (f = g, r = g.lng), (o === !1 || g.lng < o) && (y = g, o = g.lng);
          }
          s !== i ? (h = a, T = u) : (h = y, T = f);
          var S = [].concat(
            this.buildConvexHull([h, T], n),
            this.buildConvexHull([T, h], n)
          );
          return S;
        }
      };
    }(), L.MarkerCluster.include({
      getConvexHull: function() {
        var n = this.getAllChildMarkers(), i = [], s, r;
        for (r = n.length - 1; r >= 0; r--)
          s = n[r].getLatLng(), i.push(s);
        return L.QuickHull.getConvexHull(i);
      }
    }), L.MarkerCluster.include({
      _2PI: Math.PI * 2,
      _circleFootSeparation: 25,
      //related to circumference of circle
      _circleStartAngle: 0,
      _spiralFootSeparation: 28,
      //related to size of spiral (experiment!)
      _spiralLengthStart: 11,
      _spiralLengthFactor: 5,
      _circleSpiralSwitchover: 9,
      //show spiral instead of circle from this marker count upwards.
      // 0 -> always spiral; Infinity -> always circle
      spiderfy: function() {
        if (!(this._group._spiderfied === this || this._group._inZoomAnimation)) {
          var n = this.getAllChildMarkers(null, !0), i = this._group, s = i._map, r = s.latLngToLayerPoint(this._latlng), o;
          this._group._unspiderfy(), this._group._spiderfied = this, this._group.options.spiderfyShapePositions ? o = this._group.options.spiderfyShapePositions(n.length, r) : n.length >= this._circleSpiralSwitchover ? o = this._generatePointsSpiral(n.length, r) : (r.y += 10, o = this._generatePointsCircle(n.length, r)), this._animationSpiderfy(n, o);
        }
      },
      unspiderfy: function(n) {
        this._group._inZoomAnimation || (this._animationUnspiderfy(n), this._group._spiderfied = null);
      },
      _generatePointsCircle: function(n, i) {
        var s = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + n), r = s / this._2PI, o = this._2PI / n, u = [], a, f;
        for (r = Math.max(r, 35), u.length = n, a = 0; a < n; a++)
          f = this._circleStartAngle + a * o, u[a] = new L.Point(i.x + r * Math.cos(f), i.y + r * Math.sin(f))._round();
        return u;
      },
      _generatePointsSpiral: function(n, i) {
        var s = this._group.options.spiderfyDistanceMultiplier, r = s * this._spiralLengthStart, o = s * this._spiralFootSeparation, u = s * this._spiralLengthFactor * this._2PI, a = 0, f = [], y;
        for (f.length = n, y = n; y >= 0; y--)
          y < n && (f[y] = new L.Point(i.x + r * Math.cos(a), i.y + r * Math.sin(a))._round()), a += o / r + y * 5e-4, r += u / a;
        return f;
      },
      _noanimationUnspiderfy: function() {
        var n = this._group, i = n._map, s = n._featureGroup, r = this.getAllChildMarkers(null, !0), o, u;
        for (n._ignoreMove = !0, this.setOpacity(1), u = r.length - 1; u >= 0; u--)
          o = r[u], s.removeLayer(o), o._preSpiderfyLatlng && (o.setLatLng(o._preSpiderfyLatlng), delete o._preSpiderfyLatlng), o.setZIndexOffset && o.setZIndexOffset(0), o._spiderLeg && (i.removeLayer(o._spiderLeg), delete o._spiderLeg);
        n.fire("unspiderfied", {
          cluster: this,
          markers: r
        }), n._ignoreMove = !1, n._spiderfied = null;
      }
    }), L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
      _animationSpiderfy: function(n, i) {
        var s = this._group, r = s._map, o = s._featureGroup, u = this._group.options.spiderLegPolylineOptions, a, f, y, T;
        for (s._ignoreMove = !0, a = 0; a < n.length; a++)
          T = r.layerPointToLatLng(i[a]), f = n[a], y = new L.Polyline([this._latlng, T], u), r.addLayer(y), f._spiderLeg = y, f._preSpiderfyLatlng = f._latlng, f.setLatLng(T), f.setZIndexOffset && f.setZIndexOffset(1e6), o.addLayer(f);
        this.setOpacity(0.3), s._ignoreMove = !1, s.fire("spiderfied", {
          cluster: this,
          markers: n
        });
      },
      _animationUnspiderfy: function() {
        this._noanimationUnspiderfy();
      }
    }), L.MarkerCluster.include({
      _animationSpiderfy: function(n, i) {
        var s = this, r = this._group, o = r._map, u = r._featureGroup, a = this._latlng, f = o.latLngToLayerPoint(a), y = L.Path.SVG, T = L.extend({}, this._group.options.spiderLegPolylineOptions), h = T.opacity, _, g, S, d, b, k;
        for (h === void 0 && (h = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity), y ? (T.opacity = 0, T.className = (T.className || "") + " leaflet-cluster-spider-leg") : T.opacity = h, r._ignoreMove = !0, _ = 0; _ < n.length; _++)
          g = n[_], k = o.layerPointToLatLng(i[_]), S = new L.Polyline([a, k], T), o.addLayer(S), g._spiderLeg = S, y && (d = S._path, b = d.getTotalLength() + 0.1, d.style.strokeDasharray = b, d.style.strokeDashoffset = b), g.setZIndexOffset && g.setZIndexOffset(1e6), g.clusterHide && g.clusterHide(), u.addLayer(g), g._setPos && g._setPos(f);
        for (r._forceLayout(), r._animationStart(), _ = n.length - 1; _ >= 0; _--)
          k = o.layerPointToLatLng(i[_]), g = n[_], g._preSpiderfyLatlng = g._latlng, g.setLatLng(k), g.clusterShow && g.clusterShow(), y && (S = g._spiderLeg, d = S._path, d.style.strokeDashoffset = 0, S.setStyle({ opacity: h }));
        this.setOpacity(0.3), r._ignoreMove = !1, setTimeout(function() {
          r._animationEnd(), r.fire("spiderfied", {
            cluster: s,
            markers: n
          });
        }, 200);
      },
      _animationUnspiderfy: function(n) {
        var i = this, s = this._group, r = s._map, o = s._featureGroup, u = n ? r._latLngToNewLayerPoint(this._latlng, n.zoom, n.center) : r.latLngToLayerPoint(this._latlng), a = this.getAllChildMarkers(null, !0), f = L.Path.SVG, y, T, h, _, g, S;
        for (s._ignoreMove = !0, s._animationStart(), this.setOpacity(1), T = a.length - 1; T >= 0; T--)
          y = a[T], y._preSpiderfyLatlng && (y.closePopup(), y.setLatLng(y._preSpiderfyLatlng), delete y._preSpiderfyLatlng, S = !0, y._setPos && (y._setPos(u), S = !1), y.clusterHide && (y.clusterHide(), S = !1), S && o.removeLayer(y), f && (h = y._spiderLeg, _ = h._path, g = _.getTotalLength() + 0.1, _.style.strokeDashoffset = g, h.setStyle({ opacity: 0 })));
        s._ignoreMove = !1, setTimeout(function() {
          var d = 0;
          for (T = a.length - 1; T >= 0; T--)
            y = a[T], y._spiderLeg && d++;
          for (T = a.length - 1; T >= 0; T--)
            y = a[T], y._spiderLeg && (y.clusterShow && y.clusterShow(), y.setZIndexOffset && y.setZIndexOffset(0), d > 1 && o.removeLayer(y), r.removeLayer(y._spiderLeg), delete y._spiderLeg);
          s._animationEnd(), s.fire("unspiderfied", {
            cluster: i,
            markers: a
          });
        }, 200);
      }
    }), L.MarkerClusterGroup.include({
      //The MarkerCluster currently spiderfied (if any)
      _spiderfied: null,
      unspiderfy: function() {
        this._unspiderfy.apply(this, arguments);
      },
      _spiderfierOnAdd: function() {
        this._map.on("click", this._unspiderfyWrapper, this), this._map.options.zoomAnimation && this._map.on("zoomstart", this._unspiderfyZoomStart, this), this._map.on("zoomend", this._noanimationUnspiderfy, this), L.Browser.touch || this._map.getRenderer(this);
      },
      _spiderfierOnRemove: function() {
        this._map.off("click", this._unspiderfyWrapper, this), this._map.off("zoomstart", this._unspiderfyZoomStart, this), this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._map.off("zoomend", this._noanimationUnspiderfy, this), this._noanimationUnspiderfy();
      },
      //On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)
      //This means we can define the animation they do rather than Markers doing an animation to their actual location
      _unspiderfyZoomStart: function() {
        this._map && this._map.on("zoomanim", this._unspiderfyZoomAnim, this);
      },
      _unspiderfyZoomAnim: function(n) {
        L.DomUtil.hasClass(this._map._mapPane, "leaflet-touching") || (this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._unspiderfy(n));
      },
      _unspiderfyWrapper: function() {
        this._unspiderfy();
      },
      _unspiderfy: function(n) {
        this._spiderfied && this._spiderfied.unspiderfy(n);
      },
      _noanimationUnspiderfy: function() {
        this._spiderfied && this._spiderfied._noanimationUnspiderfy();
      },
      //If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc
      _unspiderfyLayer: function(n) {
        n._spiderLeg && (this._featureGroup.removeLayer(n), n.clusterShow && n.clusterShow(), n.setZIndexOffset && n.setZIndexOffset(0), this._map.removeLayer(n._spiderLeg), delete n._spiderLeg);
      }
    }), L.MarkerClusterGroup.include({
      /**
       * Updates the icon of all clusters which are parents of the given marker(s).
       * In singleMarkerMode, also updates the given marker(s) icon.
       * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|
       * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent
       * clusters need to be updated. If not provided, retrieves all child markers of this.
       * @returns {L.MarkerClusterGroup}
       */
      refreshClusters: function(n) {
        return n ? n instanceof L.MarkerClusterGroup ? n = n._topClusterLevel.getAllChildMarkers() : n instanceof L.LayerGroup ? n = n._layers : n instanceof L.MarkerCluster ? n = n.getAllChildMarkers() : n instanceof L.Marker && (n = [n]) : n = this._topClusterLevel.getAllChildMarkers(), this._flagParentsIconsNeedUpdate(n), this._refreshClustersIcons(), this.options.singleMarkerMode && this._refreshSingleMarkerModeMarkers(n), this;
      },
      /**
       * Simply flags all parent clusters of the given markers as having a "dirty" icon.
       * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
       * @private
       */
      _flagParentsIconsNeedUpdate: function(n) {
        var i, s;
        for (i in n)
          for (s = n[i].__parent; s; )
            s._iconNeedsUpdate = !0, s = s.__parent;
      },
      /**
       * Re-draws the icon of the supplied markers.
       * To be used in singleMarkerMode only.
       * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
       * @private
       */
      _refreshSingleMarkerModeMarkers: function(n) {
        var i, s;
        for (i in n)
          s = n[i], this.hasLayer(s) && s.setIcon(this._overrideMarkerIcon(s));
      }
    }), L.Marker.include({
      /**
       * Updates the given options in the marker's icon and refreshes the marker.
       * @param options map object of icon options.
       * @param directlyRefreshClusters boolean (optional) true to trigger
       * MCG.refreshClustersOf() right away with this single marker.
       * @returns {L.Marker}
       */
      refreshIconOptions: function(n, i) {
        var s = this.options.icon;
        return L.setOptions(s, n), this.setIcon(s), i && this.__parent && this.__parent._group.refreshClusters(this), this;
      }
    }), c.MarkerClusterGroup = p, c.MarkerCluster = v, Object.defineProperty(c, "__esModule", { value: !0 });
  });
})(leaflet_markerclusterSrc, leaflet_markerclusterSrcExports);
const name = "@plantquest/assetmap", version = "3.1.2", description = "PlantQuest Asset Map", author = "plantquest", license = "MIT", repository = "plantquest/plantquest-assetmap", main = "dist/pqam.umd.js", module = "dist/pqam.mjs", types = "plantquest-assetmap.d.ts", source = "src/pqam.js", scripts = {
  dev: "vite",
  build: "vite build",
  watch: "vite build -w",
  preview: "vite preview",
  clean: "rm -rf node_modules yarn.lock package-lock.json",
  reset: "npm run clean && npm install",
  "repo-tag": "REPO_VERSION=`node -e \"console.log(require('./package').version)\"` && echo TAG: v$REPO_VERSION && git commit -a -m v$REPO_VERSION && git push && git tag v$REPO_VERSION && git push --tags",
  "repo-publish": "npm run clean && npm i && npm run repo-publish-quick",
  "repo-publish-quick": "npm run build && npm run repo-tag && npm publish --access public --registry https://registry.npmjs.org "
}, devDependencies = {
  vite: "^4.3.0-beta.2",
  leaflet: "1.8.0",
  "leaflet-rastercoords": "1.0.5",
  "leaflet.markercluster": "1.5.3",
  "seneca-browser": "4.0.1",
  "seneca-entity": "21.1.0",
  "seneca-mem-store": "8.0.1"
}, files = [
  "LICENSE",
  "README.md",
  "dist"
], Pkg = {
  name,
  version,
  description,
  author,
  license,
  repository,
  main,
  module,
  types,
  source,
  scripts,
  devDependencies,
  files
};
function commonjsRequire(x) {
  throw new Error('Could not dynamically require "' + x + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var senecaBrowserExports = {}, senecaBrowser = {
  get exports() {
    return senecaBrowserExports;
  },
  set exports(x) {
    senecaBrowserExports = x;
  }
};
(function(module, exports) {
  (function(x) {
    module.exports = x();
  })(function() {
    var define;
    return function() {
      function x(C, c, p) {
        function v(s, r) {
          if (!c[s]) {
            if (!C[s]) {
              var o = typeof commonjsRequire == "function" && commonjsRequire;
              if (!r && o)
                return o(s, !0);
              if (n)
                return n(s, !0);
              var u = new Error("Cannot find module '" + s + "'");
              throw u.code = "MODULE_NOT_FOUND", u;
            }
            var a = c[s] = { exports: {} };
            C[s][0].call(a.exports, function(f) {
              var y = C[s][1][f];
              return v(y || f);
            }, a, a.exports, x, C, c, p);
          }
          return c[s].exports;
        }
        for (var n = typeof commonjsRequire == "function" && commonjsRequire, i = 0; i < p.length; i++)
          v(p[i]);
        return v;
      }
      return x;
    }()({ 1: [function(x, C, c) {
      const p = x("@hapi/hoek"), v = { codes: /* @__PURE__ */ new Map([[100, "Continue"], [101, "Switching Protocols"], [102, "Processing"], [200, "OK"], [201, "Created"], [202, "Accepted"], [203, "Non-Authoritative Information"], [204, "No Content"], [205, "Reset Content"], [206, "Partial Content"], [207, "Multi-Status"], [300, "Multiple Choices"], [301, "Moved Permanently"], [302, "Moved Temporarily"], [303, "See Other"], [304, "Not Modified"], [305, "Use Proxy"], [307, "Temporary Redirect"], [400, "Bad Request"], [401, "Unauthorized"], [402, "Payment Required"], [403, "Forbidden"], [404, "Not Found"], [405, "Method Not Allowed"], [406, "Not Acceptable"], [407, "Proxy Authentication Required"], [408, "Request Time-out"], [409, "Conflict"], [410, "Gone"], [411, "Length Required"], [412, "Precondition Failed"], [413, "Request Entity Too Large"], [414, "Request-URI Too Large"], [415, "Unsupported Media Type"], [416, "Requested Range Not Satisfiable"], [417, "Expectation Failed"], [418, "I'm a teapot"], [422, "Unprocessable Entity"], [423, "Locked"], [424, "Failed Dependency"], [425, "Too Early"], [426, "Upgrade Required"], [428, "Precondition Required"], [429, "Too Many Requests"], [431, "Request Header Fields Too Large"], [451, "Unavailable For Legal Reasons"], [500, "Internal Server Error"], [501, "Not Implemented"], [502, "Bad Gateway"], [503, "Service Unavailable"], [504, "Gateway Time-out"], [505, "HTTP Version Not Supported"], [506, "Variant Also Negotiates"], [507, "Insufficient Storage"], [509, "Bandwidth Limit Exceeded"], [510, "Not Extended"], [511, "Network Authentication Required"]]) };
      c.Boom = class extends Error {
        constructor(n, i = {}) {
          if (n instanceof Error)
            return c.boomify(p.clone(n), i);
          const { statusCode: s = 500, data: r = null, ctor: o = c.Boom } = i, u = new Error(n || void 0);
          Error.captureStackTrace(u, o), u.data = r;
          const a = v.initialize(u, s);
          return Object.defineProperty(a, "typeof", { value: o }), i.decorate && Object.assign(a, i.decorate), a;
        }
        static [Symbol.hasInstance](n) {
          return this === c.Boom ? c.isBoom(n) : this.prototype.isPrototypeOf(n);
        }
      }, c.isBoom = function(n, i) {
        return n instanceof Error && !!n.isBoom && (!i || n.output.statusCode === i);
      }, c.boomify = function(n, i) {
        return p.assert(n instanceof Error, "Cannot wrap non-Error object"), (i = i || {}).data !== void 0 && (n.data = i.data), i.decorate && Object.assign(n, i.decorate), n.isBoom ? i.override === !1 || !i.statusCode && !i.message ? n : v.initialize(n, i.statusCode || n.output.statusCode, i.message) : v.initialize(n, i.statusCode || 500, i.message);
      }, c.badRequest = function(n, i) {
        return new c.Boom(n, { statusCode: 400, data: i, ctor: c.badRequest });
      }, c.unauthorized = function(n, i, s) {
        const r = new c.Boom(n, { statusCode: 401, ctor: c.unauthorized });
        if (!i)
          return r;
        if (typeof i != "string")
          return r.output.headers["WWW-Authenticate"] = i.join(", "), r;
        let o = `${i}`;
        return (s || n) && (r.output.payload.attributes = {}), s && (typeof s == "string" ? (o += " " + p.escapeHeaderAttribute(s), r.output.payload.attributes = s) : o += " " + Object.keys(s).map((u) => {
          let a = s[u];
          return a == null && (a = ""), r.output.payload.attributes[u] = a, `${u}="${p.escapeHeaderAttribute(a.toString())}"`;
        }).join(", ")), n ? (s && (o += ","), o += ` error="${p.escapeHeaderAttribute(n)}"`, r.output.payload.attributes.error = n) : r.isMissing = !0, r.output.headers["WWW-Authenticate"] = o, r;
      }, c.paymentRequired = function(n, i) {
        return new c.Boom(n, { statusCode: 402, data: i, ctor: c.paymentRequired });
      }, c.forbidden = function(n, i) {
        return new c.Boom(n, { statusCode: 403, data: i, ctor: c.forbidden });
      }, c.notFound = function(n, i) {
        return new c.Boom(n, { statusCode: 404, data: i, ctor: c.notFound });
      }, c.methodNotAllowed = function(n, i, s) {
        const r = new c.Boom(n, { statusCode: 405, data: i, ctor: c.methodNotAllowed });
        return typeof s == "string" && (s = [s]), Array.isArray(s) && (r.output.headers.Allow = s.join(", ")), r;
      }, c.notAcceptable = function(n, i) {
        return new c.Boom(n, { statusCode: 406, data: i, ctor: c.notAcceptable });
      }, c.proxyAuthRequired = function(n, i) {
        return new c.Boom(n, { statusCode: 407, data: i, ctor: c.proxyAuthRequired });
      }, c.clientTimeout = function(n, i) {
        return new c.Boom(n, { statusCode: 408, data: i, ctor: c.clientTimeout });
      }, c.conflict = function(n, i) {
        return new c.Boom(n, { statusCode: 409, data: i, ctor: c.conflict });
      }, c.resourceGone = function(n, i) {
        return new c.Boom(n, { statusCode: 410, data: i, ctor: c.resourceGone });
      }, c.lengthRequired = function(n, i) {
        return new c.Boom(n, { statusCode: 411, data: i, ctor: c.lengthRequired });
      }, c.preconditionFailed = function(n, i) {
        return new c.Boom(n, { statusCode: 412, data: i, ctor: c.preconditionFailed });
      }, c.entityTooLarge = function(n, i) {
        return new c.Boom(n, { statusCode: 413, data: i, ctor: c.entityTooLarge });
      }, c.uriTooLong = function(n, i) {
        return new c.Boom(n, { statusCode: 414, data: i, ctor: c.uriTooLong });
      }, c.unsupportedMediaType = function(n, i) {
        return new c.Boom(n, { statusCode: 415, data: i, ctor: c.unsupportedMediaType });
      }, c.rangeNotSatisfiable = function(n, i) {
        return new c.Boom(n, { statusCode: 416, data: i, ctor: c.rangeNotSatisfiable });
      }, c.expectationFailed = function(n, i) {
        return new c.Boom(n, { statusCode: 417, data: i, ctor: c.expectationFailed });
      }, c.teapot = function(n, i) {
        return new c.Boom(n, { statusCode: 418, data: i, ctor: c.teapot });
      }, c.badData = function(n, i) {
        return new c.Boom(n, { statusCode: 422, data: i, ctor: c.badData });
      }, c.locked = function(n, i) {
        return new c.Boom(n, { statusCode: 423, data: i, ctor: c.locked });
      }, c.failedDependency = function(n, i) {
        return new c.Boom(n, { statusCode: 424, data: i, ctor: c.failedDependency });
      }, c.tooEarly = function(n, i) {
        return new c.Boom(n, { statusCode: 425, data: i, ctor: c.tooEarly });
      }, c.preconditionRequired = function(n, i) {
        return new c.Boom(n, { statusCode: 428, data: i, ctor: c.preconditionRequired });
      }, c.tooManyRequests = function(n, i) {
        return new c.Boom(n, { statusCode: 429, data: i, ctor: c.tooManyRequests });
      }, c.illegal = function(n, i) {
        return new c.Boom(n, { statusCode: 451, data: i, ctor: c.illegal });
      }, c.internal = function(n, i, s = 500) {
        return v.serverError(n, i, s, c.internal);
      }, c.notImplemented = function(n, i) {
        return v.serverError(n, i, 501, c.notImplemented);
      }, c.badGateway = function(n, i) {
        return v.serverError(n, i, 502, c.badGateway);
      }, c.serverUnavailable = function(n, i) {
        return v.serverError(n, i, 503, c.serverUnavailable);
      }, c.gatewayTimeout = function(n, i) {
        return v.serverError(n, i, 504, c.gatewayTimeout);
      }, c.badImplementation = function(n, i) {
        const s = v.serverError(n, i, 500, c.badImplementation);
        return s.isDeveloperError = !0, s;
      }, v.initialize = function(n, i, s) {
        const r = parseInt(i, 10);
        if (p.assert(!isNaN(r) && r >= 400, "First argument must be a number (400+):", i), n.isBoom = !0, n.isServer = r >= 500, n.hasOwnProperty("data") || (n.data = null), n.output = { statusCode: r, payload: {}, headers: {} }, Object.defineProperty(n, "reformat", { value: v.reformat, configurable: !0 }), s || n.message || (n.reformat(), s = n.output.payload.error), s) {
          const o = Object.getOwnPropertyDescriptor(n, "message") || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(n), "message");
          p.assert(!o || o.configurable && !o.get, "The error is not compatible with boom"), n.message = s + (n.message ? ": " + n.message : ""), n.output.payload.message = n.message;
        }
        return n.reformat(), n;
      }, v.reformat = function(n = !1) {
        this.output.payload.statusCode = this.output.statusCode, this.output.payload.error = v.codes.get(this.output.statusCode) || "Unknown", this.output.statusCode === 500 && n !== !0 ? this.output.payload.message = "An internal server error occurred" : this.message && (this.output.payload.message = this.message);
      }, v.serverError = function(n, i, s, r) {
        return i instanceof Error && !i.isBoom ? c.boomify(i, { statusCode: s, message: n }) : new c.Boom(n, { statusCode: s, data: i, ctor: r });
      };
    }, { "@hapi/hoek": 17 }], 2: [function(x, C, c) {
      const p = { suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/ };
      c.parse = function(v, ...n) {
        const i = typeof n[0] == "object" && n[0], s = n.length > 1 || !i ? n[0] : void 0, r = n.length > 1 && n[1] || i || {}, o = JSON.parse(v, s);
        return r.protoAction === "ignore" || o && typeof o == "object" && v.match(p.suspectRx) && c.scan(o, r), o;
      }, c.scan = function(v, n = {}) {
        let i = [v];
        for (; i.length; ) {
          const s = i;
          i = [];
          for (const r of s) {
            if (Object.prototype.hasOwnProperty.call(r, "__proto__")) {
              if (n.protoAction !== "remove")
                throw new SyntaxError("Object contains forbidden prototype property");
              delete r.__proto__;
            }
            for (const o in r) {
              const u = r[o];
              u && typeof u == "object" && i.push(r[o]);
            }
          }
        }
      }, c.safeParse = function(v, n) {
        try {
          return c.parse(v, n);
        } catch (i) {
          return null;
        }
      };
    }, {}], 3: [function(x, C, c) {
      const p = x("./assert"), v = x("./clone"), n = x("./merge"), i = x("./reach"), s = {};
      C.exports = function(r, o, u = {}) {
        if (p(r && typeof r == "object", "Invalid defaults value: must be an object"), p(!o || o === !0 || typeof o == "object", "Invalid source value: must be true, falsy or an object"), p(typeof u == "object", "Invalid options: must be an object"), !o)
          return null;
        if (u.shallow)
          return s.applyToDefaultsWithShallow(r, o, u);
        const a = v(r);
        if (o === !0)
          return a;
        const f = u.nullOverride !== void 0 && u.nullOverride;
        return n(a, o, { nullOverride: f, mergeArrays: !1 });
      }, s.applyToDefaultsWithShallow = function(r, o, u) {
        const a = u.shallow;
        p(Array.isArray(a), "Invalid keys");
        const f = /* @__PURE__ */ new Map(), y = o === !0 ? null : /* @__PURE__ */ new Set();
        for (let _ of a) {
          _ = Array.isArray(_) ? _ : _.split(".");
          const g = i(r, _);
          g && typeof g == "object" ? f.set(g, y && i(o, _) || g) : y && y.add(_);
        }
        const T = v(r, {}, f);
        if (!y)
          return T;
        for (const _ of y)
          s.reachCopy(T, o, _);
        const h = u.nullOverride !== void 0 && u.nullOverride;
        return n(T, o, { nullOverride: h, mergeArrays: !1 });
      }, s.reachCopy = function(r, o, u) {
        for (const y of u) {
          if (!(y in o))
            return;
          const T = o[y];
          if (typeof T != "object" || T === null)
            return;
          o = T;
        }
        const a = o;
        let f = r;
        for (let y = 0; y < u.length - 1; ++y) {
          const T = u[y];
          typeof f[T] != "object" && (f[T] = {}), f = f[T];
        }
        f[u[u.length - 1]] = a;
      };
    }, { "./assert": 4, "./clone": 7, "./merge": 20, "./reach": 22 }], 4: [function(x, C, c) {
      const p = x("./error");
      C.exports = function(v, ...n) {
        if (!v)
          throw n.length === 1 && n[0] instanceof Error ? n[0] : new p(n);
      };
    }, { "./error": 10 }], 5: [function(x, C, c) {
      (function(p) {
        (function() {
          const v = {};
          C.exports = v.Bench = class {
            constructor() {
              this.ts = 0, this.reset();
            }
            reset() {
              this.ts = v.Bench.now();
            }
            elapsed() {
              return v.Bench.now() - this.ts;
            }
            static now() {
              const n = p.hrtime();
              return 1e3 * n[0] + n[1] / 1e6;
            }
          };
        }).call(this);
      }).call(this, x("_process"));
    }, { _process: 158 }], 6: [function(x, C, c) {
      const p = x("./ignore");
      C.exports = function() {
        return new Promise(p);
      };
    }, { "./ignore": 16 }], 7: [function(x, C, c) {
      (function(p) {
        (function() {
          const v = x("./reach"), n = x("./types"), i = x("./utils"), s = { needsProtoHack: /* @__PURE__ */ new Set([n.set, n.map, n.weakSet, n.weakMap]) };
          C.exports = s.clone = function(r, o = {}, u = null) {
            if (typeof r != "object" || r === null)
              return r;
            let a = s.clone, f = u;
            if (o.shallow) {
              if (o.shallow !== !0)
                return s.cloneWithShallow(r, o);
              a = (_) => _;
            } else if (f) {
              const _ = f.get(r);
              if (_)
                return _;
            } else
              f = /* @__PURE__ */ new Map();
            const y = n.getInternalProto(r);
            if (y === n.buffer)
              return p && p.from(r);
            if (y === n.date)
              return new Date(r.getTime());
            if (y === n.regex)
              return new RegExp(r);
            const T = s.base(r, y, o);
            if (T === r)
              return r;
            if (f && f.set(r, T), y === n.set)
              for (const _ of r)
                T.add(a(_, o, f));
            else if (y === n.map)
              for (const [_, g] of r)
                T.set(_, a(g, o, f));
            const h = i.keys(r, o);
            for (const _ of h) {
              if (_ === "__proto__")
                continue;
              if (y === n.array && _ === "length") {
                T.length = r.length;
                continue;
              }
              const g = Object.getOwnPropertyDescriptor(r, _);
              g ? g.get || g.set ? Object.defineProperty(T, _, g) : g.enumerable ? T[_] = a(r[_], o, f) : Object.defineProperty(T, _, { enumerable: !1, writable: !0, configurable: !0, value: a(r[_], o, f) }) : Object.defineProperty(T, _, { enumerable: !0, writable: !0, configurable: !0, value: a(r[_], o, f) });
            }
            return T;
          }, s.cloneWithShallow = function(r, o) {
            const u = o.shallow;
            (o = Object.assign({}, o)).shallow = !1;
            const a = /* @__PURE__ */ new Map();
            for (const f of u) {
              const y = v(r, f);
              typeof y != "object" && typeof y != "function" || a.set(y, y);
            }
            return s.clone(r, o, a);
          }, s.base = function(r, o, u) {
            if (u.prototype === !1)
              return s.needsProtoHack.has(o) ? new o.constructor() : o === n.array ? [] : {};
            const a = Object.getPrototypeOf(r);
            if (a && a.isImmutable)
              return r;
            if (o === n.array) {
              const f = [];
              return a !== o && Object.setPrototypeOf(f, a), f;
            }
            if (s.needsProtoHack.has(o)) {
              const f = new a.constructor();
              return a !== o && Object.setPrototypeOf(f, a), f;
            }
            return Object.create(a);
          };
        }).call(this);
      }).call(this, x("buffer").Buffer);
    }, { "./reach": 22, "./types": 25, "./utils": 26, buffer: 46 }], 8: [function(x, C, c) {
      const p = x("./assert"), v = x("./deepEqual"), n = x("./escapeRegex"), i = x("./utils"), s = {};
      C.exports = function(r, o, u = {}) {
        return typeof o != "object" && (o = [o]), p(!Array.isArray(o) || o.length, "Values array cannot be empty"), typeof r == "string" ? s.string(r, o, u) : Array.isArray(r) ? s.array(r, o, u) : (p(typeof r == "object", "Reference must be string or an object"), s.object(r, o, u));
      }, s.array = function(r, o, u) {
        if (Array.isArray(o) || (o = [o]), !r.length || u.only && u.once && r.length !== o.length)
          return !1;
        let a;
        const f = /* @__PURE__ */ new Map();
        for (const T of o)
          if (u.deep && T && typeof T == "object") {
            a = a || s.compare(u);
            let h = !1;
            for (const [_, g] of f.entries())
              if (a(_, T)) {
                ++g.allowed, h = !0;
                break;
              }
            h || f.set(T, { allowed: 1, hits: 0 });
          } else {
            const h = f.get(T);
            h ? ++h.allowed : f.set(T, { allowed: 1, hits: 0 });
          }
        let y = 0;
        for (const T of r) {
          let h;
          if (u.deep && T && typeof T == "object") {
            a = a || s.compare(u);
            for (const [_, g] of f.entries())
              if (a(_, T)) {
                h = g;
                break;
              }
          } else
            h = f.get(T);
          if (h && (++h.hits, ++y, u.once && h.hits > h.allowed))
            return !1;
        }
        if (u.only && y !== r.length)
          return !1;
        for (const T of f.values())
          if (T.hits !== T.allowed && T.hits < T.allowed && !u.part)
            return !1;
        return !!y;
      }, s.object = function(r, o, u) {
        p(u.once === void 0, "Cannot use option once with object");
        const a = i.keys(r, u);
        if (!a.length)
          return !1;
        if (Array.isArray(o))
          return s.array(a, o, u);
        const f = Object.getOwnPropertySymbols(o).filter((_) => o.propertyIsEnumerable(_)), y = [...Object.keys(o), ...f], T = s.compare(u), h = new Set(y);
        for (const _ of a)
          if (h.has(_)) {
            if (!T(o[_], r[_]))
              return !1;
            h.delete(_);
          } else if (u.only)
            return !1;
        return !h.size || !!u.part && h.size < y.length;
      }, s.string = function(r, o, u) {
        if (r === "")
          return o.length === 1 && o[0] === "" || !u.once && !o.some((_) => _ !== "");
        const a = /* @__PURE__ */ new Map(), f = [];
        for (const _ of o)
          if (p(typeof _ == "string", "Cannot compare string reference to non-string value"), _) {
            const g = a.get(_);
            g ? ++g.allowed : (a.set(_, { allowed: 1, hits: 0 }), f.push(n(_)));
          } else if (u.once || u.only)
            return !1;
        if (!f.length)
          return !0;
        const y = new RegExp(`(${f.join("|")})`, "g"), T = r.replace(y, (_, g) => (++a.get(g).hits, ""));
        if (u.only && T)
          return !1;
        let h = !1;
        for (const _ of a.values())
          if (_.hits && (h = !0), _.hits !== _.allowed && (_.hits < _.allowed && !u.part || u.once))
            return !1;
        return !!h;
      }, s.compare = function(r) {
        if (!r.deep)
          return s.shallow;
        const o = r.only !== void 0, u = r.part !== void 0, a = { prototype: o ? r.only : !!u && !r.part, part: o ? !r.only : !!u && r.part };
        return (f, y) => v(f, y, a);
      }, s.shallow = function(r, o) {
        return r === o;
      };
    }, { "./assert": 4, "./deepEqual": 9, "./escapeRegex": 14, "./utils": 26 }], 9: [function(x, C, c) {
      (function(p) {
        (function() {
          const v = x("./types"), n = { mismatched: null };
          C.exports = function(i, s, r) {
            return r = Object.assign({ prototype: !0 }, r), !!n.isDeepEqual(i, s, r, []);
          }, n.isDeepEqual = function(i, s, r, o) {
            if (i === s)
              return i !== 0 || 1 / i == 1 / s;
            const u = typeof i;
            if (u !== typeof s || i === null || s === null)
              return !1;
            if (u === "function") {
              if (!r.deepFunction || i.toString() !== s.toString())
                return !1;
            } else if (u !== "object")
              return i != i && s != s;
            const a = n.getSharedType(i, s, !!r.prototype);
            switch (a) {
              case v.buffer:
                return p && p.prototype.equals.call(i, s);
              case v.promise:
                return i === s;
              case v.regex:
                return i.toString() === s.toString();
              case n.mismatched:
                return !1;
            }
            for (let f = o.length - 1; f >= 0; --f)
              if (o[f].isSame(i, s))
                return !0;
            o.push(new n.SeenEntry(i, s));
            try {
              return !!n.isDeepEqualObj(a, i, s, r, o);
            } finally {
              o.pop();
            }
          }, n.getSharedType = function(i, s, r) {
            if (r)
              return Object.getPrototypeOf(i) !== Object.getPrototypeOf(s) ? n.mismatched : v.getInternalProto(i);
            const o = v.getInternalProto(i);
            return o !== v.getInternalProto(s) ? n.mismatched : o;
          }, n.valueOf = function(i) {
            const s = i.valueOf;
            if (s === void 0)
              return i;
            try {
              return s.call(i);
            } catch (r) {
              return r;
            }
          }, n.hasOwnEnumerableProperty = function(i, s) {
            return Object.prototype.propertyIsEnumerable.call(i, s);
          }, n.isSetSimpleEqual = function(i, s) {
            for (const r of Set.prototype.values.call(i))
              if (!Set.prototype.has.call(s, r))
                return !1;
            return !0;
          }, n.isDeepEqualObj = function(i, s, r, o, u) {
            const { isDeepEqual: a, valueOf: f, hasOwnEnumerableProperty: y } = n, { keys: T, getOwnPropertySymbols: h } = Object;
            if (i === v.array) {
              if (!o.part) {
                if (s.length !== r.length)
                  return !1;
                for (let b = 0; b < s.length; ++b)
                  if (!a(s[b], r[b], o, u))
                    return !1;
                return !0;
              }
              for (const b of s)
                for (const k of r)
                  if (a(b, k, o, u))
                    return !0;
            } else if (i === v.set) {
              if (s.size !== r.size)
                return !1;
              if (!n.isSetSimpleEqual(s, r)) {
                const b = new Set(Set.prototype.values.call(r));
                for (const k of Set.prototype.values.call(s)) {
                  if (b.delete(k))
                    continue;
                  let O = !1;
                  for (const A of b)
                    if (a(k, A, o, u)) {
                      b.delete(A), O = !0;
                      break;
                    }
                  if (!O)
                    return !1;
                }
              }
            } else if (i === v.map) {
              if (s.size !== r.size)
                return !1;
              for (const [b, k] of Map.prototype.entries.call(s))
                if (k === void 0 && !Map.prototype.has.call(r, b) || !a(k, Map.prototype.get.call(r, b), o, u))
                  return !1;
            } else if (i === v.error && (s.name !== r.name || s.message !== r.message))
              return !1;
            const _ = f(s), g = f(r);
            if ((s !== _ || r !== g) && !a(_, g, o, u))
              return !1;
            const S = T(s);
            if (!o.part && S.length !== T(r).length && !o.skip)
              return !1;
            let d = 0;
            for (const b of S)
              if (o.skip && o.skip.includes(b))
                r[b] === void 0 && ++d;
              else if (!y(r, b) || !a(s[b], r[b], o, u))
                return !1;
            if (!o.part && S.length - d !== T(r).length)
              return !1;
            if (o.symbols !== !1) {
              const b = h(s), k = new Set(h(r));
              for (const O of b) {
                if (!o.skip || !o.skip.includes(O)) {
                  if (y(s, O)) {
                    if (!y(r, O) || !a(s[O], r[O], o, u))
                      return !1;
                  } else if (y(r, O))
                    return !1;
                }
                k.delete(O);
              }
              for (const O of k)
                if (y(r, O))
                  return !1;
            }
            return !0;
          }, n.SeenEntry = class {
            constructor(i, s) {
              this.obj = i, this.ref = s;
            }
            isSame(i, s) {
              return this.obj === i && this.ref === s;
            }
          };
        }).call(this);
      }).call(this, x("buffer").Buffer);
    }, { "./types": 25, buffer: 46 }], 10: [function(x, C, c) {
      const p = x("./stringify");
      C.exports = class extends Error {
        constructor(v) {
          super(v.filter((n) => n !== "").map((n) => typeof n == "string" ? n : n instanceof Error ? n.message : p(n)).join(" ") || "Unknown error"), typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, c.assert);
        }
      };
    }, { "./stringify": 24 }], 11: [function(x, C, c) {
      const p = x("./assert");
      C.exports = function(v) {
        return p(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(v), "Bad attribute value (" + v + ")"), v.replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
      };
    }, { "./assert": 4 }], 12: [function(x, C, c) {
      const p = {};
      C.exports = function(v) {
        if (!v)
          return "";
        let n = "";
        for (let i = 0; i < v.length; ++i) {
          const s = v.charCodeAt(i);
          p.isSafe(s) ? n += v[i] : n += p.escapeHtmlChar(s);
        }
        return n;
      }, p.escapeHtmlChar = function(v) {
        return p.namedHtml.get(v) || (v >= 256 ? "&#" + v + ";" : `&#x${v.toString(16).padStart(2, "0")};`);
      }, p.isSafe = function(v) {
        return p.safeCharCodes.has(v);
      }, p.namedHtml = /* @__PURE__ */ new Map([[38, "&amp;"], [60, "&lt;"], [62, "&gt;"], [34, "&quot;"], [160, "&nbsp;"], [162, "&cent;"], [163, "&pound;"], [164, "&curren;"], [169, "&copy;"], [174, "&reg;"]]), p.safeCharCodes = function() {
        const v = /* @__PURE__ */ new Set();
        for (let n = 32; n < 123; ++n)
          (n >= 97 || n >= 65 && n <= 90 || n >= 48 && n <= 57 || n === 32 || n === 46 || n === 44 || n === 45 || n === 58 || n === 95) && v.add(n);
        return v;
      }();
    }, {}], 13: [function(x, C, c) {
      const p = {};
      C.exports = function(v) {
        return v ? v.replace(/[<>&\u2028\u2029]/g, p.escape) : "";
      }, p.escape = function(v) {
        return p.replacements.get(v);
      }, p.replacements = /* @__PURE__ */ new Map([["<", "\\u003c"], [">", "\\u003e"], ["&", "\\u0026"], ["\u2028", "\\u2028"], ["\u2029", "\\u2029"]]);
    }, {}], 14: [function(x, C, c) {
      C.exports = function(p) {
        return p.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
      };
    }, {}], 15: [function(x, C, c) {
      const p = {};
      C.exports = p.flatten = function(v, n) {
        const i = n || [];
        for (const s of v)
          Array.isArray(s) ? p.flatten(s, i) : i.push(s);
        return i;
      };
    }, {}], 16: [function(x, C, c) {
      C.exports = function() {
      };
    }, {}], 17: [function(x, C, c) {
      c.applyToDefaults = x("./applyToDefaults"), c.assert = x("./assert"), c.Bench = x("./bench"), c.block = x("./block"), c.clone = x("./clone"), c.contain = x("./contain"), c.deepEqual = x("./deepEqual"), c.Error = x("./error"), c.escapeHeaderAttribute = x("./escapeHeaderAttribute"), c.escapeHtml = x("./escapeHtml"), c.escapeJson = x("./escapeJson"), c.escapeRegex = x("./escapeRegex"), c.flatten = x("./flatten"), c.ignore = x("./ignore"), c.intersect = x("./intersect"), c.isPromise = x("./isPromise"), c.merge = x("./merge"), c.once = x("./once"), c.reach = x("./reach"), c.reachTemplate = x("./reachTemplate"), c.stringify = x("./stringify"), c.wait = x("./wait");
    }, { "./applyToDefaults": 3, "./assert": 4, "./bench": 5, "./block": 6, "./clone": 7, "./contain": 8, "./deepEqual": 9, "./error": 10, "./escapeHeaderAttribute": 11, "./escapeHtml": 12, "./escapeJson": 13, "./escapeRegex": 14, "./flatten": 15, "./ignore": 16, "./intersect": 18, "./isPromise": 19, "./merge": 20, "./once": 21, "./reach": 22, "./reachTemplate": 23, "./stringify": 24, "./wait": 27 }], 18: [function(x, C, c) {
      const p = {};
      C.exports = function(v, n, i = {}) {
        if (!v || !n)
          return i.first ? null : [];
        const s = [], r = Array.isArray(v) ? new Set(v) : v, o = /* @__PURE__ */ new Set();
        for (const u of n)
          if (p.has(r, u) && !o.has(u)) {
            if (i.first)
              return u;
            s.push(u), o.add(u);
          }
        return i.first ? null : s;
      }, p.has = function(v, n) {
        return typeof v.has == "function" ? v.has(n) : v[n] !== void 0;
      };
    }, {}], 19: [function(x, C, c) {
      C.exports = function(p) {
        return !!p && typeof p.then == "function";
      };
    }, {}], 20: [function(x, C, c) {
      (function(p) {
        (function() {
          const v = x("./assert"), n = x("./clone"), i = x("./utils"), s = {};
          C.exports = s.merge = function(r, o, u) {
            if (v(r && typeof r == "object", "Invalid target value: must be an object"), v(o == null || typeof o == "object", "Invalid source value: must be null, undefined, or an object"), !o)
              return r;
            if (u = Object.assign({ nullOverride: !0, mergeArrays: !0 }, u), Array.isArray(o)) {
              v(Array.isArray(r), "Cannot merge array onto an object"), u.mergeArrays || (r.length = 0);
              for (let f = 0; f < o.length; ++f)
                r.push(n(o[f], { symbols: u.symbols }));
              return r;
            }
            const a = i.keys(o, u);
            for (let f = 0; f < a.length; ++f) {
              const y = a[f];
              if (y === "__proto__" || !Object.prototype.propertyIsEnumerable.call(o, y))
                continue;
              const T = o[y];
              if (T && typeof T == "object") {
                if (r[y] === T)
                  continue;
                !r[y] || typeof r[y] != "object" || Array.isArray(r[y]) !== Array.isArray(T) || T instanceof Date || p && p.isBuffer(T) || T instanceof RegExp ? r[y] = n(T, { symbols: u.symbols }) : s.merge(r[y], T, u);
              } else
                (T != null || u.nullOverride) && (r[y] = T);
            }
            return r;
          };
        }).call(this);
      }).call(this, x("buffer").Buffer);
    }, { "./assert": 4, "./clone": 7, "./utils": 26, buffer: 46 }], 21: [function(x, C, c) {
      const p = { wrapped: Symbol("wrapped") };
      C.exports = function(v) {
        if (v[p.wrapped])
          return v;
        let n = !1;
        const i = function(...s) {
          n || (n = !0, v(...s));
        };
        return i[p.wrapped] = !0, i;
      };
    }, {}], 22: [function(x, C, c) {
      const p = x("./assert"), v = {};
      C.exports = function(n, i, s) {
        if (i === !1 || i == null)
          return n;
        typeof (s = s || {}) == "string" && (s = { separator: s });
        const r = Array.isArray(i);
        p(!r || !s.separator, "Separator option is not valid for array-based chain");
        const o = r ? i : i.split(s.separator || ".");
        let u = n;
        for (let a = 0; a < o.length; ++a) {
          let f = o[a];
          const y = s.iterables && v.iterables(u);
          if (Array.isArray(u) || y === "set") {
            const T = Number(f);
            Number.isInteger(T) && (f = T < 0 ? u.length + T : T);
          }
          if (!u || typeof u == "function" && s.functions === !1 || !y && u[f] === void 0) {
            p(!s.strict || a + 1 === o.length, "Missing segment", f, "in reach path ", i), p(typeof u == "object" || s.functions === !0 || typeof u != "function", "Invalid segment", f, "in reach path ", i), u = s.default;
            break;
          }
          u = y ? y === "set" ? [...u][f] : u.get(f) : u[f];
        }
        return u;
      }, v.iterables = function(n) {
        return n instanceof Set ? "set" : n instanceof Map ? "map" : void 0;
      };
    }, { "./assert": 4 }], 23: [function(x, C, c) {
      const p = x("./reach");
      C.exports = function(v, n, i) {
        return n.replace(/{([^{}]+)}/g, (s, r) => {
          const o = p(v, r, i);
          return o == null ? "" : o;
        });
      };
    }, { "./reach": 22 }], 24: [function(x, C, c) {
      C.exports = function(...p) {
        try {
          return JSON.stringify(...p);
        } catch (v) {
          return "[Cannot display object: " + v.message + "]";
        }
      };
    }, {}], 25: [function(x, C, c) {
      (function(p) {
        (function() {
          const v = {};
          c = C.exports = { array: Array.prototype, buffer: p && p.prototype, date: Date.prototype, error: Error.prototype, generic: Object.prototype, map: Map.prototype, promise: Promise.prototype, regex: RegExp.prototype, set: Set.prototype, weakMap: WeakMap.prototype, weakSet: WeakSet.prototype }, v.typeMap = /* @__PURE__ */ new Map([["[object Error]", c.error], ["[object Map]", c.map], ["[object Promise]", c.promise], ["[object Set]", c.set], ["[object WeakMap]", c.weakMap], ["[object WeakSet]", c.weakSet]]), c.getInternalProto = function(n) {
            if (Array.isArray(n))
              return c.array;
            if (p && n instanceof p)
              return c.buffer;
            if (n instanceof Date)
              return c.date;
            if (n instanceof RegExp)
              return c.regex;
            if (n instanceof Error)
              return c.error;
            const i = Object.prototype.toString.call(n);
            return v.typeMap.get(i) || c.generic;
          };
        }).call(this);
      }).call(this, x("buffer").Buffer);
    }, { buffer: 46 }], 26: [function(x, C, c) {
      c.keys = function(p, v = {}) {
        return v.symbols !== !1 ? Reflect.ownKeys(p) : Object.getOwnPropertyNames(p);
      };
    }, {}], 27: [function(x, C, c) {
      const p = { maxTimer: 2147483647 };
      C.exports = function(v, n, i) {
        if (typeof v == "bigint" && (v = Number(v)), v >= Number.MAX_SAFE_INTEGER && (v = 1 / 0), typeof v != "number" && v !== void 0)
          throw new TypeError("Timeout must be a number or bigint");
        return new Promise((s) => {
          const r = i ? i.setTimeout : setTimeout, o = () => {
            const u = Math.min(v, p.maxTimer);
            v -= u, r(() => v > 0 ? o() : s(n), u);
          };
          v !== 1 / 0 && o();
        });
      };
    }, {}], 28: [function(x, C, c) {
      (function(p) {
        (function() {
          const v = x("events"), n = x("http"), i = x("https"), s = x("stream"), r = x("url"), o = x("zlib"), u = x("@hapi/boom"), a = x("@hapi/bourne"), f = x("@hapi/hoek"), y = x("./payload"), T = x("./recorder"), h = x("./tap"), _ = { jsonRegex: /^application\/([a-z0-9.]*[+-]json|json)$/, shallowOptions: ["agent", "agents", "beforeRedirect", "payload", "redirected"], Client: class {
            constructor(g = {}) {
              f.assert(!g.agents || g.agents.https && g.agents.http && g.agents.httpsAllowUnauthorized, 'Option agents must include "http", "https", and "httpsAllowUnauthorized"'), this._defaults = f.clone(g, { shallow: _.shallowOptions }), this.agents = this._defaults.agents || { https: new i.Agent({ maxSockets: 1 / 0 }), http: new n.Agent({ maxSockets: 1 / 0 }), httpsAllowUnauthorized: new i.Agent({ maxSockets: 1 / 0, rejectUnauthorized: !1 }) }, this._defaults.events && (this.events = new v.EventEmitter());
            }
            defaults(g) {
              return f.assert(g && typeof g == "object", "options must be provided to defaults"), g = f.applyToDefaults(this._defaults, g, { shallow: _.shallowOptions }), new _.Client(g);
            }
            request(g, S, d = {}) {
              try {
                d = f.applyToDefaults(this._defaults, d, { shallow: _.shallowOptions }), f.assert(d.payload === void 0 || typeof d.payload == "string" || typeof d.payload == "object", "options.payload must be a string, a Buffer, a Stream, or an Object"), f.assert(_.isNullOrUndefined(d.agent) || typeof d.rejectUnauthorized != "boolean", "options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set"), f.assert(_.isNullOrUndefined(d.beforeRedirect) || typeof d.beforeRedirect == "function", "options.beforeRedirect must be a function"), f.assert(_.isNullOrUndefined(d.redirected) || typeof d.redirected == "function", "options.redirected must be a function"), f.assert(d.gunzip === void 0 || typeof d.gunzip == "boolean" || d.gunzip === "force", 'options.gunzip must be a boolean or "force"');
              } catch (A) {
                return Promise.reject(A);
              }
              d.baseUrl && (S = _.resolveUrl(d.baseUrl, S), delete d.baseUrl);
              const b = {}, k = this._request(g, S, d, b), O = new Promise((A, l) => {
                b.callback = (E, M) => {
                  E ? l(E) : A(M);
                };
              });
              return O.req = k, O;
            }
            _request(g, S, d, b, k) {
              const O = {};
              if (d.socketPath) {
                O.socketPath = d.socketPath;
                const ct = new r.URL(S, `unix://${d.socketPath}`);
                _.applyUrlToOptions(O, { host: "", protocol: "http:", hash: ct.hash, search: ct.search, searchParams: ct.searchParams, pathname: ct.pathname, href: ct.href });
              } else {
                O.setHost = !1;
                const ct = new r.URL(S);
                _.applyUrlToOptions(O, ct);
              }
              O.method = g.toUpperCase(), O.headers = Object.assign({}, d.headers), _.findHeader("host", O.headers) || (O.headers.host = O.host);
              const A = _.findHeader("content-length", O.headers) !== void 0;
              !d.payload || typeof d.payload != "object" || d.payload instanceof s || p.isBuffer(d.payload) || (d.payload = JSON.stringify(d.payload), _.findHeader("content-type", O.headers) || (O.headers["content-type"] = "application/json")), d.gunzip && _.findHeader("accept-encoding", O.headers) === void 0 && (O.headers["accept-encoding"] = "gzip");
              const l = O.method !== "GET" && O.method !== "HEAD" && !_.isNullOrUndefined(d.payload);
              !l || typeof d.payload != "string" && !p.isBuffer(d.payload) || A || (O.headers["content-length"] = p.isBuffer(d.payload) ? d.payload.length : p.byteLength(d.payload));
              let E = !!d.hasOwnProperty("redirects") && d.redirects;
              (k = k || []).push({ method: O.method, url: S });
              const M = O.protocol === "https:" ? i : n;
              d.rejectUnauthorized !== void 0 && O.protocol === "https:" ? O.agent = d.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized : d.agent || d.agent === !1 ? O.agent = d.agent : O.agent = O.protocol === "https:" ? this.agents.https : this.agents.http, d.secureProtocol !== void 0 && (O.secureProtocol = d.secureProtocol), d.ciphers !== void 0 && (O.ciphers = d.ciphers), this._emit("preRequest", O, d);
              const B = Date.now(), X = M.request(O);
              this._emit("request", X);
              let K, D = null;
              const j = (ct) => (ct.trace = k, nt(u.badGateway("Client request error", ct))), Z = () => {
                if (!X.socket) {
                  const ct = new Error("socket hang up");
                  ct.code = "ECONNRESET", nt(ct);
                }
              };
              X.once("error", j);
              const tt = (ct) => {
                const ut = ct.statusCode, V = _.redirectMethod(ut, O.method, d);
                if (E === !1 || !V)
                  return nt(null, ct);
                if (ct.destroy(), E === 0)
                  return nt(u.badGateway("Maximum redirections reached", k));
                let ot = ct.headers.location;
                if (!ot)
                  return nt(u.badGateway("Received redirection without location", k));
                /^https?:/i.test(ot) || (ot = r.resolve(O.href, ot));
                const xt = f.clone(d, { shallow: _.shallowOptions });
                if (xt.payload = D || d.payload, xt.redirects = --E, K) {
                  clearTimeout(K);
                  const pt = Date.now() - B;
                  xt.timeout = (xt.timeout - pt).toString();
                }
                if (xt.headers) {
                  const pt = new URL(ot);
                  if (O.hostname !== pt.hostname)
                    for (const at of Object.keys(xt.headers)) {
                      const bt = at.toLowerCase();
                      bt !== "authorization" && bt !== "cookie" || delete xt.headers[at];
                    }
                }
                const Ut = (pt) => {
                  if (pt)
                    return pt.trace = k, nt(u.badGateway("Invalid redirect", pt));
                  const at = this._request(V, ot, xt, { callback: nt }, k);
                  d.redirected && d.redirected(ut, ot, at);
                };
                return d.beforeRedirect ? d.beforeRedirect(V, ut, ot, ct.headers, xt, Ut) : Ut();
              }, nt = f.once((ct, ut) => (ct && X.abort(), X.removeListener("response", tt), X.removeListener("error", j), X.removeListener("abort", Z), X.on("error", f.ignore), clearTimeout(K), this._emit("response", ct, { req: X, res: ut, start: B, uri: O }), b.callback(ct, ut)));
              if (X.once("response", tt), d.timeout && (K = setTimeout(() => nt(u.gatewayTimeout("Client request timeout")), d.timeout)), X.on("abort", Z), l) {
                if (d.payload instanceof s) {
                  let ct = d.payload;
                  if (E) {
                    const ut = new h();
                    ut.once("finish", () => {
                      D = ut.collect();
                    }), ct = d.payload.pipe(ut);
                  }
                  return _.deferPipeUntilSocketConnects(X, ct), X;
                }
                X.write(d.payload);
              }
              return X.end(), X;
            }
            _emit(...g) {
              this.events && this.events.emit(...g);
            }
            read(g, S = {}) {
              return new Promise((d, b) => {
                this._read(g, S, (k, O) => {
                  k ? b(k) : d(O);
                });
              });
            }
            _read(g, S, d) {
              S = f.applyToDefaults(this._defaults, S, { shallow: _.shallowOptions });
              let b = null;
              const k = f.once((X, K) => {
                if (clearTimeout(b), E.removeListener("error", M), E.removeListener("finish", B), g.removeListener("error", A), g.removeListener("close", l), g.removeListener("aborted", l), g.on("error", f.ignore), X)
                  return d(X);
                if (!S.json)
                  return d(null, K);
                if (S.json === "force")
                  return _.tryParseBuffer(K, d);
                const D = (g.headers && _.findHeader("content-type", g.headers) || "").split(";")[0].trim().toLowerCase();
                return _.jsonRegex.test(D) ? _.tryParseBuffer(K, d) : S.json === "strict" ? d(u.notAcceptable("The content-type is not JSON compatible")) : d(null, K);
              }), O = S.timeout;
              O && O > 0 && (b = setTimeout(() => k(u.clientTimeout()), O));
              const A = (X) => k(X.isBoom ? X : u.internal("Payload stream error", X)), l = () => {
                g.complete || k(u.internal("Payload stream closed prematurely"));
              };
              g.once("error", A), g.once("close", l), g.once("aborted", l);
              const E = new T({ maxBytes: S.maxBytes }), M = (X) => (g.destroy && g.destroy(), k(X));
              E.once("error", M);
              const B = () => k(null, E.collect());
              if (E.once("finish", B), S.gunzip) {
                const X = S.gunzip === "force" ? "gzip" : g.headers && _.findHeader("content-encoding", g.headers) || "";
                if (/^(x-)?gzip(\s*,\s*identity)?$/.test(X)) {
                  const K = o.createGunzip();
                  return K.once("error", M), void g.pipe(K).pipe(E);
                }
              }
              g.pipe(E);
            }
            toReadableStream(g, S) {
              return new y(g, S);
            }
            parseCacheControl(g) {
              const S = {}, d = g.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (b, k, O, A) => {
                const l = O || A;
                return S[k] = !l || l.toLowerCase(), "";
              });
              if (S["max-age"])
                try {
                  const b = parseInt(S["max-age"], 10);
                  if (isNaN(b))
                    return null;
                  S["max-age"] = b;
                } catch (b) {
                }
              return d ? null : S;
            }
            get(g, S) {
              return this._shortcut("GET", g, S);
            }
            post(g, S) {
              return this._shortcut("POST", g, S);
            }
            patch(g, S) {
              return this._shortcut("PATCH", g, S);
            }
            put(g, S) {
              return this._shortcut("PUT", g, S);
            }
            delete(g, S) {
              return this._shortcut("DELETE", g, S);
            }
            _shortcut(b, k) {
              return sn(this, arguments, function* (g, S, d = {}) {
                const O = yield this.request(g, S, d);
                let A;
                try {
                  A = yield this.read(O, d);
                } catch (E) {
                  throw E.data = E.data || {}, E.data.res = O, E;
                }
                if (O.statusCode < 400)
                  return { res: O, payload: A };
                const l = { isResponseError: !0, headers: O.headers, res: O, payload: A };
                throw new u.Boom(`Response Error: ${O.statusCode} ${O.statusMessage}`, { statusCode: O.statusCode, data: l });
              });
            }
          }, resolveUrl: function(g, S) {
            if (!S)
              return g;
            const d = new r.URL(S, g);
            return r.format(d);
          }, deferPipeUntilSocketConnects: function(g, S) {
            const d = () => {
              S.pipe(g), S.removeListener("error", b);
            }, b = (k) => {
              g.emit("error", k);
            };
            g.once("socket", (k) => {
              if (!k.connecting)
                return d();
              k.once("connect", d);
            }), S.on("error", b);
          }, redirectMethod: function(g, S, d) {
            switch (g) {
              case 301:
              case 302:
                return d.redirectMethod || S;
              case 303:
                if (d.redirect303)
                  return "GET";
                break;
              case 307:
              case 308:
                return S;
            }
            return null;
          }, tryParseBuffer: function(g, S) {
            if (g.length === 0)
              return S(null, null);
            let d;
            try {
              d = a.parse(g.toString());
            } catch (b) {
              return S(u.badGateway(b.message, { payload: g }));
            }
            return S(null, d);
          }, findHeader: function(g, S) {
            const d = g.toLowerCase();
            for (const b of Object.keys(S))
              if (b.toLowerCase() === d)
                return S[b];
          }, applyUrlToOptions: (g, S) => (g.host = S.host, g.origin = S.origin, g.searchParams = S.searchParams, g.protocol = S.protocol, g.hostname = typeof S.hostname == "string" && S.hostname.startsWith("[") ? S.hostname.slice(1, -1) : S.hostname, g.hash = S.hash, g.search = S.search, g.pathname = S.pathname, g.path = `${S.pathname}${S.search || ""}`, g.href = S.href, S.port !== "" && (g.port = Number(S.port)), (S.username || S.password) && (g.auth = `${S.username}:${S.password}`, g.username = S.username, g.password = S.password), g), isNullOrUndefined: (g) => [null, void 0].includes(g) };
          C.exports = new _.Client();
        }).call(this);
      }).call(this, x("buffer").Buffer);
    }, { "./payload": 29, "./recorder": 30, "./tap": 31, "@hapi/boom": 1, "@hapi/bourne": 2, "@hapi/hoek": 17, buffer: 46, events: 95, http: 208, https: 108, stream: 192, url: 229, zlib: 44 }], 29: [function(x, C, c) {
      (function(p) {
        (function() {
          const v = x("stream");
          C.exports = class extends v.Readable {
            constructor(n, i) {
              super();
              const s = [].concat(n || "");
              let r = 0;
              for (let o = 0; o < s.length; ++o) {
                const u = s[o];
                r += u.length, s[o] = p.isBuffer(u) ? u : p.from(u);
              }
              this._data = p.concat(s, r), this._position = 0, this._encoding = i || "utf8";
            }
            _read(n) {
              const i = this._data.slice(this._position, this._position + n);
              this.push(i, this._encoding), this._position = this._position + i.length, this._position >= this._data.length && this.push(null);
            }
          };
        }).call(this);
      }).call(this, x("buffer").Buffer);
    }, { buffer: 46, stream: 192 }], 30: [function(x, C, c) {
      (function(p) {
        (function() {
          const v = x("stream"), n = x("@hapi/boom");
          C.exports = class extends v.Writable {
            constructor(i) {
              super(), this.settings = i, this.buffers = [], this.length = 0;
            }
            _write(i, s, r) {
              if (this.settings.maxBytes && this.length + i.length > this.settings.maxBytes)
                return this.emit("error", n.entityTooLarge("Payload content length greater than maximum allowed: " + this.settings.maxBytes));
              this.length = this.length + i.length, this.buffers.push(i), r();
            }
            collect() {
              return this.buffers.length === 0 ? p.alloc(0) : this.buffers.length === 1 ? this.buffers[0] : p.concat(this.buffers, this.length);
            }
          };
        }).call(this);
      }).call(this, x("buffer").Buffer);
    }, { "@hapi/boom": 1, buffer: 46, stream: 192 }], 31: [function(x, C, c) {
      const p = x("stream"), v = x("./payload");
      C.exports = class extends p.Transform {
        constructor() {
          super(), this.buffers = [];
        }
        _transform(n, i, s) {
          this.buffers.push(n), s(null, n);
        }
        collect() {
          return new v(this.buffers);
        }
      };
    }, { "./payload": 29, stream: 192 }], 32: [function(x, C, c) {
      var p = x("es-abstract/2021/Call"), v = x("es-abstract/2021/Get"), n = x("es-abstract/2021/HasProperty"), i = x("es-abstract/2021/IsCallable"), s = x("es-abstract/2021/LengthOfArrayLike"), r = x("es-abstract/2021/ToObject"), o = x("es-abstract/2021/ToString"), u = x("call-bind/callBound"), a = x("is-string"), f = TypeError, y = Object("a"), T = y[0] !== "a" || !(0 in y), h = u("%String.prototype.split%");
      C.exports = function(_) {
        var g = r(this), S = T && a(g) ? h(g, "") : g, d = s(S);
        if (!i(_))
          throw new f("Array.prototype.reduce callback must be a function");
        if (d === 0 && arguments.length < 2)
          throw new f("reduce of empty array with no initial value");
        var b, k, O, A = 0;
        if (arguments.length > 1)
          b = arguments[1];
        else {
          for (O = !1; !O && A < d; )
            k = o(A), (O = n(g, k)) && (b = v(g, k)), A += 1;
          if (!O)
            throw new f("reduce of empty array with no initial value");
        }
        for (; A < d; ) {
          if (k = o(A), O = n(g, k)) {
            var l = v(g, k);
            b = p(_, void 0, [b, l, A, g]);
          }
          A += 1;
        }
        return b;
      };
    }, { "call-bind/callBound": 48, "es-abstract/2021/Call": 52, "es-abstract/2021/Get": 55, "es-abstract/2021/HasProperty": 56, "es-abstract/2021/IsCallable": 58, "es-abstract/2021/LengthOfArrayLike": 63, "es-abstract/2021/ToObject": 71, "es-abstract/2021/ToString": 74, "is-string": 116 }], 33: [function(x, C, c) {
      var p = x("define-properties"), v = x("es-abstract/2021/RequireObjectCoercible"), n = x("call-bind"), i = x("call-bind/callBound"), s = x("./implementation"), r = x("./polyfill"), o = n.apply(r()), u = x("./shim"), a = i("%Array.prototype.slice%"), f = function(y, T) {
        return v(y), o(y, a(arguments, 1));
      };
      p(f, { getPolyfill: r, implementation: s, shim: u }), C.exports = f;
    }, { "./implementation": 32, "./polyfill": 34, "./shim": 35, "call-bind": 49, "call-bind/callBound": 48, "define-properties": 50, "es-abstract/2021/RequireObjectCoercible": 65 }], 34: [function(x, C, c) {
      var p = x("es-array-method-boxes-properly"), v = x("./implementation");
      C.exports = function() {
        var n = Array.prototype.reduce;
        return p(n) ? n : v;
      };
    }, { "./implementation": 32, "es-array-method-boxes-properly": 92 }], 35: [function(x, C, c) {
      var p = x("define-properties"), v = x("./polyfill");
      C.exports = function() {
        var n = v();
        return p(Array.prototype, { reduce: n }, { reduce: function() {
          return Array.prototype.reduce !== n;
        } }), n;
      };
    }, { "./polyfill": 34, "define-properties": 50 }], 36: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = x("object-assign");
          function n(D, j) {
            if (D === j)
              return 0;
            for (var Z = D.length, tt = j.length, nt = 0, ct = Math.min(Z, tt); nt < ct; ++nt)
              if (D[nt] !== j[nt]) {
                Z = D[nt], tt = j[nt];
                break;
              }
            return Z < tt ? -1 : tt < Z ? 1 : 0;
          }
          function i(D) {
            return p.Buffer && typeof p.Buffer.isBuffer == "function" ? p.Buffer.isBuffer(D) : !(D == null || !D._isBuffer);
          }
          var s = x("util/"), r = Object.prototype.hasOwnProperty, o = Array.prototype.slice, u = function() {
          }.name === "foo";
          function a(D) {
            return Object.prototype.toString.call(D);
          }
          function f(D) {
            return !i(D) && typeof p.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(D) : !!D && (D instanceof DataView || !!(D.buffer && D.buffer instanceof ArrayBuffer)));
          }
          var y = C.exports = b, T = /\s*function\s+([^\(\s]*)\s*/;
          function h(D) {
            if (s.isFunction(D)) {
              if (u)
                return D.name;
              var j = D.toString().match(T);
              return j && j[1];
            }
          }
          function _(D, j) {
            return typeof D == "string" ? D.length < j ? D : D.slice(0, j) : D;
          }
          function g(D) {
            if (u || !s.isFunction(D))
              return s.inspect(D);
            var j = h(D);
            return "[Function" + (j ? ": " + j : "") + "]";
          }
          function S(D) {
            return _(g(D.actual), 128) + " " + D.operator + " " + _(g(D.expected), 128);
          }
          function d(D, j, Z, tt, nt) {
            throw new y.AssertionError({ message: Z, actual: D, expected: j, operator: tt, stackStartFunction: nt });
          }
          function b(D, j) {
            D || d(D, !0, j, "==", y.ok);
          }
          function k(D, j, Z, tt) {
            if (D === j)
              return !0;
            if (i(D) && i(j))
              return n(D, j) === 0;
            if (s.isDate(D) && s.isDate(j))
              return D.getTime() === j.getTime();
            if (s.isRegExp(D) && s.isRegExp(j))
              return D.source === j.source && D.global === j.global && D.multiline === j.multiline && D.lastIndex === j.lastIndex && D.ignoreCase === j.ignoreCase;
            if (D !== null && typeof D == "object" || j !== null && typeof j == "object") {
              if (f(D) && f(j) && a(D) === a(j) && !(D instanceof Float32Array || D instanceof Float64Array))
                return n(new Uint8Array(D.buffer), new Uint8Array(j.buffer)) === 0;
              if (i(D) !== i(j))
                return !1;
              var nt = (tt = tt || { actual: [], expected: [] }).actual.indexOf(D);
              return nt !== -1 && nt === tt.expected.indexOf(j) || (tt.actual.push(D), tt.expected.push(j), A(D, j, Z, tt));
            }
            return Z ? D === j : D == j;
          }
          function O(D) {
            return Object.prototype.toString.call(D) == "[object Arguments]";
          }
          function A(D, j, Z, tt) {
            if (D == null || j == null)
              return !1;
            if (s.isPrimitive(D) || s.isPrimitive(j))
              return D === j;
            if (Z && Object.getPrototypeOf(D) !== Object.getPrototypeOf(j))
              return !1;
            var nt = O(D), ct = O(j);
            if (nt && !ct || !nt && ct)
              return !1;
            if (nt)
              return k(D = o.call(D), j = o.call(j), Z);
            var ut, V, ot = K(D), xt = K(j);
            if (ot.length !== xt.length)
              return !1;
            for (ot.sort(), xt.sort(), V = ot.length - 1; V >= 0; V--)
              if (ot[V] !== xt[V])
                return !1;
            for (V = ot.length - 1; V >= 0; V--)
              if (!k(D[ut = ot[V]], j[ut], Z, tt))
                return !1;
            return !0;
          }
          function l(D, j, Z) {
            k(D, j, !0) && d(D, j, Z, "notDeepStrictEqual", l);
          }
          function E(D, j) {
            if (!D || !j)
              return !1;
            if (Object.prototype.toString.call(j) == "[object RegExp]")
              return j.test(D);
            try {
              if (D instanceof j)
                return !0;
            } catch (Z) {
            }
            return !Error.isPrototypeOf(j) && j.call({}, D) === !0;
          }
          function M(D) {
            var j;
            try {
              D();
            } catch (Z) {
              j = Z;
            }
            return j;
          }
          function B(D, j, Z, tt) {
            var nt;
            if (typeof j != "function")
              throw new TypeError('"block" argument must be a function');
            typeof Z == "string" && (tt = Z, Z = null), nt = M(j), tt = (Z && Z.name ? " (" + Z.name + ")." : ".") + (tt ? " " + tt : "."), D && !nt && d(nt, Z, "Missing expected exception" + tt);
            var ct = typeof tt == "string", ut = !D && nt && !Z;
            if ((!D && s.isError(nt) && ct && E(nt, Z) || ut) && d(nt, Z, "Got unwanted exception" + tt), D && nt && Z && !E(nt, Z) || !D && nt)
              throw nt;
          }
          function X(D, j) {
            D || d(D, !0, j, "==", X);
          }
          y.AssertionError = function(D) {
            this.name = "AssertionError", this.actual = D.actual, this.expected = D.expected, this.operator = D.operator, D.message ? (this.message = D.message, this.generatedMessage = !1) : (this.message = S(this), this.generatedMessage = !0);
            var j = D.stackStartFunction || d;
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, j);
            else {
              var Z = new Error();
              if (Z.stack) {
                var tt = Z.stack, nt = h(j), ct = tt.indexOf(`
` + nt);
                if (ct >= 0) {
                  var ut = tt.indexOf(`
`, ct + 1);
                  tt = tt.substring(ut + 1);
                }
                this.stack = tt;
              }
            }
          }, s.inherits(y.AssertionError, Error), y.fail = d, y.ok = b, y.equal = function(D, j, Z) {
            D != j && d(D, j, Z, "==", y.equal);
          }, y.notEqual = function(D, j, Z) {
            D == j && d(D, j, Z, "!=", y.notEqual);
          }, y.deepEqual = function(D, j, Z) {
            k(D, j, !1) || d(D, j, Z, "deepEqual", y.deepEqual);
          }, y.deepStrictEqual = function(D, j, Z) {
            k(D, j, !0) || d(D, j, Z, "deepStrictEqual", y.deepStrictEqual);
          }, y.notDeepEqual = function(D, j, Z) {
            k(D, j, !1) && d(D, j, Z, "notDeepEqual", y.notDeepEqual);
          }, y.notDeepStrictEqual = l, y.strictEqual = function(D, j, Z) {
            D !== j && d(D, j, Z, "===", y.strictEqual);
          }, y.notStrictEqual = function(D, j, Z) {
            D === j && d(D, j, Z, "!==", y.notStrictEqual);
          }, y.throws = function(D, j, Z) {
            B(!0, D, j, Z);
          }, y.doesNotThrow = function(D, j, Z) {
            B(!1, D, j, Z);
          }, y.ifError = function(D) {
            if (D)
              throw D;
          }, y.strict = v(X, y, { equal: y.strictEqual, deepEqual: y.deepStrictEqual, notEqual: y.notStrictEqual, notDeepEqual: y.notDeepStrictEqual }), y.strict.strict = y.strict;
          var K = Object.keys || function(D) {
            var j = [];
            for (var Z in D)
              r.call(D, Z) && j.push(Z);
            return j;
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "object-assign": 135, "util/": 39 }], 37: [function(x, C, c) {
      typeof Object.create == "function" ? C.exports = function(p, v) {
        p.super_ = v, p.prototype = Object.create(v.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } });
      } : C.exports = function(p, v) {
        p.super_ = v;
        var n = function() {
        };
        n.prototype = v.prototype, p.prototype = new n(), p.prototype.constructor = p;
      };
    }, {}], 38: [function(x, C, c) {
      C.exports = function(p) {
        return p && typeof p == "object" && typeof p.copy == "function" && typeof p.fill == "function" && typeof p.readUInt8 == "function";
      };
    }, {}], 39: [function(x, C, c) {
      (function(p, v) {
        (function() {
          var n = /%[sdj%]/g;
          c.format = function(V) {
            if (!A(V)) {
              for (var ot = [], xt = 0; xt < arguments.length; xt++)
                ot.push(r(arguments[xt]));
              return ot.join(" ");
            }
            xt = 1;
            for (var Ut = arguments, pt = Ut.length, at = String(V).replace(n, function(Q) {
              if (Q === "%%")
                return "%";
              if (xt >= pt)
                return Q;
              switch (Q) {
                case "%s":
                  return String(Ut[xt++]);
                case "%d":
                  return Number(Ut[xt++]);
                case "%j":
                  try {
                    return JSON.stringify(Ut[xt++]);
                  } catch (At) {
                    return "[Circular]";
                  }
                default:
                  return Q;
              }
            }), bt = Ut[xt]; xt < pt; bt = Ut[++xt])
              b(bt) || !B(bt) ? at += " " + bt : at += " " + r(bt);
            return at;
          }, c.deprecate = function(V, ot) {
            if (E(v.process))
              return function() {
                return c.deprecate(V, ot).apply(this, arguments);
              };
            if (p.noDeprecation === !0)
              return V;
            var xt = !1;
            return function() {
              if (!xt) {
                if (p.throwDeprecation)
                  throw new Error(ot);
                p.traceDeprecation ? console.trace(ot) : console.error(ot), xt = !0;
              }
              return V.apply(this, arguments);
            };
          };
          var i, s = {};
          function r(V, ot) {
            var xt = { seen: [], stylize: u };
            return arguments.length >= 3 && (xt.depth = arguments[2]), arguments.length >= 4 && (xt.colors = arguments[3]), d(ot) ? xt.showHidden = ot : ot && c._extend(xt, ot), E(xt.showHidden) && (xt.showHidden = !1), E(xt.depth) && (xt.depth = 2), E(xt.colors) && (xt.colors = !1), E(xt.customInspect) && (xt.customInspect = !0), xt.colors && (xt.stylize = o), f(xt, V, xt.depth);
          }
          function o(V, ot) {
            var xt = r.styles[ot];
            return xt ? "\x1B[" + r.colors[xt][0] + "m" + V + "\x1B[" + r.colors[xt][1] + "m" : V;
          }
          function u(V, ot) {
            return V;
          }
          function a(V) {
            var ot = {};
            return V.forEach(function(xt, Ut) {
              ot[xt] = !0;
            }), ot;
          }
          function f(V, ot, xt) {
            if (V.customInspect && ot && D(ot.inspect) && ot.inspect !== c.inspect && (!ot.constructor || ot.constructor.prototype !== ot)) {
              var Ut = ot.inspect(xt, V);
              return A(Ut) || (Ut = f(V, Ut, xt)), Ut;
            }
            var pt = y(V, ot);
            if (pt)
              return pt;
            var at = Object.keys(ot), bt = a(at);
            if (V.showHidden && (at = Object.getOwnPropertyNames(ot)), K(ot) && (at.indexOf("message") >= 0 || at.indexOf("description") >= 0))
              return T(ot);
            if (at.length === 0) {
              if (D(ot)) {
                var Q = ot.name ? ": " + ot.name : "";
                return V.stylize("[Function" + Q + "]", "special");
              }
              if (M(ot))
                return V.stylize(RegExp.prototype.toString.call(ot), "regexp");
              if (X(ot))
                return V.stylize(Date.prototype.toString.call(ot), "date");
              if (K(ot))
                return T(ot);
            }
            var At, Pt = "", q = !1, G = ["{", "}"];
            return S(ot) && (q = !0, G = ["[", "]"]), D(ot) && (Pt = " [Function" + (ot.name ? ": " + ot.name : "") + "]"), M(ot) && (Pt = " " + RegExp.prototype.toString.call(ot)), X(ot) && (Pt = " " + Date.prototype.toUTCString.call(ot)), K(ot) && (Pt = " " + T(ot)), at.length !== 0 || q && ot.length != 0 ? xt < 0 ? M(ot) ? V.stylize(RegExp.prototype.toString.call(ot), "regexp") : V.stylize("[Object]", "special") : (V.seen.push(ot), At = q ? h(V, ot, xt, bt, at) : at.map(function(lt) {
              return _(V, ot, xt, bt, lt, q);
            }), V.seen.pop(), g(At, Pt, G)) : G[0] + Pt + G[1];
          }
          function y(V, ot) {
            if (E(ot))
              return V.stylize("undefined", "undefined");
            if (A(ot)) {
              var xt = "'" + JSON.stringify(ot).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return V.stylize(xt, "string");
            }
            return O(ot) ? V.stylize("" + ot, "number") : d(ot) ? V.stylize("" + ot, "boolean") : b(ot) ? V.stylize("null", "null") : void 0;
          }
          function T(V) {
            return "[" + Error.prototype.toString.call(V) + "]";
          }
          function h(V, ot, xt, Ut, pt) {
            for (var at = [], bt = 0, Q = ot.length; bt < Q; ++bt)
              ut(ot, String(bt)) ? at.push(_(V, ot, xt, Ut, String(bt), !0)) : at.push("");
            return pt.forEach(function(At) {
              At.match(/^\d+$/) || at.push(_(V, ot, xt, Ut, At, !0));
            }), at;
          }
          function _(V, ot, xt, Ut, pt, at) {
            var bt, Q, At;
            if ((At = Object.getOwnPropertyDescriptor(ot, pt) || { value: ot[pt] }).get ? Q = At.set ? V.stylize("[Getter/Setter]", "special") : V.stylize("[Getter]", "special") : At.set && (Q = V.stylize("[Setter]", "special")), ut(Ut, pt) || (bt = "[" + pt + "]"), Q || (V.seen.indexOf(At.value) < 0 ? (Q = b(xt) ? f(V, At.value, null) : f(V, At.value, xt - 1)).indexOf(`
`) > -1 && (Q = at ? Q.split(`
`).map(function(Pt) {
              return "  " + Pt;
            }).join(`
`).substr(2) : `
` + Q.split(`
`).map(function(Pt) {
              return "   " + Pt;
            }).join(`
`)) : Q = V.stylize("[Circular]", "special")), E(bt)) {
              if (at && pt.match(/^\d+$/))
                return Q;
              (bt = JSON.stringify("" + pt)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (bt = bt.substr(1, bt.length - 2), bt = V.stylize(bt, "name")) : (bt = bt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), bt = V.stylize(bt, "string"));
            }
            return bt + ": " + Q;
          }
          function g(V, ot, xt) {
            return V.reduce(function(Ut, pt) {
              return pt.indexOf(`
`) >= 0, Ut + pt.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0) > 60 ? xt[0] + (ot === "" ? "" : ot + `
 `) + " " + V.join(`,
  `) + " " + xt[1] : xt[0] + ot + " " + V.join(", ") + " " + xt[1];
          }
          function S(V) {
            return Array.isArray(V);
          }
          function d(V) {
            return typeof V == "boolean";
          }
          function b(V) {
            return V === null;
          }
          function k(V) {
            return V == null;
          }
          function O(V) {
            return typeof V == "number";
          }
          function A(V) {
            return typeof V == "string";
          }
          function l(V) {
            return typeof V == "symbol";
          }
          function E(V) {
            return V === void 0;
          }
          function M(V) {
            return B(V) && Z(V) === "[object RegExp]";
          }
          function B(V) {
            return typeof V == "object" && V !== null;
          }
          function X(V) {
            return B(V) && Z(V) === "[object Date]";
          }
          function K(V) {
            return B(V) && (Z(V) === "[object Error]" || V instanceof Error);
          }
          function D(V) {
            return typeof V == "function";
          }
          function j(V) {
            return V === null || typeof V == "boolean" || typeof V == "number" || typeof V == "string" || typeof V == "symbol" || V === void 0;
          }
          function Z(V) {
            return Object.prototype.toString.call(V);
          }
          function tt(V) {
            return V < 10 ? "0" + V.toString(10) : V.toString(10);
          }
          c.debuglog = function(V) {
            if (E(i) && (i = p.env.NODE_DEBUG || ""), V = V.toUpperCase(), !s[V])
              if (new RegExp("\\b" + V + "\\b", "i").test(i)) {
                var ot = p.pid;
                s[V] = function() {
                  var xt = c.format.apply(c, arguments);
                  console.error("%s %d: %s", V, ot, xt);
                };
              } else
                s[V] = function() {
                };
            return s[V];
          }, c.inspect = r, r.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, r.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, c.isArray = S, c.isBoolean = d, c.isNull = b, c.isNullOrUndefined = k, c.isNumber = O, c.isString = A, c.isSymbol = l, c.isUndefined = E, c.isRegExp = M, c.isObject = B, c.isDate = X, c.isError = K, c.isFunction = D, c.isPrimitive = j, c.isBuffer = x("./support/isBuffer");
          var nt = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          function ct() {
            var V = /* @__PURE__ */ new Date(), ot = [tt(V.getHours()), tt(V.getMinutes()), tt(V.getSeconds())].join(":");
            return [V.getDate(), nt[V.getMonth()], ot].join(" ");
          }
          function ut(V, ot) {
            return Object.prototype.hasOwnProperty.call(V, ot);
          }
          c.log = function() {
            console.log("%s - %s", ct(), c.format.apply(c, arguments));
          }, c.inherits = x("inherits"), c._extend = function(V, ot) {
            if (!ot || !B(ot))
              return V;
            for (var xt = Object.keys(ot), Ut = xt.length; Ut--; )
              V[xt[Ut]] = ot[xt[Ut]];
            return V;
          };
        }).call(this);
      }).call(this, x("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "./support/isBuffer": 38, _process: 158, inherits: 37 }], 40: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], n = typeof globalThis == "undefined" ? p : globalThis;
          C.exports = function() {
            for (var i = [], s = 0; s < v.length; s++)
              typeof n[v[s]] == "function" && (i[i.length] = v[s]);
            return i;
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 41: [function(x, C, c) {
      c.byteLength = u, c.toByteArray = f, c.fromByteArray = h;
      for (var p = [], v = [], n = typeof Uint8Array != "undefined" ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, r = i.length; s < r; ++s)
        p[s] = i[s], v[i.charCodeAt(s)] = s;
      function o(_) {
        var g = _.length;
        if (g % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        var S = _.indexOf("=");
        return S === -1 && (S = g), [S, S === g ? 0 : 4 - S % 4];
      }
      function u(_) {
        var g = o(_), S = g[0], d = g[1];
        return 3 * (S + d) / 4 - d;
      }
      function a(_, g, S) {
        return 3 * (g + S) / 4 - S;
      }
      function f(_) {
        var g, S, d = o(_), b = d[0], k = d[1], O = new n(a(_, b, k)), A = 0, l = k > 0 ? b - 4 : b;
        for (S = 0; S < l; S += 4)
          g = v[_.charCodeAt(S)] << 18 | v[_.charCodeAt(S + 1)] << 12 | v[_.charCodeAt(S + 2)] << 6 | v[_.charCodeAt(S + 3)], O[A++] = g >> 16 & 255, O[A++] = g >> 8 & 255, O[A++] = 255 & g;
        return k === 2 && (g = v[_.charCodeAt(S)] << 2 | v[_.charCodeAt(S + 1)] >> 4, O[A++] = 255 & g), k === 1 && (g = v[_.charCodeAt(S)] << 10 | v[_.charCodeAt(S + 1)] << 4 | v[_.charCodeAt(S + 2)] >> 2, O[A++] = g >> 8 & 255, O[A++] = 255 & g), O;
      }
      function y(_) {
        return p[_ >> 18 & 63] + p[_ >> 12 & 63] + p[_ >> 6 & 63] + p[63 & _];
      }
      function T(_, g, S) {
        for (var d, b = [], k = g; k < S; k += 3)
          d = (_[k] << 16 & 16711680) + (_[k + 1] << 8 & 65280) + (255 & _[k + 2]), b.push(y(d));
        return b.join("");
      }
      function h(_) {
        for (var g, S = _.length, d = S % 3, b = [], k = 0, O = S - d; k < O; k += 16383)
          b.push(T(_, k, k + 16383 > O ? O : k + 16383));
        return d === 1 ? (g = _[S - 1], b.push(p[g >> 2] + p[g << 4 & 63] + "==")) : d === 2 && (g = (_[S - 2] << 8) + _[S - 1], b.push(p[g >> 10] + p[g >> 4 & 63] + p[g << 2 & 63] + "=")), b.join("");
      }
      v["-".charCodeAt(0)] = 62, v["_".charCodeAt(0)] = 63;
    }, {}], 42: [function(x, C, c) {
    }, {}], 43: [function(x, C, c) {
      (function(p, v) {
        (function() {
          var n = x("assert"), i = x("pako/lib/zlib/zstream"), s = x("pako/lib/zlib/deflate.js"), r = x("pako/lib/zlib/inflate.js"), o = x("pako/lib/zlib/constants");
          for (var u in o)
            c[u] = o[u];
          c.NONE = 0, c.DEFLATE = 1, c.INFLATE = 2, c.GZIP = 3, c.GUNZIP = 4, c.DEFLATERAW = 5, c.INFLATERAW = 6, c.UNZIP = 7;
          var a = 31, f = 139;
          function y(T) {
            if (typeof T != "number" || T < c.DEFLATE || T > c.UNZIP)
              throw new TypeError("Bad argument");
            this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = T, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
          }
          y.prototype.close = function() {
            this.write_in_progress ? this.pending_close = !0 : (this.pending_close = !1, n(this.init_done, "close before init"), n(this.mode <= c.UNZIP), this.mode === c.DEFLATE || this.mode === c.GZIP || this.mode === c.DEFLATERAW ? s.deflateEnd(this.strm) : this.mode !== c.INFLATE && this.mode !== c.GUNZIP && this.mode !== c.INFLATERAW && this.mode !== c.UNZIP || r.inflateEnd(this.strm), this.mode = c.NONE, this.dictionary = null);
          }, y.prototype.write = function(T, h, _, g, S, d, b) {
            return this._write(!0, T, h, _, g, S, d, b);
          }, y.prototype.writeSync = function(T, h, _, g, S, d, b) {
            return this._write(!1, T, h, _, g, S, d, b);
          }, y.prototype._write = function(T, h, _, g, S, d, b, k) {
            if (n.equal(arguments.length, 8), n(this.init_done, "write before init"), n(this.mode !== c.NONE, "already finalized"), n.equal(!1, this.write_in_progress, "write already in progress"), n.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, n.equal(!1, h === void 0, "must provide flush value"), this.write_in_progress = !0, h !== c.Z_NO_FLUSH && h !== c.Z_PARTIAL_FLUSH && h !== c.Z_SYNC_FLUSH && h !== c.Z_FULL_FLUSH && h !== c.Z_FINISH && h !== c.Z_BLOCK)
              throw new Error("Invalid flush value");
            if (_ == null && (_ = v.alloc(0), S = 0, g = 0), this.strm.avail_in = S, this.strm.input = _, this.strm.next_in = g, this.strm.avail_out = k, this.strm.output = d, this.strm.next_out = b, this.flush = h, !T)
              return this._process(), this._checkError() ? this._afterSync() : void 0;
            var O = this;
            return p.nextTick(function() {
              O._process(), O._after();
            }), this;
          }, y.prototype._afterSync = function() {
            var T = this.strm.avail_out, h = this.strm.avail_in;
            return this.write_in_progress = !1, [h, T];
          }, y.prototype._process = function() {
            var T = null;
            switch (this.mode) {
              case c.DEFLATE:
              case c.GZIP:
              case c.DEFLATERAW:
                this.err = s.deflate(this.strm, this.flush);
                break;
              case c.UNZIP:
                switch (this.strm.avail_in > 0 && (T = this.strm.next_in), this.gzip_id_bytes_read) {
                  case 0:
                    if (T === null)
                      break;
                    if (this.strm.input[T] !== a) {
                      this.mode = c.INFLATE;
                      break;
                    }
                    if (this.gzip_id_bytes_read = 1, T++, this.strm.avail_in === 1)
                      break;
                  case 1:
                    if (T === null)
                      break;
                    this.strm.input[T] === f ? (this.gzip_id_bytes_read = 2, this.mode = c.GUNZIP) : this.mode = c.INFLATE;
                    break;
                  default:
                    throw new Error("invalid number of gzip magic number bytes read");
                }
              case c.INFLATE:
              case c.GUNZIP:
              case c.INFLATERAW:
                for (this.err = r.inflate(this.strm, this.flush), this.err === c.Z_NEED_DICT && this.dictionary && (this.err = r.inflateSetDictionary(this.strm, this.dictionary), this.err === c.Z_OK ? this.err = r.inflate(this.strm, this.flush) : this.err === c.Z_DATA_ERROR && (this.err = c.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === c.GUNZIP && this.err === c.Z_STREAM_END && this.strm.next_in[0] !== 0; )
                  this.reset(), this.err = r.inflate(this.strm, this.flush);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
          }, y.prototype._checkError = function() {
            switch (this.err) {
              case c.Z_OK:
              case c.Z_BUF_ERROR:
                if (this.strm.avail_out !== 0 && this.flush === c.Z_FINISH)
                  return this._error("unexpected end of file"), !1;
                break;
              case c.Z_STREAM_END:
                break;
              case c.Z_NEED_DICT:
                return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
              default:
                return this._error("Zlib error"), !1;
            }
            return !0;
          }, y.prototype._after = function() {
            if (this._checkError()) {
              var T = this.strm.avail_out, h = this.strm.avail_in;
              this.write_in_progress = !1, this.callback(h, T), this.pending_close && this.close();
            }
          }, y.prototype._error = function(T) {
            this.strm.msg && (T = this.strm.msg), this.onerror(T, this.err), this.write_in_progress = !1, this.pending_close && this.close();
          }, y.prototype.init = function(T, h, _, g, S) {
            n(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), n(T >= 8 && T <= 15, "invalid windowBits"), n(h >= -1 && h <= 9, "invalid compression level"), n(_ >= 1 && _ <= 9, "invalid memlevel"), n(g === c.Z_FILTERED || g === c.Z_HUFFMAN_ONLY || g === c.Z_RLE || g === c.Z_FIXED || g === c.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(h, T, _, g, S), this._setDictionary();
          }, y.prototype.params = function() {
            throw new Error("deflateParams Not supported");
          }, y.prototype.reset = function() {
            this._reset(), this._setDictionary();
          }, y.prototype._init = function(T, h, _, g, S) {
            switch (this.level = T, this.windowBits = h, this.memLevel = _, this.strategy = g, this.flush = c.Z_NO_FLUSH, this.err = c.Z_OK, this.mode !== c.GZIP && this.mode !== c.GUNZIP || (this.windowBits += 16), this.mode === c.UNZIP && (this.windowBits += 32), this.mode !== c.DEFLATERAW && this.mode !== c.INFLATERAW || (this.windowBits = -1 * this.windowBits), this.strm = new i(), this.mode) {
              case c.DEFLATE:
              case c.GZIP:
              case c.DEFLATERAW:
                this.err = s.deflateInit2(this.strm, this.level, c.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                break;
              case c.INFLATE:
              case c.GUNZIP:
              case c.INFLATERAW:
              case c.UNZIP:
                this.err = r.inflateInit2(this.strm, this.windowBits);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
            this.err !== c.Z_OK && this._error("Init error"), this.dictionary = S, this.write_in_progress = !1, this.init_done = !0;
          }, y.prototype._setDictionary = function() {
            if (this.dictionary != null) {
              switch (this.err = c.Z_OK, this.mode) {
                case c.DEFLATE:
                case c.DEFLATERAW:
                  this.err = s.deflateSetDictionary(this.strm, this.dictionary);
              }
              this.err !== c.Z_OK && this._error("Failed to set dictionary");
            }
          }, y.prototype._reset = function() {
            switch (this.err = c.Z_OK, this.mode) {
              case c.DEFLATE:
              case c.DEFLATERAW:
              case c.GZIP:
                this.err = s.deflateReset(this.strm);
                break;
              case c.INFLATE:
              case c.INFLATERAW:
              case c.GUNZIP:
                this.err = r.inflateReset(this.strm);
            }
            this.err !== c.Z_OK && this._error("Failed to reset stream");
          }, c.Zlib = y;
        }).call(this);
      }).call(this, x("_process"), x("buffer").Buffer);
    }, { _process: 158, assert: 36, buffer: 46, "pako/lib/zlib/constants": 147, "pako/lib/zlib/deflate.js": 149, "pako/lib/zlib/inflate.js": 151, "pako/lib/zlib/zstream": 155 }], 44: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = x("buffer").Buffer, n = x("stream").Transform, i = x("./binding"), s = x("util"), r = x("assert").ok, o = x("buffer").kMaxLength, u = "Cannot create final Buffer. It would be larger than 0x" + o.toString(16) + " bytes";
          i.Z_MIN_WINDOWBITS = 8, i.Z_MAX_WINDOWBITS = 15, i.Z_DEFAULT_WINDOWBITS = 15, i.Z_MIN_CHUNK = 64, i.Z_MAX_CHUNK = 1 / 0, i.Z_DEFAULT_CHUNK = 16384, i.Z_MIN_MEMLEVEL = 1, i.Z_MAX_MEMLEVEL = 9, i.Z_DEFAULT_MEMLEVEL = 8, i.Z_MIN_LEVEL = -1, i.Z_MAX_LEVEL = 9, i.Z_DEFAULT_LEVEL = i.Z_DEFAULT_COMPRESSION;
          for (var a = Object.keys(i), f = 0; f < a.length; f++) {
            var y = a[f];
            y.match(/^Z/) && Object.defineProperty(c, y, { enumerable: !0, value: i[y], writable: !1 });
          }
          for (var T = { Z_OK: i.Z_OK, Z_STREAM_END: i.Z_STREAM_END, Z_NEED_DICT: i.Z_NEED_DICT, Z_ERRNO: i.Z_ERRNO, Z_STREAM_ERROR: i.Z_STREAM_ERROR, Z_DATA_ERROR: i.Z_DATA_ERROR, Z_MEM_ERROR: i.Z_MEM_ERROR, Z_BUF_ERROR: i.Z_BUF_ERROR, Z_VERSION_ERROR: i.Z_VERSION_ERROR }, h = Object.keys(T), _ = 0; _ < h.length; _++) {
            var g = h[_];
            T[T[g]] = g;
          }
          function S(j, Z, tt) {
            var nt = [], ct = 0;
            function ut() {
              for (var ot; (ot = j.read()) !== null; )
                nt.push(ot), ct += ot.length;
              j.once("readable", ut);
            }
            function V() {
              var ot, xt = null;
              ct >= o ? xt = new RangeError(u) : ot = v.concat(nt, ct), nt = [], j.close(), tt(xt, ot);
            }
            j.on("error", function(ot) {
              j.removeListener("end", V), j.removeListener("readable", ut), tt(ot);
            }), j.on("end", V), j.end(Z), ut();
          }
          function d(j, Z) {
            if (typeof Z == "string" && (Z = v.from(Z)), !v.isBuffer(Z))
              throw new TypeError("Not a string or buffer");
            var tt = j._finishFlushFlag;
            return j._processChunk(Z, tt);
          }
          function b(j) {
            if (!(this instanceof b))
              return new b(j);
            X.call(this, j, i.DEFLATE);
          }
          function k(j) {
            if (!(this instanceof k))
              return new k(j);
            X.call(this, j, i.INFLATE);
          }
          function O(j) {
            if (!(this instanceof O))
              return new O(j);
            X.call(this, j, i.GZIP);
          }
          function A(j) {
            if (!(this instanceof A))
              return new A(j);
            X.call(this, j, i.GUNZIP);
          }
          function l(j) {
            if (!(this instanceof l))
              return new l(j);
            X.call(this, j, i.DEFLATERAW);
          }
          function E(j) {
            if (!(this instanceof E))
              return new E(j);
            X.call(this, j, i.INFLATERAW);
          }
          function M(j) {
            if (!(this instanceof M))
              return new M(j);
            X.call(this, j, i.UNZIP);
          }
          function B(j) {
            return j === i.Z_NO_FLUSH || j === i.Z_PARTIAL_FLUSH || j === i.Z_SYNC_FLUSH || j === i.Z_FULL_FLUSH || j === i.Z_FINISH || j === i.Z_BLOCK;
          }
          function X(j, Z) {
            var tt = this;
            if (this._opts = j = j || {}, this._chunkSize = j.chunkSize || c.Z_DEFAULT_CHUNK, n.call(this, j), j.flush && !B(j.flush))
              throw new Error("Invalid flush flag: " + j.flush);
            if (j.finishFlush && !B(j.finishFlush))
              throw new Error("Invalid flush flag: " + j.finishFlush);
            if (this._flushFlag = j.flush || i.Z_NO_FLUSH, this._finishFlushFlag = j.finishFlush !== void 0 ? j.finishFlush : i.Z_FINISH, j.chunkSize && (j.chunkSize < c.Z_MIN_CHUNK || j.chunkSize > c.Z_MAX_CHUNK))
              throw new Error("Invalid chunk size: " + j.chunkSize);
            if (j.windowBits && (j.windowBits < c.Z_MIN_WINDOWBITS || j.windowBits > c.Z_MAX_WINDOWBITS))
              throw new Error("Invalid windowBits: " + j.windowBits);
            if (j.level && (j.level < c.Z_MIN_LEVEL || j.level > c.Z_MAX_LEVEL))
              throw new Error("Invalid compression level: " + j.level);
            if (j.memLevel && (j.memLevel < c.Z_MIN_MEMLEVEL || j.memLevel > c.Z_MAX_MEMLEVEL))
              throw new Error("Invalid memLevel: " + j.memLevel);
            if (j.strategy && j.strategy != c.Z_FILTERED && j.strategy != c.Z_HUFFMAN_ONLY && j.strategy != c.Z_RLE && j.strategy != c.Z_FIXED && j.strategy != c.Z_DEFAULT_STRATEGY)
              throw new Error("Invalid strategy: " + j.strategy);
            if (j.dictionary && !v.isBuffer(j.dictionary))
              throw new Error("Invalid dictionary: it should be a Buffer instance");
            this._handle = new i.Zlib(Z);
            var nt = this;
            this._hadError = !1, this._handle.onerror = function(V, ot) {
              K(nt), nt._hadError = !0;
              var xt = new Error(V);
              xt.errno = ot, xt.code = c.codes[ot], nt.emit("error", xt);
            };
            var ct = c.Z_DEFAULT_COMPRESSION;
            typeof j.level == "number" && (ct = j.level);
            var ut = c.Z_DEFAULT_STRATEGY;
            typeof j.strategy == "number" && (ut = j.strategy), this._handle.init(j.windowBits || c.Z_DEFAULT_WINDOWBITS, ct, j.memLevel || c.Z_DEFAULT_MEMLEVEL, ut, j.dictionary), this._buffer = v.allocUnsafe(this._chunkSize), this._offset = 0, this._level = ct, this._strategy = ut, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: function() {
              return !tt._handle;
            }, configurable: !0, enumerable: !0 });
          }
          function K(j, Z) {
            Z && p.nextTick(Z), j._handle && (j._handle.close(), j._handle = null);
          }
          function D(j) {
            j.emit("close");
          }
          Object.defineProperty(c, "codes", { enumerable: !0, value: Object.freeze(T), writable: !1 }), c.Deflate = b, c.Inflate = k, c.Gzip = O, c.Gunzip = A, c.DeflateRaw = l, c.InflateRaw = E, c.Unzip = M, c.createDeflate = function(j) {
            return new b(j);
          }, c.createInflate = function(j) {
            return new k(j);
          }, c.createDeflateRaw = function(j) {
            return new l(j);
          }, c.createInflateRaw = function(j) {
            return new E(j);
          }, c.createGzip = function(j) {
            return new O(j);
          }, c.createGunzip = function(j) {
            return new A(j);
          }, c.createUnzip = function(j) {
            return new M(j);
          }, c.deflate = function(j, Z, tt) {
            return typeof Z == "function" && (tt = Z, Z = {}), S(new b(Z), j, tt);
          }, c.deflateSync = function(j, Z) {
            return d(new b(Z), j);
          }, c.gzip = function(j, Z, tt) {
            return typeof Z == "function" && (tt = Z, Z = {}), S(new O(Z), j, tt);
          }, c.gzipSync = function(j, Z) {
            return d(new O(Z), j);
          }, c.deflateRaw = function(j, Z, tt) {
            return typeof Z == "function" && (tt = Z, Z = {}), S(new l(Z), j, tt);
          }, c.deflateRawSync = function(j, Z) {
            return d(new l(Z), j);
          }, c.unzip = function(j, Z, tt) {
            return typeof Z == "function" && (tt = Z, Z = {}), S(new M(Z), j, tt);
          }, c.unzipSync = function(j, Z) {
            return d(new M(Z), j);
          }, c.inflate = function(j, Z, tt) {
            return typeof Z == "function" && (tt = Z, Z = {}), S(new k(Z), j, tt);
          }, c.inflateSync = function(j, Z) {
            return d(new k(Z), j);
          }, c.gunzip = function(j, Z, tt) {
            return typeof Z == "function" && (tt = Z, Z = {}), S(new A(Z), j, tt);
          }, c.gunzipSync = function(j, Z) {
            return d(new A(Z), j);
          }, c.inflateRaw = function(j, Z, tt) {
            return typeof Z == "function" && (tt = Z, Z = {}), S(new E(Z), j, tt);
          }, c.inflateRawSync = function(j, Z) {
            return d(new E(Z), j);
          }, s.inherits(X, n), X.prototype.params = function(j, Z, tt) {
            if (j < c.Z_MIN_LEVEL || j > c.Z_MAX_LEVEL)
              throw new RangeError("Invalid compression level: " + j);
            if (Z != c.Z_FILTERED && Z != c.Z_HUFFMAN_ONLY && Z != c.Z_RLE && Z != c.Z_FIXED && Z != c.Z_DEFAULT_STRATEGY)
              throw new TypeError("Invalid strategy: " + Z);
            if (this._level !== j || this._strategy !== Z) {
              var nt = this;
              this.flush(i.Z_SYNC_FLUSH, function() {
                r(nt._handle, "zlib binding closed"), nt._handle.params(j, Z), nt._hadError || (nt._level = j, nt._strategy = Z, tt && tt());
              });
            } else
              p.nextTick(tt);
          }, X.prototype.reset = function() {
            return r(this._handle, "zlib binding closed"), this._handle.reset();
          }, X.prototype._flush = function(j) {
            this._transform(v.alloc(0), "", j);
          }, X.prototype.flush = function(j, Z) {
            var tt = this, nt = this._writableState;
            (typeof j == "function" || j === void 0 && !Z) && (Z = j, j = i.Z_FULL_FLUSH), nt.ended ? Z && p.nextTick(Z) : nt.ending ? Z && this.once("end", Z) : nt.needDrain ? Z && this.once("drain", function() {
              return tt.flush(j, Z);
            }) : (this._flushFlag = j, this.write(v.alloc(0), "", Z));
          }, X.prototype.close = function(j) {
            K(this, j), p.nextTick(D, this);
          }, X.prototype._transform = function(j, Z, tt) {
            var nt, ct = this._writableState, ut = (ct.ending || ct.ended) && (!j || ct.length === j.length);
            return j === null || v.isBuffer(j) ? this._handle ? (ut ? nt = this._finishFlushFlag : (nt = this._flushFlag, j.length >= ct.length && (this._flushFlag = this._opts.flush || i.Z_NO_FLUSH)), void this._processChunk(j, nt, tt)) : tt(new Error("zlib binding closed")) : tt(new Error("invalid input"));
          }, X.prototype._processChunk = function(j, Z, tt) {
            var nt = j && j.length, ct = this._chunkSize - this._offset, ut = 0, V = this, ot = typeof tt == "function";
            if (!ot) {
              var xt, Ut = [], pt = 0;
              this.on("error", function(Pt) {
                xt = Pt;
              }), r(this._handle, "zlib binding closed");
              do
                var at = this._handle.writeSync(Z, j, ut, nt, this._buffer, this._offset, ct);
              while (!this._hadError && At(at[0], at[1]));
              if (this._hadError)
                throw xt;
              if (pt >= o)
                throw K(this), new RangeError(u);
              var bt = v.concat(Ut, pt);
              return K(this), bt;
            }
            r(this._handle, "zlib binding closed");
            var Q = this._handle.write(Z, j, ut, nt, this._buffer, this._offset, ct);
            function At(Pt, q) {
              if (this && (this.buffer = null, this.callback = null), !V._hadError) {
                var G = ct - q;
                if (r(G >= 0, "have should not go down"), G > 0) {
                  var lt = V._buffer.slice(V._offset, V._offset + G);
                  V._offset += G, ot ? V.push(lt) : (Ut.push(lt), pt += lt.length);
                }
                if ((q === 0 || V._offset >= V._chunkSize) && (ct = V._chunkSize, V._offset = 0, V._buffer = v.allocUnsafe(V._chunkSize)), q === 0) {
                  if (ut += nt - Pt, nt = Pt, !ot)
                    return !0;
                  var It = V._handle.write(Z, j, ut, nt, V._buffer, V._offset, V._chunkSize);
                  return It.callback = At, void (It.buffer = j);
                }
                if (!ot)
                  return !1;
                tt();
              }
            }
            Q.buffer = j, Q.callback = At;
          }, s.inherits(b, X), s.inherits(k, X), s.inherits(O, X), s.inherits(A, X), s.inherits(l, X), s.inherits(E, X), s.inherits(M, X);
        }).call(this);
      }).call(this, x("_process"));
    }, { "./binding": 43, _process: 158, assert: 36, buffer: 46, stream: 192, util: 238 }], 45: [function(x, C, c) {
    }, {}], 46: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = x("base64-js"), n = x("ieee754");
          c.Buffer = o, c.SlowBuffer = d, c.INSPECT_MAX_BYTES = 50;
          var i = 2147483647;
          function s() {
            try {
              var P = new Uint8Array(1);
              return P.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                return 42;
              } }, P.foo() === 42;
            } catch (U) {
              return !1;
            }
          }
          function r(P) {
            if (P > i)
              throw new RangeError('The value "' + P + '" is invalid for option "size"');
            var U = new Uint8Array(P);
            return U.__proto__ = o.prototype, U;
          }
          function o(P, U, rt) {
            if (typeof P == "number") {
              if (typeof U == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
              return y(P);
            }
            return u(P, U, rt);
          }
          function u(P, U, rt) {
            if (typeof P == "string")
              return T(P, U);
            if (ArrayBuffer.isView(P))
              return h(P);
            if (P == null)
              throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof P);
            if (H(P, ArrayBuffer) || P && H(P.buffer, ArrayBuffer))
              return _(P, U, rt);
            if (typeof P == "number")
              throw new TypeError('The "value" argument must not be of type number. Received type number');
            var ft = P.valueOf && P.valueOf();
            if (ft != null && ft !== P)
              return o.from(ft, U, rt);
            var Ot = g(P);
            if (Ot)
              return Ot;
            if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof P[Symbol.toPrimitive] == "function")
              return o.from(P[Symbol.toPrimitive]("string"), U, rt);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof P);
          }
          function a(P) {
            if (typeof P != "number")
              throw new TypeError('"size" argument must be of type number');
            if (P < 0)
              throw new RangeError('The value "' + P + '" is invalid for option "size"');
          }
          function f(P, U, rt) {
            return a(P), P <= 0 ? r(P) : U !== void 0 ? typeof rt == "string" ? r(P).fill(U, rt) : r(P).fill(U) : r(P);
          }
          function y(P) {
            return a(P), r(P < 0 ? 0 : 0 | S(P));
          }
          function T(P, U) {
            if (typeof U == "string" && U !== "" || (U = "utf8"), !o.isEncoding(U))
              throw new TypeError("Unknown encoding: " + U);
            var rt = 0 | b(P, U), ft = r(rt), Ot = ft.write(P, U);
            return Ot !== rt && (ft = ft.slice(0, Ot)), ft;
          }
          function h(P) {
            for (var U = P.length < 0 ? 0 : 0 | S(P.length), rt = r(U), ft = 0; ft < U; ft += 1)
              rt[ft] = 255 & P[ft];
            return rt;
          }
          function _(P, U, rt) {
            if (U < 0 || P.byteLength < U)
              throw new RangeError('"offset" is outside of buffer bounds');
            if (P.byteLength < U + (rt || 0))
              throw new RangeError('"length" is outside of buffer bounds');
            var ft;
            return (ft = U === void 0 && rt === void 0 ? new Uint8Array(P) : rt === void 0 ? new Uint8Array(P, U) : new Uint8Array(P, U, rt)).__proto__ = o.prototype, ft;
          }
          function g(P) {
            if (o.isBuffer(P)) {
              var U = 0 | S(P.length), rt = r(U);
              return rt.length === 0 || P.copy(rt, 0, 0, U), rt;
            }
            return P.length !== void 0 ? typeof P.length != "number" || F(P.length) ? r(0) : h(P) : P.type === "Buffer" && Array.isArray(P.data) ? h(P.data) : void 0;
          }
          function S(P) {
            if (P >= i)
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
            return 0 | P;
          }
          function d(P) {
            return +P != P && (P = 0), o.alloc(+P);
          }
          function b(P, U) {
            if (o.isBuffer(P))
              return P.length;
            if (ArrayBuffer.isView(P) || H(P, ArrayBuffer))
              return P.byteLength;
            if (typeof P != "string")
              throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof P);
            var rt = P.length, ft = arguments.length > 2 && arguments[2] === !0;
            if (!ft && rt === 0)
              return 0;
            for (var Ot = !1; ; )
              switch (U) {
                case "ascii":
                case "latin1":
                case "binary":
                  return rt;
                case "utf8":
                case "utf-8":
                  return q(P).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * rt;
                case "hex":
                  return rt >>> 1;
                case "base64":
                  return It(P).length;
                default:
                  if (Ot)
                    return ft ? -1 : q(P).length;
                  U = ("" + U).toLowerCase(), Ot = !0;
              }
          }
          function k(P, U, rt) {
            var ft = !1;
            if ((U === void 0 || U < 0) && (U = 0), U > this.length || ((rt === void 0 || rt > this.length) && (rt = this.length), rt <= 0) || (rt >>>= 0) <= (U >>>= 0))
              return "";
            for (P || (P = "utf8"); ; )
              switch (P) {
                case "hex":
                  return V(this, U, rt);
                case "utf8":
                case "utf-8":
                  return Z(this, U, rt);
                case "ascii":
                  return ct(this, U, rt);
                case "latin1":
                case "binary":
                  return ut(this, U, rt);
                case "base64":
                  return j(this, U, rt);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return ot(this, U, rt);
                default:
                  if (ft)
                    throw new TypeError("Unknown encoding: " + P);
                  P = (P + "").toLowerCase(), ft = !0;
              }
          }
          function O(P, U, rt) {
            var ft = P[U];
            P[U] = P[rt], P[rt] = ft;
          }
          function A(P, U, rt, ft, Ot) {
            if (P.length === 0)
              return -1;
            if (typeof rt == "string" ? (ft = rt, rt = 0) : rt > 2147483647 ? rt = 2147483647 : rt < -2147483648 && (rt = -2147483648), F(rt = +rt) && (rt = Ot ? 0 : P.length - 1), rt < 0 && (rt = P.length + rt), rt >= P.length) {
              if (Ot)
                return -1;
              rt = P.length - 1;
            } else if (rt < 0) {
              if (!Ot)
                return -1;
              rt = 0;
            }
            if (typeof U == "string" && (U = o.from(U, ft)), o.isBuffer(U))
              return U.length === 0 ? -1 : l(P, U, rt, ft, Ot);
            if (typeof U == "number")
              return U &= 255, typeof Uint8Array.prototype.indexOf == "function" ? Ot ? Uint8Array.prototype.indexOf.call(P, U, rt) : Uint8Array.prototype.lastIndexOf.call(P, U, rt) : l(P, [U], rt, ft, Ot);
            throw new TypeError("val must be string, number or Buffer");
          }
          function l(P, U, rt, ft, Ot) {
            var Wt, ce = 1, ye = P.length, ge = U.length;
            if (ft !== void 0 && ((ft = String(ft).toLowerCase()) === "ucs2" || ft === "ucs-2" || ft === "utf16le" || ft === "utf-16le")) {
              if (P.length < 2 || U.length < 2)
                return -1;
              ce = 2, ye /= 2, ge /= 2, rt /= 2;
            }
            function Ce($e, He) {
              return ce === 1 ? $e[He] : $e.readUInt16BE(He * ce);
            }
            if (Ot) {
              var _e = -1;
              for (Wt = rt; Wt < ye; Wt++)
                if (Ce(P, Wt) === Ce(U, _e === -1 ? 0 : Wt - _e)) {
                  if (_e === -1 && (_e = Wt), Wt - _e + 1 === ge)
                    return _e * ce;
                } else
                  _e !== -1 && (Wt -= Wt - _e), _e = -1;
            } else
              for (rt + ge > ye && (rt = ye - ge), Wt = rt; Wt >= 0; Wt--) {
                for (var je = !0, Ie = 0; Ie < ge; Ie++)
                  if (Ce(P, Wt + Ie) !== Ce(U, Ie)) {
                    je = !1;
                    break;
                  }
                if (je)
                  return Wt;
              }
            return -1;
          }
          function E(P, U, rt, ft) {
            rt = Number(rt) || 0;
            var Ot = P.length - rt;
            ft ? (ft = Number(ft)) > Ot && (ft = Ot) : ft = Ot;
            var Wt = U.length;
            ft > Wt / 2 && (ft = Wt / 2);
            for (var ce = 0; ce < ft; ++ce) {
              var ye = parseInt(U.substr(2 * ce, 2), 16);
              if (F(ye))
                return ce;
              P[rt + ce] = ye;
            }
            return ce;
          }
          function M(P, U, rt, ft) {
            return Ft(q(U, P.length - rt), P, rt, ft);
          }
          function B(P, U, rt, ft) {
            return Ft(G(U), P, rt, ft);
          }
          function X(P, U, rt, ft) {
            return B(P, U, rt, ft);
          }
          function K(P, U, rt, ft) {
            return Ft(It(U), P, rt, ft);
          }
          function D(P, U, rt, ft) {
            return Ft(lt(U, P.length - rt), P, rt, ft);
          }
          function j(P, U, rt) {
            return U === 0 && rt === P.length ? v.fromByteArray(P) : v.fromByteArray(P.slice(U, rt));
          }
          function Z(P, U, rt) {
            rt = Math.min(P.length, rt);
            for (var ft = [], Ot = U; Ot < rt; ) {
              var Wt, ce, ye, ge, Ce = P[Ot], _e = null, je = Ce > 239 ? 4 : Ce > 223 ? 3 : Ce > 191 ? 2 : 1;
              if (Ot + je <= rt)
                switch (je) {
                  case 1:
                    Ce < 128 && (_e = Ce);
                    break;
                  case 2:
                    (192 & (Wt = P[Ot + 1])) == 128 && (ge = (31 & Ce) << 6 | 63 & Wt) > 127 && (_e = ge);
                    break;
                  case 3:
                    Wt = P[Ot + 1], ce = P[Ot + 2], (192 & Wt) == 128 && (192 & ce) == 128 && (ge = (15 & Ce) << 12 | (63 & Wt) << 6 | 63 & ce) > 2047 && (ge < 55296 || ge > 57343) && (_e = ge);
                    break;
                  case 4:
                    Wt = P[Ot + 1], ce = P[Ot + 2], ye = P[Ot + 3], (192 & Wt) == 128 && (192 & ce) == 128 && (192 & ye) == 128 && (ge = (15 & Ce) << 18 | (63 & Wt) << 12 | (63 & ce) << 6 | 63 & ye) > 65535 && ge < 1114112 && (_e = ge);
                }
              _e === null ? (_e = 65533, je = 1) : _e > 65535 && (_e -= 65536, ft.push(_e >>> 10 & 1023 | 55296), _e = 56320 | 1023 & _e), ft.push(_e), Ot += je;
            }
            return nt(ft);
          }
          c.kMaxLength = i, o.TYPED_ARRAY_SUPPORT = s(), o.TYPED_ARRAY_SUPPORT || typeof console == "undefined" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(o.prototype, "parent", { enumerable: !0, get: function() {
            if (o.isBuffer(this))
              return this.buffer;
          } }), Object.defineProperty(o.prototype, "offset", { enumerable: !0, get: function() {
            if (o.isBuffer(this))
              return this.byteOffset;
          } }), typeof Symbol != "undefined" && Symbol.species != null && o[Symbol.species] === o && Object.defineProperty(o, Symbol.species, { value: null, configurable: !0, enumerable: !1, writable: !1 }), o.poolSize = 8192, o.from = function(P, U, rt) {
            return u(P, U, rt);
          }, o.prototype.__proto__ = Uint8Array.prototype, o.__proto__ = Uint8Array, o.alloc = function(P, U, rt) {
            return f(P, U, rt);
          }, o.allocUnsafe = function(P) {
            return y(P);
          }, o.allocUnsafeSlow = function(P) {
            return y(P);
          }, o.isBuffer = function(P) {
            return P != null && P._isBuffer === !0 && P !== o.prototype;
          }, o.compare = function(P, U) {
            if (H(P, Uint8Array) && (P = o.from(P, P.offset, P.byteLength)), H(U, Uint8Array) && (U = o.from(U, U.offset, U.byteLength)), !o.isBuffer(P) || !o.isBuffer(U))
              throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (P === U)
              return 0;
            for (var rt = P.length, ft = U.length, Ot = 0, Wt = Math.min(rt, ft); Ot < Wt; ++Ot)
              if (P[Ot] !== U[Ot]) {
                rt = P[Ot], ft = U[Ot];
                break;
              }
            return rt < ft ? -1 : ft < rt ? 1 : 0;
          }, o.isEncoding = function(P) {
            switch (String(P).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }, o.concat = function(P, U) {
            if (!Array.isArray(P))
              throw new TypeError('"list" argument must be an Array of Buffers');
            if (P.length === 0)
              return o.alloc(0);
            var rt;
            if (U === void 0)
              for (U = 0, rt = 0; rt < P.length; ++rt)
                U += P[rt].length;
            var ft = o.allocUnsafe(U), Ot = 0;
            for (rt = 0; rt < P.length; ++rt) {
              var Wt = P[rt];
              if (H(Wt, Uint8Array) && (Wt = o.from(Wt)), !o.isBuffer(Wt))
                throw new TypeError('"list" argument must be an Array of Buffers');
              Wt.copy(ft, Ot), Ot += Wt.length;
            }
            return ft;
          }, o.byteLength = b, o.prototype._isBuffer = !0, o.prototype.swap16 = function() {
            var P = this.length;
            if (P % 2 != 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var U = 0; U < P; U += 2)
              O(this, U, U + 1);
            return this;
          }, o.prototype.swap32 = function() {
            var P = this.length;
            if (P % 4 != 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var U = 0; U < P; U += 4)
              O(this, U, U + 3), O(this, U + 1, U + 2);
            return this;
          }, o.prototype.swap64 = function() {
            var P = this.length;
            if (P % 8 != 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var U = 0; U < P; U += 8)
              O(this, U, U + 7), O(this, U + 1, U + 6), O(this, U + 2, U + 5), O(this, U + 3, U + 4);
            return this;
          }, o.prototype.toString = function() {
            var P = this.length;
            return P === 0 ? "" : arguments.length === 0 ? Z(this, 0, P) : k.apply(this, arguments);
          }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(P) {
            if (!o.isBuffer(P))
              throw new TypeError("Argument must be a Buffer");
            return this === P || o.compare(this, P) === 0;
          }, o.prototype.inspect = function() {
            var P = "", U = c.INSPECT_MAX_BYTES;
            return P = this.toString("hex", 0, U).replace(/(.{2})/g, "$1 ").trim(), this.length > U && (P += " ... "), "<Buffer " + P + ">";
          }, o.prototype.compare = function(P, U, rt, ft, Ot) {
            if (H(P, Uint8Array) && (P = o.from(P, P.offset, P.byteLength)), !o.isBuffer(P))
              throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof P);
            if (U === void 0 && (U = 0), rt === void 0 && (rt = P ? P.length : 0), ft === void 0 && (ft = 0), Ot === void 0 && (Ot = this.length), U < 0 || rt > P.length || ft < 0 || Ot > this.length)
              throw new RangeError("out of range index");
            if (ft >= Ot && U >= rt)
              return 0;
            if (ft >= Ot)
              return -1;
            if (U >= rt)
              return 1;
            if (this === P)
              return 0;
            for (var Wt = (Ot >>>= 0) - (ft >>>= 0), ce = (rt >>>= 0) - (U >>>= 0), ye = Math.min(Wt, ce), ge = this.slice(ft, Ot), Ce = P.slice(U, rt), _e = 0; _e < ye; ++_e)
              if (ge[_e] !== Ce[_e]) {
                Wt = ge[_e], ce = Ce[_e];
                break;
              }
            return Wt < ce ? -1 : ce < Wt ? 1 : 0;
          }, o.prototype.includes = function(P, U, rt) {
            return this.indexOf(P, U, rt) !== -1;
          }, o.prototype.indexOf = function(P, U, rt) {
            return A(this, P, U, rt, !0);
          }, o.prototype.lastIndexOf = function(P, U, rt) {
            return A(this, P, U, rt, !1);
          }, o.prototype.write = function(P, U, rt, ft) {
            if (U === void 0)
              ft = "utf8", rt = this.length, U = 0;
            else if (rt === void 0 && typeof U == "string")
              ft = U, rt = this.length, U = 0;
            else {
              if (!isFinite(U))
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              U >>>= 0, isFinite(rt) ? (rt >>>= 0, ft === void 0 && (ft = "utf8")) : (ft = rt, rt = void 0);
            }
            var Ot = this.length - U;
            if ((rt === void 0 || rt > Ot) && (rt = Ot), P.length > 0 && (rt < 0 || U < 0) || U > this.length)
              throw new RangeError("Attempt to write outside buffer bounds");
            ft || (ft = "utf8");
            for (var Wt = !1; ; )
              switch (ft) {
                case "hex":
                  return E(this, P, U, rt);
                case "utf8":
                case "utf-8":
                  return M(this, P, U, rt);
                case "ascii":
                  return B(this, P, U, rt);
                case "latin1":
                case "binary":
                  return X(this, P, U, rt);
                case "base64":
                  return K(this, P, U, rt);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return D(this, P, U, rt);
                default:
                  if (Wt)
                    throw new TypeError("Unknown encoding: " + ft);
                  ft = ("" + ft).toLowerCase(), Wt = !0;
              }
          }, o.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          var tt = 4096;
          function nt(P) {
            var U = P.length;
            if (U <= tt)
              return String.fromCharCode.apply(String, P);
            for (var rt = "", ft = 0; ft < U; )
              rt += String.fromCharCode.apply(String, P.slice(ft, ft += tt));
            return rt;
          }
          function ct(P, U, rt) {
            var ft = "";
            rt = Math.min(P.length, rt);
            for (var Ot = U; Ot < rt; ++Ot)
              ft += String.fromCharCode(127 & P[Ot]);
            return ft;
          }
          function ut(P, U, rt) {
            var ft = "";
            rt = Math.min(P.length, rt);
            for (var Ot = U; Ot < rt; ++Ot)
              ft += String.fromCharCode(P[Ot]);
            return ft;
          }
          function V(P, U, rt) {
            var ft = P.length;
            (!U || U < 0) && (U = 0), (!rt || rt < 0 || rt > ft) && (rt = ft);
            for (var Ot = "", Wt = U; Wt < rt; ++Wt)
              Ot += Pt(P[Wt]);
            return Ot;
          }
          function ot(P, U, rt) {
            for (var ft = P.slice(U, rt), Ot = "", Wt = 0; Wt < ft.length; Wt += 2)
              Ot += String.fromCharCode(ft[Wt] + 256 * ft[Wt + 1]);
            return Ot;
          }
          function xt(P, U, rt) {
            if (P % 1 != 0 || P < 0)
              throw new RangeError("offset is not uint");
            if (P + U > rt)
              throw new RangeError("Trying to access beyond buffer length");
          }
          function Ut(P, U, rt, ft, Ot, Wt) {
            if (!o.isBuffer(P))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (U > Ot || U < Wt)
              throw new RangeError('"value" argument is out of bounds');
            if (rt + ft > P.length)
              throw new RangeError("Index out of range");
          }
          function pt(P, U, rt, ft, Ot, Wt) {
            if (rt + ft > P.length)
              throw new RangeError("Index out of range");
            if (rt < 0)
              throw new RangeError("Index out of range");
          }
          function at(P, U, rt, ft, Ot) {
            return U = +U, rt >>>= 0, Ot || pt(P, U, rt, 4), n.write(P, U, rt, ft, 23, 4), rt + 4;
          }
          function bt(P, U, rt, ft, Ot) {
            return U = +U, rt >>>= 0, Ot || pt(P, U, rt, 8), n.write(P, U, rt, ft, 52, 8), rt + 8;
          }
          o.prototype.slice = function(P, U) {
            var rt = this.length;
            (P = ~~P) < 0 ? (P += rt) < 0 && (P = 0) : P > rt && (P = rt), (U = U === void 0 ? rt : ~~U) < 0 ? (U += rt) < 0 && (U = 0) : U > rt && (U = rt), U < P && (U = P);
            var ft = this.subarray(P, U);
            return ft.__proto__ = o.prototype, ft;
          }, o.prototype.readUIntLE = function(P, U, rt) {
            P >>>= 0, U >>>= 0, rt || xt(P, U, this.length);
            for (var ft = this[P], Ot = 1, Wt = 0; ++Wt < U && (Ot *= 256); )
              ft += this[P + Wt] * Ot;
            return ft;
          }, o.prototype.readUIntBE = function(P, U, rt) {
            P >>>= 0, U >>>= 0, rt || xt(P, U, this.length);
            for (var ft = this[P + --U], Ot = 1; U > 0 && (Ot *= 256); )
              ft += this[P + --U] * Ot;
            return ft;
          }, o.prototype.readUInt8 = function(P, U) {
            return P >>>= 0, U || xt(P, 1, this.length), this[P];
          }, o.prototype.readUInt16LE = function(P, U) {
            return P >>>= 0, U || xt(P, 2, this.length), this[P] | this[P + 1] << 8;
          }, o.prototype.readUInt16BE = function(P, U) {
            return P >>>= 0, U || xt(P, 2, this.length), this[P] << 8 | this[P + 1];
          }, o.prototype.readUInt32LE = function(P, U) {
            return P >>>= 0, U || xt(P, 4, this.length), (this[P] | this[P + 1] << 8 | this[P + 2] << 16) + 16777216 * this[P + 3];
          }, o.prototype.readUInt32BE = function(P, U) {
            return P >>>= 0, U || xt(P, 4, this.length), 16777216 * this[P] + (this[P + 1] << 16 | this[P + 2] << 8 | this[P + 3]);
          }, o.prototype.readIntLE = function(P, U, rt) {
            P >>>= 0, U >>>= 0, rt || xt(P, U, this.length);
            for (var ft = this[P], Ot = 1, Wt = 0; ++Wt < U && (Ot *= 256); )
              ft += this[P + Wt] * Ot;
            return ft >= (Ot *= 128) && (ft -= Math.pow(2, 8 * U)), ft;
          }, o.prototype.readIntBE = function(P, U, rt) {
            P >>>= 0, U >>>= 0, rt || xt(P, U, this.length);
            for (var ft = U, Ot = 1, Wt = this[P + --ft]; ft > 0 && (Ot *= 256); )
              Wt += this[P + --ft] * Ot;
            return Wt >= (Ot *= 128) && (Wt -= Math.pow(2, 8 * U)), Wt;
          }, o.prototype.readInt8 = function(P, U) {
            return P >>>= 0, U || xt(P, 1, this.length), 128 & this[P] ? -1 * (255 - this[P] + 1) : this[P];
          }, o.prototype.readInt16LE = function(P, U) {
            P >>>= 0, U || xt(P, 2, this.length);
            var rt = this[P] | this[P + 1] << 8;
            return 32768 & rt ? 4294901760 | rt : rt;
          }, o.prototype.readInt16BE = function(P, U) {
            P >>>= 0, U || xt(P, 2, this.length);
            var rt = this[P + 1] | this[P] << 8;
            return 32768 & rt ? 4294901760 | rt : rt;
          }, o.prototype.readInt32LE = function(P, U) {
            return P >>>= 0, U || xt(P, 4, this.length), this[P] | this[P + 1] << 8 | this[P + 2] << 16 | this[P + 3] << 24;
          }, o.prototype.readInt32BE = function(P, U) {
            return P >>>= 0, U || xt(P, 4, this.length), this[P] << 24 | this[P + 1] << 16 | this[P + 2] << 8 | this[P + 3];
          }, o.prototype.readFloatLE = function(P, U) {
            return P >>>= 0, U || xt(P, 4, this.length), n.read(this, P, !0, 23, 4);
          }, o.prototype.readFloatBE = function(P, U) {
            return P >>>= 0, U || xt(P, 4, this.length), n.read(this, P, !1, 23, 4);
          }, o.prototype.readDoubleLE = function(P, U) {
            return P >>>= 0, U || xt(P, 8, this.length), n.read(this, P, !0, 52, 8);
          }, o.prototype.readDoubleBE = function(P, U) {
            return P >>>= 0, U || xt(P, 8, this.length), n.read(this, P, !1, 52, 8);
          }, o.prototype.writeUIntLE = function(P, U, rt, ft) {
            P = +P, U >>>= 0, rt >>>= 0, ft || Ut(this, P, U, rt, Math.pow(2, 8 * rt) - 1, 0);
            var Ot = 1, Wt = 0;
            for (this[U] = 255 & P; ++Wt < rt && (Ot *= 256); )
              this[U + Wt] = P / Ot & 255;
            return U + rt;
          }, o.prototype.writeUIntBE = function(P, U, rt, ft) {
            P = +P, U >>>= 0, rt >>>= 0, ft || Ut(this, P, U, rt, Math.pow(2, 8 * rt) - 1, 0);
            var Ot = rt - 1, Wt = 1;
            for (this[U + Ot] = 255 & P; --Ot >= 0 && (Wt *= 256); )
              this[U + Ot] = P / Wt & 255;
            return U + rt;
          }, o.prototype.writeUInt8 = function(P, U, rt) {
            return P = +P, U >>>= 0, rt || Ut(this, P, U, 1, 255, 0), this[U] = 255 & P, U + 1;
          }, o.prototype.writeUInt16LE = function(P, U, rt) {
            return P = +P, U >>>= 0, rt || Ut(this, P, U, 2, 65535, 0), this[U] = 255 & P, this[U + 1] = P >>> 8, U + 2;
          }, o.prototype.writeUInt16BE = function(P, U, rt) {
            return P = +P, U >>>= 0, rt || Ut(this, P, U, 2, 65535, 0), this[U] = P >>> 8, this[U + 1] = 255 & P, U + 2;
          }, o.prototype.writeUInt32LE = function(P, U, rt) {
            return P = +P, U >>>= 0, rt || Ut(this, P, U, 4, 4294967295, 0), this[U + 3] = P >>> 24, this[U + 2] = P >>> 16, this[U + 1] = P >>> 8, this[U] = 255 & P, U + 4;
          }, o.prototype.writeUInt32BE = function(P, U, rt) {
            return P = +P, U >>>= 0, rt || Ut(this, P, U, 4, 4294967295, 0), this[U] = P >>> 24, this[U + 1] = P >>> 16, this[U + 2] = P >>> 8, this[U + 3] = 255 & P, U + 4;
          }, o.prototype.writeIntLE = function(P, U, rt, ft) {
            if (P = +P, U >>>= 0, !ft) {
              var Ot = Math.pow(2, 8 * rt - 1);
              Ut(this, P, U, rt, Ot - 1, -Ot);
            }
            var Wt = 0, ce = 1, ye = 0;
            for (this[U] = 255 & P; ++Wt < rt && (ce *= 256); )
              P < 0 && ye === 0 && this[U + Wt - 1] !== 0 && (ye = 1), this[U + Wt] = (P / ce >> 0) - ye & 255;
            return U + rt;
          }, o.prototype.writeIntBE = function(P, U, rt, ft) {
            if (P = +P, U >>>= 0, !ft) {
              var Ot = Math.pow(2, 8 * rt - 1);
              Ut(this, P, U, rt, Ot - 1, -Ot);
            }
            var Wt = rt - 1, ce = 1, ye = 0;
            for (this[U + Wt] = 255 & P; --Wt >= 0 && (ce *= 256); )
              P < 0 && ye === 0 && this[U + Wt + 1] !== 0 && (ye = 1), this[U + Wt] = (P / ce >> 0) - ye & 255;
            return U + rt;
          }, o.prototype.writeInt8 = function(P, U, rt) {
            return P = +P, U >>>= 0, rt || Ut(this, P, U, 1, 127, -128), P < 0 && (P = 255 + P + 1), this[U] = 255 & P, U + 1;
          }, o.prototype.writeInt16LE = function(P, U, rt) {
            return P = +P, U >>>= 0, rt || Ut(this, P, U, 2, 32767, -32768), this[U] = 255 & P, this[U + 1] = P >>> 8, U + 2;
          }, o.prototype.writeInt16BE = function(P, U, rt) {
            return P = +P, U >>>= 0, rt || Ut(this, P, U, 2, 32767, -32768), this[U] = P >>> 8, this[U + 1] = 255 & P, U + 2;
          }, o.prototype.writeInt32LE = function(P, U, rt) {
            return P = +P, U >>>= 0, rt || Ut(this, P, U, 4, 2147483647, -2147483648), this[U] = 255 & P, this[U + 1] = P >>> 8, this[U + 2] = P >>> 16, this[U + 3] = P >>> 24, U + 4;
          }, o.prototype.writeInt32BE = function(P, U, rt) {
            return P = +P, U >>>= 0, rt || Ut(this, P, U, 4, 2147483647, -2147483648), P < 0 && (P = 4294967295 + P + 1), this[U] = P >>> 24, this[U + 1] = P >>> 16, this[U + 2] = P >>> 8, this[U + 3] = 255 & P, U + 4;
          }, o.prototype.writeFloatLE = function(P, U, rt) {
            return at(this, P, U, !0, rt);
          }, o.prototype.writeFloatBE = function(P, U, rt) {
            return at(this, P, U, !1, rt);
          }, o.prototype.writeDoubleLE = function(P, U, rt) {
            return bt(this, P, U, !0, rt);
          }, o.prototype.writeDoubleBE = function(P, U, rt) {
            return bt(this, P, U, !1, rt);
          }, o.prototype.copy = function(P, U, rt, ft) {
            if (!o.isBuffer(P))
              throw new TypeError("argument should be a Buffer");
            if (rt || (rt = 0), ft || ft === 0 || (ft = this.length), U >= P.length && (U = P.length), U || (U = 0), ft > 0 && ft < rt && (ft = rt), ft === rt || P.length === 0 || this.length === 0)
              return 0;
            if (U < 0)
              throw new RangeError("targetStart out of bounds");
            if (rt < 0 || rt >= this.length)
              throw new RangeError("Index out of range");
            if (ft < 0)
              throw new RangeError("sourceEnd out of bounds");
            ft > this.length && (ft = this.length), P.length - U < ft - rt && (ft = P.length - U + rt);
            var Ot = ft - rt;
            if (this === P && typeof Uint8Array.prototype.copyWithin == "function")
              this.copyWithin(U, rt, ft);
            else if (this === P && rt < U && U < ft)
              for (var Wt = Ot - 1; Wt >= 0; --Wt)
                P[Wt + U] = this[Wt + rt];
            else
              Uint8Array.prototype.set.call(P, this.subarray(rt, ft), U);
            return Ot;
          }, o.prototype.fill = function(P, U, rt, ft) {
            if (typeof P == "string") {
              if (typeof U == "string" ? (ft = U, U = 0, rt = this.length) : typeof rt == "string" && (ft = rt, rt = this.length), ft !== void 0 && typeof ft != "string")
                throw new TypeError("encoding must be a string");
              if (typeof ft == "string" && !o.isEncoding(ft))
                throw new TypeError("Unknown encoding: " + ft);
              if (P.length === 1) {
                var Ot = P.charCodeAt(0);
                (ft === "utf8" && Ot < 128 || ft === "latin1") && (P = Ot);
              }
            } else
              typeof P == "number" && (P &= 255);
            if (U < 0 || this.length < U || this.length < rt)
              throw new RangeError("Out of range index");
            if (rt <= U)
              return this;
            var Wt;
            if (U >>>= 0, rt = rt === void 0 ? this.length : rt >>> 0, P || (P = 0), typeof P == "number")
              for (Wt = U; Wt < rt; ++Wt)
                this[Wt] = P;
            else {
              var ce = o.isBuffer(P) ? P : o.from(P, ft), ye = ce.length;
              if (ye === 0)
                throw new TypeError('The value "' + P + '" is invalid for argument "value"');
              for (Wt = 0; Wt < rt - U; ++Wt)
                this[Wt + U] = ce[Wt % ye];
            }
            return this;
          };
          var Q = /[^+/0-9A-Za-z-_]/g;
          function At(P) {
            if ((P = (P = P.split("=")[0]).trim().replace(Q, "")).length < 2)
              return "";
            for (; P.length % 4 != 0; )
              P += "=";
            return P;
          }
          function Pt(P) {
            return P < 16 ? "0" + P.toString(16) : P.toString(16);
          }
          function q(P, U) {
            var rt;
            U = U || 1 / 0;
            for (var ft = P.length, Ot = null, Wt = [], ce = 0; ce < ft; ++ce) {
              if ((rt = P.charCodeAt(ce)) > 55295 && rt < 57344) {
                if (!Ot) {
                  if (rt > 56319) {
                    (U -= 3) > -1 && Wt.push(239, 191, 189);
                    continue;
                  }
                  if (ce + 1 === ft) {
                    (U -= 3) > -1 && Wt.push(239, 191, 189);
                    continue;
                  }
                  Ot = rt;
                  continue;
                }
                if (rt < 56320) {
                  (U -= 3) > -1 && Wt.push(239, 191, 189), Ot = rt;
                  continue;
                }
                rt = 65536 + (Ot - 55296 << 10 | rt - 56320);
              } else
                Ot && (U -= 3) > -1 && Wt.push(239, 191, 189);
              if (Ot = null, rt < 128) {
                if ((U -= 1) < 0)
                  break;
                Wt.push(rt);
              } else if (rt < 2048) {
                if ((U -= 2) < 0)
                  break;
                Wt.push(rt >> 6 | 192, 63 & rt | 128);
              } else if (rt < 65536) {
                if ((U -= 3) < 0)
                  break;
                Wt.push(rt >> 12 | 224, rt >> 6 & 63 | 128, 63 & rt | 128);
              } else {
                if (!(rt < 1114112))
                  throw new Error("Invalid code point");
                if ((U -= 4) < 0)
                  break;
                Wt.push(rt >> 18 | 240, rt >> 12 & 63 | 128, rt >> 6 & 63 | 128, 63 & rt | 128);
              }
            }
            return Wt;
          }
          function G(P) {
            for (var U = [], rt = 0; rt < P.length; ++rt)
              U.push(255 & P.charCodeAt(rt));
            return U;
          }
          function lt(P, U) {
            for (var rt, ft, Ot, Wt = [], ce = 0; ce < P.length && !((U -= 2) < 0); ++ce)
              ft = (rt = P.charCodeAt(ce)) >> 8, Ot = rt % 256, Wt.push(Ot), Wt.push(ft);
            return Wt;
          }
          function It(P) {
            return v.toByteArray(At(P));
          }
          function Ft(P, U, rt, ft) {
            for (var Ot = 0; Ot < ft && !(Ot + rt >= U.length || Ot >= P.length); ++Ot)
              U[Ot + rt] = P[Ot];
            return Ot;
          }
          function H(P, U) {
            return P instanceof U || P != null && P.constructor != null && P.constructor.name != null && P.constructor.name === U.name;
          }
          function F(P) {
            return P != P;
          }
        }).call(this);
      }).call(this, x("buffer").Buffer);
    }, { "base64-js": 41, buffer: 46, ieee754: 109 }], 47: [function(x, C, c) {
      C.exports = { 100: "Continue", 101: "Switching Protocols", 102: "Processing", 200: "OK", 201: "Created", 202: "Accepted", 203: "Non-Authoritative Information", 204: "No Content", 205: "Reset Content", 206: "Partial Content", 207: "Multi-Status", 208: "Already Reported", 226: "IM Used", 300: "Multiple Choices", 301: "Moved Permanently", 302: "Found", 303: "See Other", 304: "Not Modified", 305: "Use Proxy", 307: "Temporary Redirect", 308: "Permanent Redirect", 400: "Bad Request", 401: "Unauthorized", 402: "Payment Required", 403: "Forbidden", 404: "Not Found", 405: "Method Not Allowed", 406: "Not Acceptable", 407: "Proxy Authentication Required", 408: "Request Timeout", 409: "Conflict", 410: "Gone", 411: "Length Required", 412: "Precondition Failed", 413: "Payload Too Large", 414: "URI Too Long", 415: "Unsupported Media Type", 416: "Range Not Satisfiable", 417: "Expectation Failed", 418: "I'm a teapot", 421: "Misdirected Request", 422: "Unprocessable Entity", 423: "Locked", 424: "Failed Dependency", 425: "Unordered Collection", 426: "Upgrade Required", 428: "Precondition Required", 429: "Too Many Requests", 431: "Request Header Fields Too Large", 451: "Unavailable For Legal Reasons", 500: "Internal Server Error", 501: "Not Implemented", 502: "Bad Gateway", 503: "Service Unavailable", 504: "Gateway Timeout", 505: "HTTP Version Not Supported", 506: "Variant Also Negotiates", 507: "Insufficient Storage", 508: "Loop Detected", 509: "Bandwidth Limit Exceeded", 510: "Not Extended", 511: "Network Authentication Required" };
    }, {}], 48: [function(x, C, c) {
      var p = x("get-intrinsic"), v = x("./"), n = v(p("String.prototype.indexOf"));
      C.exports = function(i, s) {
        var r = p(i, !!s);
        return typeof r == "function" && n(i, ".prototype.") > -1 ? v(r) : r;
      };
    }, { "./": 49, "get-intrinsic": 101 }], 49: [function(x, C, c) {
      var p = x("function-bind"), v = x("get-intrinsic"), n = v("%Function.prototype.apply%"), i = v("%Function.prototype.call%"), s = v("%Reflect.apply%", !0) || p.call(i, n), r = v("%Object.getOwnPropertyDescriptor%", !0), o = v("%Object.defineProperty%", !0), u = v("%Math.max%");
      if (o)
        try {
          o({}, "a", { value: 1 });
        } catch (f) {
          o = null;
        }
      C.exports = function(f) {
        var y = s(p, i, arguments);
        return r && o && r(y, "length").configurable && o(y, "length", { value: 1 + u(0, f.length - (arguments.length - 1)) }), y;
      };
      var a = function() {
        return s(p, n, arguments);
      };
      o ? o(C.exports, "apply", { value: a }) : C.exports.apply = a;
    }, { "function-bind": 99, "get-intrinsic": 101 }], 50: [function(x, C, c) {
      var p = x("object-keys"), v = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", n = Object.prototype.toString, i = Array.prototype.concat, s = Object.defineProperty, r = function(y) {
        return typeof y == "function" && n.call(y) === "[object Function]";
      }, o = x("has-property-descriptors")(), u = s && o, a = function(y, T, h, _) {
        (!(T in y) || r(_) && _()) && (u ? s(y, T, { configurable: !0, enumerable: !1, value: h, writable: !0 }) : y[T] = h);
      }, f = function(y, T) {
        var h = arguments.length > 2 ? arguments[2] : {}, _ = p(T);
        v && (_ = i.call(_, Object.getOwnPropertySymbols(T)));
        for (var g = 0; g < _.length; g += 1)
          a(y, _[g], T[_[g]], h[_[g]]);
      };
      f.supportsDescriptors = !!u, C.exports = f;
    }, { "has-property-descriptors": 103, "object-keys": 138 }], 51: [function(require, module, exports) {
      const Util = require("util");
      var Template = require("lodash.template");
      function eraro(x) {
        var C = (x = x || {}).prefix === !1 ? "" : typeof x.prefix == "string" ? x.prefix : typeof x.package == "string" ? x.package + ": " : "", c = x.package || "unknown", p = x.module || module, v = x.msgmap || {}, n = x.inspect == null || !!x.inspect, i = [module.filename], s = p.filename;
        s && i.push(s);
        var r = function(o, u, a, f) {
          if (Util.isError(o)) {
            if (o.eraro && !x.override)
              return o;
          } else
            o = null, u = arguments[0], a = arguments[1], f = arguments[2];
          u = typeof u == "string" ? u : o ? o.code ? o.code : o.message ? o.message : "unknown" : "unknown", f = typeof f == "object" ? f : typeof a == "object" && typeof a != "string" ? a : {}, o && (f.errmsg = o.message, f.errline = callpoint(o, i)), a = buildmessage(x, a = typeof a == "string" ? a : null, v, C, n, u, f, o);
          var y = new Error(a);
          if (o)
            for (var T in f.orig$ = f.orig$ == null ? o : f.orig$, f.message$ = f.message$ == null ? o.message : f.message$, o)
              y[T] = o[T];
          return y.eraro = !0, y.orig = o, y.code = u, y[c] = !0, y.package = c, y.msg = a, y.details = f, y.stack = o ? o.stack : y.stack, y.callpoint = f.errline || callpoint(y, i), y;
        };
        return r.callpoint = callpoint, r.has = function(o) {
          return !!v[o];
        }, r;
      }
      function callpoint(x, C) {
        C = Array.isArray(C) ? C : [];
        var c = x ? x.stack : null, p = "";
        if (c) {
          var v, n = c.split(`
`);
          t:
            for (v = 1; v < n.length; v++) {
              for (var i = n[v], s = !1, r = 0; r < C.length && (typeof C[r] != "string" || !(s = i.indexOf(C[r]) != -1)); r++)
                ;
              if (!s)
                break t;
            }
          p = typeof n[v] == "string" ? n[v].substring(4) : p;
        }
        return p;
      }
      function buildmessage(options, msg, msgmap, msgprefix, inspect, code, details, ex) {
        var message = msgprefix + (typeof msg == "string" ? msg : typeof msgmap[code] == "string" ? msgmap[code] : ex ? originalmsg(options.override, ex) : code), valmap = Object.assign({}, details, { code }), valstrmap = { util: Util };
        Object.entries(valmap).forEach(function(entry) {
          var key = entry[0], val = entry[1];
          try {
            eval("var " + key + ";");
          } catch (x) {
            key += "$";
          }
          ({ undefined: 1, NaN: 1 })[key] && (key += "$"), valstrmap[key] = inspect && typeof val != "string" ? Util.inspect(val) : val;
        });
        for (var done = !1; !done; )
          try {
            var tm = Template(message);
            message = tm(valstrmap), done = !0;
          } catch (x) {
            if (x instanceof ReferenceError) {
              var m = /ReferenceError:\s+(.*?)\s+/.exec(x.toString());
              m && m[1] ? valstrmap[m[1]] = "[" + m[1] + "?]" : done = !0;
            } else
              done = !0, message = message + " VALUES:" + Util.inspect(valmap, { depth: 2 }) + " TEMPLATE ERROR: " + x;
          }
        return message;
      }
      function originalmsg(x, C) {
        if (C)
          return x && C.eraro && C.orig ? C.orig.message : C.message;
      }
      module.exports = eraro;
    }, { "lodash.template": 127, util: 238 }], 52: [function(x, C, c) {
      var p = x("get-intrinsic"), v = x("call-bind/callBound"), n = p("%TypeError%"), i = x("./IsArray"), s = p("%Reflect.apply%", !0) || v("%Function.prototype.apply%");
      C.exports = function(r, o) {
        var u = arguments.length > 2 ? arguments[2] : [];
        if (!i(u))
          throw new n("Assertion failed: optional `argumentsList`, if provided, must be a List");
        return s(r, o, u);
      };
    }, { "./IsArray": 57, "call-bind/callBound": 48, "get-intrinsic": 101 }], 53: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%TypeError%"), n = x("../helpers/DefineOwnProperty"), i = x("./FromPropertyDescriptor"), s = x("./OrdinaryGetOwnProperty"), r = x("./IsDataDescriptor"), o = x("./IsExtensible"), u = x("./IsPropertyKey"), a = x("./SameValue"), f = x("./Type");
      C.exports = function(y, T, h) {
        if (f(y) !== "Object")
          throw new v("Assertion failed: Type(O) is not Object");
        if (!u(T))
          throw new v("Assertion failed: IsPropertyKey(P) is not true");
        var _ = s(y, T), g = !_ || o(y);
        return !(_ && !_["[[Configurable]]"] || !g) && n(r, a, i, y, T, { "[[Configurable]]": !0, "[[Enumerable]]": !0, "[[Value]]": h, "[[Writable]]": !0 });
      };
    }, { "../helpers/DefineOwnProperty": 80, "./FromPropertyDescriptor": 54, "./IsDataDescriptor": 59, "./IsExtensible": 60, "./IsPropertyKey": 61, "./OrdinaryGetOwnProperty": 64, "./SameValue": 66, "./Type": 75, "get-intrinsic": 101 }], 54: [function(x, C, c) {
      var p = x("../helpers/assertRecord"), v = x("../helpers/fromPropertyDescriptor"), n = x("./Type");
      C.exports = function(i) {
        return i !== void 0 && p(n, "Property Descriptor", "Desc", i), v(i);
      };
    }, { "../helpers/assertRecord": 82, "../helpers/fromPropertyDescriptor": 83, "./Type": 75 }], 55: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%TypeError%"), n = x("object-inspect"), i = x("./IsPropertyKey"), s = x("./Type");
      C.exports = function(r, o) {
        if (s(r) !== "Object")
          throw new v("Assertion failed: Type(O) is not Object");
        if (!i(o))
          throw new v("Assertion failed: IsPropertyKey(P) is not true, got " + n(o));
        return r[o];
      };
    }, { "./IsPropertyKey": 61, "./Type": 75, "get-intrinsic": 101, "object-inspect": 136 }], 56: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%TypeError%"), n = x("./IsPropertyKey"), i = x("./Type");
      C.exports = function(s, r) {
        if (i(s) !== "Object")
          throw new v("Assertion failed: `O` must be an Object");
        if (!n(r))
          throw new v("Assertion failed: `P` must be a Property Key");
        return r in s;
      };
    }, { "./IsPropertyKey": 61, "./Type": 75, "get-intrinsic": 101 }], 57: [function(x, C, c) {
      C.exports = x("../helpers/IsArray");
    }, { "../helpers/IsArray": 81 }], 58: [function(x, C, c) {
      C.exports = x("is-callable");
    }, { "is-callable": 112 }], 59: [function(x, C, c) {
      var p = x("has"), v = x("../helpers/assertRecord"), n = x("./Type");
      C.exports = function(i) {
        return i !== void 0 && (v(n, "Property Descriptor", "Desc", i), !(!p(i, "[[Value]]") && !p(i, "[[Writable]]")));
      };
    }, { "../helpers/assertRecord": 82, "./Type": 75, has: 107 }], 60: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%Object.preventExtensions%", !0), n = p("%Object.isExtensible%", !0), i = x("../helpers/isPrimitive");
      C.exports = v ? function(s) {
        return !i(s) && n(s);
      } : function(s) {
        return !i(s);
      };
    }, { "../helpers/isPrimitive": 88, "get-intrinsic": 101 }], 61: [function(x, C, c) {
      C.exports = function(p) {
        return typeof p == "string" || typeof p == "symbol";
      };
    }, {}], 62: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%Symbol.match%", !0), n = x("is-regex"), i = x("./ToBoolean");
      C.exports = function(s) {
        if (!s || typeof s != "object")
          return !1;
        if (v) {
          var r = s[v];
          if (r !== void 0)
            return i(r);
        }
        return n(s);
      };
    }, { "./ToBoolean": 67, "get-intrinsic": 101, "is-regex": 115 }], 63: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%TypeError%"), n = x("./Get"), i = x("./ToLength"), s = x("./Type");
      C.exports = function(r) {
        if (s(r) !== "Object")
          throw new v("Assertion failed: `obj` must be an Object");
        return i(n(r, "length"));
      };
    }, { "./Get": 55, "./ToLength": 69, "./Type": 75, "get-intrinsic": 101 }], 64: [function(x, C, c) {
      var p = x("get-intrinsic"), v = x("../helpers/getOwnPropertyDescriptor"), n = p("%TypeError%"), i = x("call-bind/callBound"), s = i("Object.prototype.propertyIsEnumerable"), r = x("has"), o = x("./IsArray"), u = x("./IsPropertyKey"), a = x("./IsRegExp"), f = x("./ToPropertyDescriptor"), y = x("./Type");
      C.exports = function(T, h) {
        if (y(T) !== "Object")
          throw new n("Assertion failed: O must be an Object");
        if (!u(h))
          throw new n("Assertion failed: P must be a Property Key");
        if (r(T, h)) {
          if (!v) {
            var _ = o(T) && h === "length", g = a(T) && h === "lastIndex";
            return { "[[Configurable]]": !(_ || g), "[[Enumerable]]": s(T, h), "[[Value]]": T[h], "[[Writable]]": !0 };
          }
          return f(v(T, h));
        }
      };
    }, { "../helpers/getOwnPropertyDescriptor": 84, "./IsArray": 57, "./IsPropertyKey": 61, "./IsRegExp": 62, "./ToPropertyDescriptor": 73, "./Type": 75, "call-bind/callBound": 48, "get-intrinsic": 101, has: 107 }], 65: [function(x, C, c) {
      C.exports = x("../5/CheckObjectCoercible");
    }, { "../5/CheckObjectCoercible": 78 }], 66: [function(x, C, c) {
      var p = x("../helpers/isNaN");
      C.exports = function(v, n) {
        return v === n ? v !== 0 || 1 / v == 1 / n : p(v) && p(n);
      };
    }, { "../helpers/isNaN": 87 }], 67: [function(x, C, c) {
      C.exports = function(p) {
        return !!p;
      };
    }, {}], 68: [function(x, C, c) {
      var p = x("./abs"), v = x("./floor"), n = x("./ToNumber"), i = x("../helpers/isNaN"), s = x("../helpers/isFinite"), r = x("../helpers/sign");
      C.exports = function(o) {
        var u = n(o);
        return i(u) || u === 0 ? 0 : s(u) ? r(u) * v(p(u)) : u;
      };
    }, { "../helpers/isFinite": 85, "../helpers/isNaN": 87, "../helpers/sign": 91, "./ToNumber": 70, "./abs": 76, "./floor": 77 }], 69: [function(x, C, c) {
      var p = x("../helpers/maxSafeInteger"), v = x("./ToIntegerOrInfinity");
      C.exports = function(n) {
        var i = v(n);
        return i <= 0 ? 0 : i > p ? p : i;
      };
    }, { "../helpers/maxSafeInteger": 89, "./ToIntegerOrInfinity": 68 }], 70: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%TypeError%"), n = p("%Number%"), i = p("%RegExp%"), s = p("%parseInt%"), r = x("call-bind/callBound"), o = x("../helpers/regexTester"), u = x("../helpers/isPrimitive"), a = r("String.prototype.slice"), f = o(/^0b[01]+$/i), y = o(/^0o[0-7]+$/i), T = o(/^[-+]0x[0-9a-f]+$/i), h = ["", "​", "￾"].join(""), _ = new i("[" + h + "]", "g"), g = o(_), S = [`	
\v\f\r   ᠎    `, "         　\u2028", "\u2029\uFEFF"].join(""), d = new RegExp("(^[" + S + "]+)|([" + S + "]+$)", "g"), b = r("String.prototype.replace"), k = function(A) {
        return b(A, d, "");
      }, O = x("./ToPrimitive");
      C.exports = function A(l) {
        var E = u(l) ? l : O(l, n);
        if (typeof E == "symbol")
          throw new v("Cannot convert a Symbol value to a number");
        if (typeof E == "bigint")
          throw new v("Conversion from 'BigInt' to 'number' is not allowed.");
        if (typeof E == "string") {
          if (f(E))
            return A(s(a(E, 2), 2));
          if (y(E))
            return A(s(a(E, 2), 8));
          if (g(E) || T(E))
            return NaN;
          var M = k(E);
          if (M !== E)
            return A(M);
        }
        return n(E);
      };
    }, { "../helpers/isPrimitive": 88, "../helpers/regexTester": 90, "./ToPrimitive": 72, "call-bind/callBound": 48, "get-intrinsic": 101 }], 71: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%Object%"), n = x("./RequireObjectCoercible");
      C.exports = function(i) {
        return n(i), v(i);
      };
    }, { "./RequireObjectCoercible": 65, "get-intrinsic": 101 }], 72: [function(x, C, c) {
      var p = x("es-to-primitive/es2015");
      C.exports = function(v) {
        return arguments.length > 1 ? p(v, arguments[1]) : p(v);
      };
    }, { "es-to-primitive/es2015": 93 }], 73: [function(x, C, c) {
      var p = x("has"), v = x("get-intrinsic"), n = v("%TypeError%"), i = x("./Type"), s = x("./ToBoolean"), r = x("./IsCallable");
      C.exports = function(o) {
        if (i(o) !== "Object")
          throw new n("ToPropertyDescriptor requires an object");
        var u = {};
        if (p(o, "enumerable") && (u["[[Enumerable]]"] = s(o.enumerable)), p(o, "configurable") && (u["[[Configurable]]"] = s(o.configurable)), p(o, "value") && (u["[[Value]]"] = o.value), p(o, "writable") && (u["[[Writable]]"] = s(o.writable)), p(o, "get")) {
          var a = o.get;
          if (a !== void 0 && !r(a))
            throw new n("getter must be a function");
          u["[[Get]]"] = a;
        }
        if (p(o, "set")) {
          var f = o.set;
          if (f !== void 0 && !r(f))
            throw new n("setter must be a function");
          u["[[Set]]"] = f;
        }
        if ((p(u, "[[Get]]") || p(u, "[[Set]]")) && (p(u, "[[Value]]") || p(u, "[[Writable]]")))
          throw new n("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
        return u;
      };
    }, { "./IsCallable": 58, "./ToBoolean": 67, "./Type": 75, "get-intrinsic": 101, has: 107 }], 74: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%String%"), n = p("%TypeError%");
      C.exports = function(i) {
        if (typeof i == "symbol")
          throw new n("Cannot convert a Symbol value to a string");
        return v(i);
      };
    }, { "get-intrinsic": 101 }], 75: [function(x, C, c) {
      var p = x("../5/Type");
      C.exports = function(v) {
        return typeof v == "symbol" ? "Symbol" : typeof v == "bigint" ? "BigInt" : p(v);
      };
    }, { "../5/Type": 79 }], 76: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%Math.abs%");
      C.exports = function(n) {
        return v(n);
      };
    }, { "get-intrinsic": 101 }], 77: [function(x, C, c) {
      var p = Math.floor;
      C.exports = function(v) {
        return p(v);
      };
    }, {}], 78: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%TypeError%");
      C.exports = function(n, i) {
        if (n == null)
          throw new v(i || "Cannot call method on " + n);
        return n;
      };
    }, { "get-intrinsic": 101 }], 79: [function(x, C, c) {
      C.exports = function(p) {
        return p === null ? "Null" : p === void 0 ? "Undefined" : typeof p == "function" || typeof p == "object" ? "Object" : typeof p == "number" ? "Number" : typeof p == "boolean" ? "Boolean" : typeof p == "string" ? "String" : void 0;
      };
    }, {}], 80: [function(x, C, c) {
      var p = x("has-property-descriptors"), v = x("get-intrinsic"), n = p() && v("%Object.defineProperty%", !0), i = p.hasArrayLengthDefineBug(), s = i && x("../helpers/IsArray"), r = x("call-bind/callBound"), o = r("Object.prototype.propertyIsEnumerable");
      C.exports = function(u, a, f, y, T, h) {
        if (!n) {
          if (!u(h) || !h["[[Configurable]]"] || !h["[[Writable]]"] || T in y && o(y, T) !== !!h["[[Enumerable]]"])
            return !1;
          var _ = h["[[Value]]"];
          return y[T] = _, a(y[T], _);
        }
        return i && T === "length" && "[[Value]]" in h && s(y) && y.length !== h["[[Value]]"] ? (y.length = h["[[Value]]"], y.length === h["[[Value]]"]) : (n(y, T, f(h)), !0);
      };
    }, { "../helpers/IsArray": 81, "call-bind/callBound": 48, "get-intrinsic": 101, "has-property-descriptors": 103 }], 81: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%Array%"), n = !v.isArray && x("call-bind/callBound")("Object.prototype.toString");
      C.exports = v.isArray || function(i) {
        return n(i) === "[object Array]";
      };
    }, { "call-bind/callBound": 48, "get-intrinsic": 101 }], 82: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%TypeError%"), n = p("%SyntaxError%"), i = x("has"), s = x("./isMatchRecord"), r = { "Property Descriptor": function(o) {
        var u = { "[[Configurable]]": !0, "[[Enumerable]]": !0, "[[Get]]": !0, "[[Set]]": !0, "[[Value]]": !0, "[[Writable]]": !0 };
        for (var a in o)
          if (i(o, a) && !u[a])
            return !1;
        var f = i(o, "[[Value]]"), y = i(o, "[[Get]]") || i(o, "[[Set]]");
        if (f && y)
          throw new v("Property Descriptors may not be both accessor and data descriptors");
        return !0;
      }, "Match Record": s };
      C.exports = function(o, u, a, f) {
        var y = r[u];
        if (typeof y != "function")
          throw new n("unknown record type: " + u);
        if (o(f) !== "Object" || !y(f))
          throw new v(a + " must be a " + u);
      };
    }, { "./isMatchRecord": 86, "get-intrinsic": 101, has: 107 }], 83: [function(x, C, c) {
      C.exports = function(p) {
        if (p === void 0)
          return p;
        var v = {};
        return "[[Value]]" in p && (v.value = p["[[Value]]"]), "[[Writable]]" in p && (v.writable = !!p["[[Writable]]"]), "[[Get]]" in p && (v.get = p["[[Get]]"]), "[[Set]]" in p && (v.set = p["[[Set]]"]), "[[Enumerable]]" in p && (v.enumerable = !!p["[[Enumerable]]"]), "[[Configurable]]" in p && (v.configurable = !!p["[[Configurable]]"]), v;
      };
    }, {}], 84: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%Object.getOwnPropertyDescriptor%", !0);
      if (v)
        try {
          v([], "length");
        } catch (n) {
          v = null;
        }
      C.exports = v;
    }, { "get-intrinsic": 101 }], 85: [function(x, C, c) {
      var p = Number.isNaN || function(v) {
        return v != v;
      };
      C.exports = Number.isFinite || function(v) {
        return typeof v == "number" && !p(v) && v !== 1 / 0 && v !== -1 / 0;
      };
    }, {}], 86: [function(x, C, c) {
      var p = x("has");
      C.exports = function(v) {
        return p(v, "[[StartIndex]]") && p(v, "[[EndIndex]]") && v["[[StartIndex]]"] >= 0 && v["[[EndIndex]]"] >= v["[[StartIndex]]"] && String(parseInt(v["[[StartIndex]]"], 10)) === String(v["[[StartIndex]]"]) && String(parseInt(v["[[EndIndex]]"], 10)) === String(v["[[EndIndex]]"]);
      };
    }, { has: 107 }], 87: [function(x, C, c) {
      C.exports = Number.isNaN || function(p) {
        return p != p;
      };
    }, {}], 88: [function(x, C, c) {
      C.exports = function(p) {
        return p === null || typeof p != "function" && typeof p != "object";
      };
    }, {}], 89: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%Math%"), n = p("%Number%");
      C.exports = n.MAX_SAFE_INTEGER || v.pow(2, 53) - 1;
    }, { "get-intrinsic": 101 }], 90: [function(x, C, c) {
      var p = x("call-bind/callBound"), v = p("RegExp.prototype.exec");
      C.exports = function(n) {
        return function(i) {
          return v(n, i) !== null;
        };
      };
    }, { "call-bind/callBound": 48 }], 91: [function(x, C, c) {
      C.exports = function(p) {
        return p >= 0 ? 1 : -1;
      };
    }, {}], 92: [function(x, C, c) {
      C.exports = function(p) {
        var v = !0, n = !0, i = !1;
        if (typeof p == "function") {
          try {
            p.call("f", function(s, r, o) {
              typeof o != "object" && (v = !1);
            }), p.call([null], function() {
              "use strict";
              n = typeof this == "string";
            }, "x");
          } catch (s) {
            i = !0;
          }
          return !i && v && n;
        }
        return !1;
      };
    }, {}], 93: [function(x, C, c) {
      var p = typeof Symbol == "function" && typeof Symbol.iterator == "symbol", v = x("./helpers/isPrimitive"), n = x("is-callable"), i = x("is-date-object"), s = x("is-symbol"), r = function(u, a) {
        if (u == null)
          throw new TypeError("Cannot call method on " + u);
        if (typeof a != "string" || a !== "number" && a !== "string")
          throw new TypeError('hint must be "string" or "number"');
        var f, y, T, h = a === "string" ? ["toString", "valueOf"] : ["valueOf", "toString"];
        for (T = 0; T < h.length; ++T)
          if (f = u[h[T]], n(f) && (y = f.call(u), v(y)))
            return y;
        throw new TypeError("No default value");
      }, o = function(u, a) {
        var f = u[a];
        if (f != null) {
          if (!n(f))
            throw new TypeError(f + " returned for property " + a + " of object " + u + " is not a function");
          return f;
        }
      };
      C.exports = function(u) {
        if (v(u))
          return u;
        var a, f = "default";
        if (arguments.length > 1 && (arguments[1] === String ? f = "string" : arguments[1] === Number && (f = "number")), p && (Symbol.toPrimitive ? a = o(u, Symbol.toPrimitive) : s(u) && (a = Symbol.prototype.valueOf)), a !== void 0) {
          var y = a.call(u, f);
          if (v(y))
            return y;
          throw new TypeError("unable to convert exotic object to primitive");
        }
        return f === "default" && (i(u) || s(u)) && (f = "string"), r(u, f === "default" ? "number" : f);
      };
    }, { "./helpers/isPrimitive": 94, "is-callable": 112, "is-date-object": 113, "is-symbol": 117 }], 94: [function(x, C, c) {
      C.exports = function(p) {
        return p === null || typeof p != "function" && typeof p != "object";
      };
    }, {}], 95: [function(x, C, c) {
      var p, v = typeof Reflect == "object" ? Reflect : null, n = v && typeof v.apply == "function" ? v.apply : function(A, l, E) {
        return Function.prototype.apply.call(A, l, E);
      };
      function i(A) {
        console && console.warn && console.warn(A);
      }
      p = v && typeof v.ownKeys == "function" ? v.ownKeys : Object.getOwnPropertySymbols ? function(A) {
        return Object.getOwnPropertyNames(A).concat(Object.getOwnPropertySymbols(A));
      } : function(A) {
        return Object.getOwnPropertyNames(A);
      };
      var s = Number.isNaN || function(A) {
        return A != A;
      };
      function r() {
        r.init.call(this);
      }
      C.exports = r, C.exports.once = b, r.EventEmitter = r, r.prototype._events = void 0, r.prototype._eventsCount = 0, r.prototype._maxListeners = void 0;
      var o = 10;
      function u(A) {
        if (typeof A != "function")
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof A);
      }
      function a(A) {
        return A._maxListeners === void 0 ? r.defaultMaxListeners : A._maxListeners;
      }
      function f(A, l, E, M) {
        var B, X, K;
        if (u(E), (X = A._events) === void 0 ? (X = A._events = /* @__PURE__ */ Object.create(null), A._eventsCount = 0) : (X.newListener !== void 0 && (A.emit("newListener", l, E.listener ? E.listener : E), X = A._events), K = X[l]), K === void 0)
          K = X[l] = E, ++A._eventsCount;
        else if (typeof K == "function" ? K = X[l] = M ? [E, K] : [K, E] : M ? K.unshift(E) : K.push(E), (B = a(A)) > 0 && K.length > B && !K.warned) {
          K.warned = !0;
          var D = new Error("Possible EventEmitter memory leak detected. " + K.length + " " + String(l) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          D.name = "MaxListenersExceededWarning", D.emitter = A, D.type = l, D.count = K.length, i(D);
        }
        return A;
      }
      function y() {
        if (!this.fired)
          return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
      }
      function T(A, l, E) {
        var M = { fired: !1, wrapFn: void 0, target: A, type: l, listener: E }, B = y.bind(M);
        return B.listener = E, M.wrapFn = B, B;
      }
      function h(A, l, E) {
        var M = A._events;
        if (M === void 0)
          return [];
        var B = M[l];
        return B === void 0 ? [] : typeof B == "function" ? E ? [B.listener || B] : [B] : E ? d(B) : g(B, B.length);
      }
      function _(A) {
        var l = this._events;
        if (l !== void 0) {
          var E = l[A];
          if (typeof E == "function")
            return 1;
          if (E !== void 0)
            return E.length;
        }
        return 0;
      }
      function g(A, l) {
        for (var E = new Array(l), M = 0; M < l; ++M)
          E[M] = A[M];
        return E;
      }
      function S(A, l) {
        for (; l + 1 < A.length; l++)
          A[l] = A[l + 1];
        A.pop();
      }
      function d(A) {
        for (var l = new Array(A.length), E = 0; E < l.length; ++E)
          l[E] = A[E].listener || A[E];
        return l;
      }
      function b(A, l) {
        return new Promise(function(E, M) {
          function B(K) {
            A.removeListener(l, X), M(K);
          }
          function X() {
            typeof A.removeListener == "function" && A.removeListener("error", B), E([].slice.call(arguments));
          }
          O(A, l, X, { once: !0 }), l !== "error" && k(A, B, { once: !0 });
        });
      }
      function k(A, l, E) {
        typeof A.on == "function" && O(A, "error", l, E);
      }
      function O(A, l, E, M) {
        if (typeof A.on == "function")
          M.once ? A.once(l, E) : A.on(l, E);
        else {
          if (typeof A.addEventListener != "function")
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof A);
          A.addEventListener(l, function B(X) {
            M.once && A.removeEventListener(l, B), E(X);
          });
        }
      }
      Object.defineProperty(r, "defaultMaxListeners", { enumerable: !0, get: function() {
        return o;
      }, set: function(A) {
        if (typeof A != "number" || A < 0 || s(A))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + A + ".");
        o = A;
      } }), r.init = function() {
        this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, r.prototype.setMaxListeners = function(A) {
        if (typeof A != "number" || A < 0 || s(A))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + A + ".");
        return this._maxListeners = A, this;
      }, r.prototype.getMaxListeners = function() {
        return a(this);
      }, r.prototype.emit = function(A) {
        for (var l = [], E = 1; E < arguments.length; E++)
          l.push(arguments[E]);
        var M = A === "error", B = this._events;
        if (B !== void 0)
          M = M && B.error === void 0;
        else if (!M)
          return !1;
        if (M) {
          var X;
          if (l.length > 0 && (X = l[0]), X instanceof Error)
            throw X;
          var K = new Error("Unhandled error." + (X ? " (" + X.message + ")" : ""));
          throw K.context = X, K;
        }
        var D = B[A];
        if (D === void 0)
          return !1;
        if (typeof D == "function")
          n(D, this, l);
        else {
          var j = D.length, Z = g(D, j);
          for (E = 0; E < j; ++E)
            n(Z[E], this, l);
        }
        return !0;
      }, r.prototype.addListener = function(A, l) {
        return f(this, A, l, !1);
      }, r.prototype.on = r.prototype.addListener, r.prototype.prependListener = function(A, l) {
        return f(this, A, l, !0);
      }, r.prototype.once = function(A, l) {
        return u(l), this.on(A, T(this, A, l)), this;
      }, r.prototype.prependOnceListener = function(A, l) {
        return u(l), this.prependListener(A, T(this, A, l)), this;
      }, r.prototype.removeListener = function(A, l) {
        var E, M, B, X, K;
        if (u(l), (M = this._events) === void 0)
          return this;
        if ((E = M[A]) === void 0)
          return this;
        if (E === l || E.listener === l)
          --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete M[A], M.removeListener && this.emit("removeListener", A, E.listener || l));
        else if (typeof E != "function") {
          for (B = -1, X = E.length - 1; X >= 0; X--)
            if (E[X] === l || E[X].listener === l) {
              K = E[X].listener, B = X;
              break;
            }
          if (B < 0)
            return this;
          B === 0 ? E.shift() : S(E, B), E.length === 1 && (M[A] = E[0]), M.removeListener !== void 0 && this.emit("removeListener", A, K || l);
        }
        return this;
      }, r.prototype.off = r.prototype.removeListener, r.prototype.removeAllListeners = function(A) {
        var l, E, M;
        if ((E = this._events) === void 0)
          return this;
        if (E.removeListener === void 0)
          return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : E[A] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete E[A]), this;
        if (arguments.length === 0) {
          var B, X = Object.keys(E);
          for (M = 0; M < X.length; ++M)
            (B = X[M]) !== "removeListener" && this.removeAllListeners(B);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if (typeof (l = E[A]) == "function")
          this.removeListener(A, l);
        else if (l !== void 0)
          for (M = l.length - 1; M >= 0; M--)
            this.removeListener(A, l[M]);
        return this;
      }, r.prototype.listeners = function(A) {
        return h(this, A, !0);
      }, r.prototype.rawListeners = function(A) {
        return h(this, A, !1);
      }, r.listenerCount = function(A, l) {
        return typeof A.listenerCount == "function" ? A.listenerCount(l) : _.call(A, l);
      }, r.prototype.listenerCount = _, r.prototype.eventNames = function() {
        return this._eventsCount > 0 ? p(this._events) : [];
      };
    }, {}], 96: [function(x, C, c) {
      C.exports = r, r.default = r, r.stable = f, r.stableStringify = f;
      var p = "[...]", v = "[Circular]", n = [], i = [];
      function s() {
        return { depthLimit: Number.MAX_SAFE_INTEGER, edgesLimit: Number.MAX_SAFE_INTEGER };
      }
      function r(h, _, g, S) {
        var d;
        S === void 0 && (S = s()), u(h, "", 0, [], void 0, 0, S);
        try {
          d = i.length === 0 ? JSON.stringify(h, _, g) : JSON.stringify(h, T(_), g);
        } catch (k) {
          return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
        } finally {
          for (; n.length !== 0; ) {
            var b = n.pop();
            b.length === 4 ? Object.defineProperty(b[0], b[1], b[3]) : b[0][b[1]] = b[2];
          }
        }
        return d;
      }
      function o(h, _, g, S) {
        var d = Object.getOwnPropertyDescriptor(S, g);
        d.get !== void 0 ? d.configurable ? (Object.defineProperty(S, g, { value: h }), n.push([S, g, _, d])) : i.push([_, g, h]) : (S[g] = h, n.push([S, g, _]));
      }
      function u(h, _, g, S, d, b, k) {
        var O;
        if (b += 1, typeof h == "object" && h !== null) {
          for (O = 0; O < S.length; O++)
            if (S[O] === h)
              return void o(v, h, _, d);
          if (k.depthLimit !== void 0 && b > k.depthLimit || k.edgesLimit !== void 0 && g + 1 > k.edgesLimit)
            return void o(p, h, _, d);
          if (S.push(h), Array.isArray(h))
            for (O = 0; O < h.length; O++)
              u(h[O], O, O, S, h, b, k);
          else {
            var A = Object.keys(h);
            for (O = 0; O < A.length; O++) {
              var l = A[O];
              u(h[l], l, O, S, h, b, k);
            }
          }
          S.pop();
        }
      }
      function a(h, _) {
        return h < _ ? -1 : h > _ ? 1 : 0;
      }
      function f(h, _, g, S) {
        S === void 0 && (S = s());
        var d, b = y(h, "", 0, [], void 0, 0, S) || h;
        try {
          d = i.length === 0 ? JSON.stringify(b, _, g) : JSON.stringify(b, T(_), g);
        } catch (O) {
          return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
        } finally {
          for (; n.length !== 0; ) {
            var k = n.pop();
            k.length === 4 ? Object.defineProperty(k[0], k[1], k[3]) : k[0][k[1]] = k[2];
          }
        }
        return d;
      }
      function y(h, _, g, S, d, b, k) {
        var O;
        if (b += 1, typeof h == "object" && h !== null) {
          for (O = 0; O < S.length; O++)
            if (S[O] === h)
              return void o(v, h, _, d);
          try {
            if (typeof h.toJSON == "function")
              return;
          } catch (M) {
            return;
          }
          if (k.depthLimit !== void 0 && b > k.depthLimit || k.edgesLimit !== void 0 && g + 1 > k.edgesLimit)
            return void o(p, h, _, d);
          if (S.push(h), Array.isArray(h))
            for (O = 0; O < h.length; O++)
              y(h[O], O, O, S, h, b, k);
          else {
            var A = {}, l = Object.keys(h).sort(a);
            for (O = 0; O < l.length; O++) {
              var E = l[O];
              y(h[E], E, O, S, h, b, k), A[E] = h[E];
            }
            if (d === void 0)
              return A;
            n.push([d, _, h]), d[_] = A;
          }
          S.pop();
        }
      }
      function T(h) {
        return h = h !== void 0 ? h : function(_, g) {
          return g;
        }, function(_, g) {
          if (i.length > 0)
            for (var S = 0; S < i.length; S++) {
              var d = i[S];
              if (d[1] === _ && d[0] === g) {
                g = d[2], i.splice(S, 1);
                break;
              }
            }
          return h.call(this, _, g);
        };
      }
    }, {}], 97: [function(x, C, c) {
      var p = x("is-callable"), v = Object.prototype.toString, n = Object.prototype.hasOwnProperty, i = function(u, a, f) {
        for (var y = 0, T = u.length; y < T; y++)
          n.call(u, y) && (f == null ? a(u[y], y, u) : a.call(f, u[y], y, u));
      }, s = function(u, a, f) {
        for (var y = 0, T = u.length; y < T; y++)
          f == null ? a(u.charAt(y), y, u) : a.call(f, u.charAt(y), y, u);
      }, r = function(u, a, f) {
        for (var y in u)
          n.call(u, y) && (f == null ? a(u[y], y, u) : a.call(f, u[y], y, u));
      }, o = function(u, a, f) {
        if (!p(a))
          throw new TypeError("iterator must be a function");
        var y;
        arguments.length >= 3 && (y = f), v.call(u) === "[object Array]" ? i(u, a, y) : typeof u == "string" ? s(u, a, y) : r(u, a, y);
      };
      C.exports = o;
    }, { "is-callable": 112 }], 98: [function(x, C, c) {
      var p = "Function.prototype.bind called on incompatible ", v = Array.prototype.slice, n = Object.prototype.toString, i = "[object Function]";
      C.exports = function(s) {
        var r = this;
        if (typeof r != "function" || n.call(r) !== i)
          throw new TypeError(p + r);
        for (var o, u = v.call(arguments, 1), a = Math.max(0, r.length - u.length), f = [], y = 0; y < a; y++)
          f.push("$" + y);
        if (o = Function("binder", "return function (" + f.join(",") + "){ return binder.apply(this,arguments); }")(function() {
          if (this instanceof o) {
            var h = r.apply(this, u.concat(v.call(arguments)));
            return Object(h) === h ? h : this;
          }
          return r.apply(s, u.concat(v.call(arguments)));
        }), r.prototype) {
          var T = function() {
          };
          T.prototype = r.prototype, o.prototype = new T(), T.prototype = null;
        }
        return o;
      };
    }, {}], 99: [function(x, C, c) {
      var p = x("./implementation");
      C.exports = Function.prototype.bind || p;
    }, { "./implementation": 98 }], 100: [function(x, C, c) {
      (function(p) {
        (function() {
          (function(v) {
            typeof c == "object" && typeof C != "undefined" ? C.exports = v() : (typeof window != "undefined" ? window : typeof p != "undefined" ? p : typeof self != "undefined" ? self : this).GateExecutor = v();
          })(function() {
            var v, n, i, s, r = (v = function(A, l) {
              (function(E, M) {
                (function() {
                  var B = o.nextTick, X = Array.prototype.slice, K = {}, D = 0;
                  l.setImmediate = typeof E == "function" ? E : function(j) {
                    var Z = D++, tt = !(arguments.length < 2) && X.call(arguments, 1);
                    return K[Z] = !0, B(function() {
                      K[Z] && (tt ? j.apply(null, tt) : j.call(null), l.clearImmediate(Z));
                    }), Z;
                  }, l.clearImmediate = typeof M == "function" ? M : function(j) {
                    delete K[j];
                  };
                }).call(this);
              }).call(this, r({}).setImmediate, r({}).clearImmediate);
            }, function(A) {
              return n || v(n = { exports: {}, parent: A }, n.exports), n.exports;
            }), o = {}, u = o = {};
            function a() {
              throw new Error("setTimeout has not been defined");
            }
            function f() {
              throw new Error("clearTimeout has not been defined");
            }
            function y(A) {
              if (i === setTimeout)
                return setTimeout(A, 0);
              if ((i === a || !i) && setTimeout)
                return i = setTimeout, setTimeout(A, 0);
              try {
                return i(A, 0);
              } catch (l) {
                try {
                  return i.call(null, A, 0);
                } catch (E) {
                  return i.call(this, A, 0);
                }
              }
            }
            (function() {
              try {
                i = typeof setTimeout == "function" ? setTimeout : a;
              } catch (A) {
                i = a;
              }
              try {
                s = typeof clearTimeout == "function" ? clearTimeout : f;
              } catch (A) {
                s = f;
              }
            })();
            var T, h = [], _ = !1, g = -1;
            function S() {
              _ && T && (_ = !1, T.length ? h = T.concat(h) : g = -1, h.length && d());
            }
            function d() {
              if (!_) {
                var A = y(S);
                _ = !0;
                for (var l = h.length; l; ) {
                  for (T = h, h = []; ++g < l; )
                    T && T[g].run();
                  g = -1, l = h.length;
                }
                T = null, _ = !1, function(E) {
                  if (s === clearTimeout)
                    return clearTimeout(E);
                  if ((s === f || !s) && clearTimeout)
                    return s = clearTimeout, clearTimeout(E);
                  try {
                    s(E);
                  } catch (M) {
                    try {
                      return s.call(null, E);
                    } catch (B) {
                      return s.call(this, E);
                    }
                  }
                }(A);
              }
            }
            function b(A, l) {
              this.fun = A, this.array = l;
            }
            function k() {
            }
            u.nextTick = function(A) {
              var l = new Array(arguments.length - 1);
              if (arguments.length > 1)
                for (var E = 1; E < arguments.length; E++)
                  l[E - 1] = arguments[E];
              h.push(new b(A, l)), h.length !== 1 || _ || y(d);
            }, b.prototype.run = function() {
              this.fun.apply(null, this.array);
            }, u.title = "browser", u.browser = !0, u.env = {}, u.argv = [], u.version = "", u.versions = {}, u.on = k, u.addListener = k, u.once = k, u.off = k, u.removeListener = k, u.removeAllListeners = k, u.emit = k, u.prependListener = k, u.prependOnceListener = k, u.listeners = function(A) {
              return [];
            }, u.binding = function(A) {
              throw new Error("process.binding is not supported");
            }, u.cwd = function() {
              return "/";
            }, u.chdir = function(A) {
              throw new Error("process.chdir is not supported");
            }, u.umask = function() {
              return 0;
            };
            var O = {};
            return function(A) {
              (function() {
                function l(E) {
                  return (E = E || {}).interval = E.interval == null ? 111 : E.interval, E.timeout = E.timeout == null ? 2222 : E.timeout, function M(B, X) {
                    let K = {};
                    K.id = ++X, K.options = B;
                    let D = [], j = { lookup: {}, history: [] }, Z = [], tt = { work_counter: 0, gate: !1, running: !1, clear: null, firstclear: null, tm_in: null, hw_tmc: 0, hw_hst: 0 };
                    function nt() {
                      if (!tt.running)
                        return;
                      K.isclear() || tt.tm_in || (tt.tm_in = setInterval(ut, B.interval));
                      let V = !1;
                      do {
                        V = !1;
                        let ot = null;
                        tt.gate || (ot = D.shift()), ot && (j.lookup[ot.id] = ot, j.history.push(ot), tt.hw_hst = j.history.length > tt.hw_hst ? j.history.length : tt.hw_hst, tt.gate = ot.gate, ot.start = Date.now(), ot.callback = ct(ot), Z.push(ot), tt.hw_tmc = Z.length > tt.hw_tmc ? Z.length : tt.hw_tmc, ot.fn(ot.callback), V = !0);
                      } while (V);
                    }
                    function ct(V) {
                      return function() {
                        if (!V.done) {
                          for (V.end = Date.now(), V.done = !0, delete j.lookup[V.id]; j.history[0] && j.history[0].done; )
                            j.history.shift();
                          for (; Z[0] && Z[0].done; )
                            Z.shift();
                          if (V.gate && (tt.gate = !1), D.length === 0 && j.history.length === 0) {
                            if (clearInterval(tt.tm_in), tt.tm_in = null, tt.firstclear) {
                              let ot = tt.firstclear;
                              tt.firstclear = null, ot();
                            }
                            tt.clear && tt.clear();
                          }
                          A(nt);
                        }
                      };
                    }
                    function ut() {
                      let V = Date.now(), ot = null;
                      for (let xt = 0; xt < Z.length; ++xt)
                        !(ot = Z[xt]).gate && !ot.done && ot.tm < V - ot.start && (ot.ontm && ot.ontm(ot.tm, ot.start, V), ot.callback());
                    }
                    return K.start = function(V) {
                      return A(function() {
                        tt.running = !0, V && (tt.firstclear = V), nt();
                      }), K;
                    }, K.pause = function() {
                      tt.running = !1;
                    }, K.clear = function(V) {
                      return tt.clear = V, K;
                    }, K.isclear = function() {
                      return D.length === 0 && j.history.length === 0;
                    }, K.add = function(V) {
                      return tt.work_counter += 1, V.id = V.id || "" + tt.work_counter, V.ge = K.id, V.tm = V.tm == null ? B.timeout : V.tm, V.dn = V.dn || V.fn.name || "" + Date.now(), V.ctxt = {}, D.push(V), tt.running && A(nt), K;
                    }, K.gate = function() {
                      let V = M(B, X);
                      return K.add({ gate: V, fn: function(ot) {
                        V.start(ot);
                      } }), V;
                    }, K.state = function() {
                      let V = [];
                      for (let ot = 0; ot < j.history.length; ++ot) {
                        let xt = j.history[ot];
                        xt.done || V.push({ s: "a", ge: xt.ge, dn: xt.dn, id: xt.id });
                      }
                      for (let ot = 0; ot < D.length; ++ot) {
                        let xt = D[ot];
                        xt.gate ? V.push(xt.gate.state()) : V.push({ s: "w", ge: xt.ge, dn: xt.dn, id: xt.id });
                      }
                      return V.internal = { qlen: D.length, hlen: j.history.length, klen: Object.keys(j.lookup).length, tlen: ut.length, hw_hst: tt.hw_hst, hw_tmc: tt.hw_tmc }, V;
                    }, K;
                  }(E, 0);
                }
                Object.defineProperty(O, "__esModule", { value: !0 }), O.default = l, typeof O != null && (O = l);
              }).call(this);
            }.call(this, r({}).setImmediate), O;
          });
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 101: [function(x, C, c) {
      var p, v = SyntaxError, n = Function, i = TypeError, s = function(K) {
        try {
          return n('"use strict"; return (' + K + ").constructor;")();
        } catch (D) {
        }
      }, r = Object.getOwnPropertyDescriptor;
      if (r)
        try {
          r({}, "");
        } catch (K) {
          r = null;
        }
      var o = function() {
        throw new i();
      }, u = r ? function() {
        try {
          return arguments.callee, o;
        } catch (K) {
          try {
            return r(arguments, "callee").get;
          } catch (D) {
            return o;
          }
        }
      }() : o, a = x("has-symbols")(), f = Object.getPrototypeOf || function(K) {
        return K.__proto__;
      }, y = {}, T = typeof Uint8Array == "undefined" ? p : f(Uint8Array), h = { "%AggregateError%": typeof AggregateError == "undefined" ? p : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? p : ArrayBuffer, "%ArrayIteratorPrototype%": a ? f([][Symbol.iterator]()) : p, "%AsyncFromSyncIteratorPrototype%": p, "%AsyncFunction%": y, "%AsyncGenerator%": y, "%AsyncGeneratorFunction%": y, "%AsyncIteratorPrototype%": y, "%Atomics%": typeof Atomics == "undefined" ? p : Atomics, "%BigInt%": typeof BigInt == "undefined" ? p : BigInt, "%Boolean%": Boolean, "%DataView%": typeof DataView == "undefined" ? p : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array == "undefined" ? p : Float32Array, "%Float64Array%": typeof Float64Array == "undefined" ? p : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? p : FinalizationRegistry, "%Function%": n, "%GeneratorFunction%": y, "%Int8Array%": typeof Int8Array == "undefined" ? p : Int8Array, "%Int16Array%": typeof Int16Array == "undefined" ? p : Int16Array, "%Int32Array%": typeof Int32Array == "undefined" ? p : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": a ? f(f([][Symbol.iterator]())) : p, "%JSON%": typeof JSON == "object" ? JSON : p, "%Map%": typeof Map == "undefined" ? p : Map, "%MapIteratorPrototype%": typeof Map != "undefined" && a ? f((/* @__PURE__ */ new Map())[Symbol.iterator]()) : p, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise == "undefined" ? p : Promise, "%Proxy%": typeof Proxy == "undefined" ? p : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect == "undefined" ? p : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set == "undefined" ? p : Set, "%SetIteratorPrototype%": typeof Set != "undefined" && a ? f((/* @__PURE__ */ new Set())[Symbol.iterator]()) : p, "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? p : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": a ? f(""[Symbol.iterator]()) : p, "%Symbol%": a ? Symbol : p, "%SyntaxError%": v, "%ThrowTypeError%": u, "%TypedArray%": T, "%TypeError%": i, "%Uint8Array%": typeof Uint8Array == "undefined" ? p : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? p : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array == "undefined" ? p : Uint16Array, "%Uint32Array%": typeof Uint32Array == "undefined" ? p : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap == "undefined" ? p : WeakMap, "%WeakRef%": typeof WeakRef == "undefined" ? p : WeakRef, "%WeakSet%": typeof WeakSet == "undefined" ? p : WeakSet }, _ = function K(D) {
        var j;
        if (D === "%AsyncFunction%")
          j = s("async function () {}");
        else if (D === "%GeneratorFunction%")
          j = s("function* () {}");
        else if (D === "%AsyncGeneratorFunction%")
          j = s("async function* () {}");
        else if (D === "%AsyncGenerator%") {
          var Z = K("%AsyncGeneratorFunction%");
          Z && (j = Z.prototype);
        } else if (D === "%AsyncIteratorPrototype%") {
          var tt = K("%AsyncGenerator%");
          tt && (j = f(tt.prototype));
        }
        return h[D] = j, j;
      }, g = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, S = x("function-bind"), d = x("has"), b = S.call(Function.call, Array.prototype.concat), k = S.call(Function.apply, Array.prototype.splice), O = S.call(Function.call, String.prototype.replace), A = S.call(Function.call, String.prototype.slice), l = S.call(Function.call, RegExp.prototype.exec), E = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, M = /\\(\\)?/g, B = function(K) {
        var D = A(K, 0, 1), j = A(K, -1);
        if (D === "%" && j !== "%")
          throw new v("invalid intrinsic syntax, expected closing `%`");
        if (j === "%" && D !== "%")
          throw new v("invalid intrinsic syntax, expected opening `%`");
        var Z = [];
        return O(K, E, function(tt, nt, ct, ut) {
          Z[Z.length] = ct ? O(ut, M, "$1") : nt || tt;
        }), Z;
      }, X = function(K, D) {
        var j, Z = K;
        if (d(g, Z) && (Z = "%" + (j = g[Z])[0] + "%"), d(h, Z)) {
          var tt = h[Z];
          if (tt === y && (tt = _(Z)), tt === void 0 && !D)
            throw new i("intrinsic " + K + " exists, but is not available. Please file an issue!");
          return { alias: j, name: Z, value: tt };
        }
        throw new v("intrinsic " + K + " does not exist!");
      };
      C.exports = function(K, D) {
        if (typeof K != "string" || K.length === 0)
          throw new i("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof D != "boolean")
          throw new i('"allowMissing" argument must be a boolean');
        if (l(/^%?[^%]*%?$/g, K) === null)
          throw new v("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var j = B(K), Z = j.length > 0 ? j[0] : "", tt = X("%" + Z + "%", D), nt = tt.name, ct = tt.value, ut = !1, V = tt.alias;
        V && (Z = V[0], k(j, b([0, 1], V)));
        for (var ot = 1, xt = !0; ot < j.length; ot += 1) {
          var Ut = j[ot], pt = A(Ut, 0, 1), at = A(Ut, -1);
          if ((pt === '"' || pt === "'" || pt === "`" || at === '"' || at === "'" || at === "`") && pt !== at)
            throw new v("property names with quotes must have matching quotes");
          if (Ut !== "constructor" && xt || (ut = !0), d(h, nt = "%" + (Z += "." + Ut) + "%"))
            ct = h[nt];
          else if (ct != null) {
            if (!(Ut in ct)) {
              if (!D)
                throw new i("base intrinsic for " + K + " exists, but the property is not available.");
              return;
            }
            if (r && ot + 1 >= j.length) {
              var bt = r(ct, Ut);
              ct = (xt = !!bt) && "get" in bt && !("originalValue" in bt.get) ? bt.get : ct[Ut];
            } else
              xt = d(ct, Ut), ct = ct[Ut];
            xt && !ut && (h[nt] = ct);
          }
        }
        return ct;
      };
    }, { "function-bind": 99, has: 107, "has-symbols": 104 }], 102: [function(x, C, c) {
      (function(p) {
        (function() {
          (function(v) {
            typeof c == "object" && typeof C != "undefined" ? C.exports = v() : (typeof window != "undefined" ? window : typeof p != "undefined" ? p : typeof self != "undefined" ? self : this).Gubu = v();
          })(function() {
            var v = {}, n = {};
            Object.defineProperty(n, "__esModule", { value: !0 }), n.Gubu = void 0;
            const i = Symbol.for("gubu$"), s = { gubu$: i, v$: "3.1.0" }, r = Symbol.for("gubu$nil"), o = /^[A-Z]/, u = "", a = "name", f = "nan", y = "never", T = "number", h = "required", _ = "array", g = "function", S = "object", d = "string", b = "undefined", k = "any", O = "list", A = "instance", l = "null", E = "type", M = "Object", B = "Array", X = "Above", K = "Below", D = "Some", j = "Value", Z = " for property ", tt = '"$PATH"', nt = '"$VALUE"', ct = (R) => Object.keys(R), ut = (R, z, et) => Object.defineProperty(R, z, et), V = (R) => Array.isArray(R), ot = (R) => JSON.parse(R), xt = (R, z) => JSON.stringify(R, z);
            class Ut {
              constructor(z, et, ht, yt) {
                this.match = !1, this.dI = 0, this.nI = 2, this.cI = -1, this.pI = 0, this.sI = -1, this.valType = y, this.isRoot = !1, this.key = u, this.type = y, this.stop = !0, this.nextSibling = !0, this.fromDefault = !1, this.ignoreVal = void 0, this.err = [], this.parents = [], this.keys = [], this.path = [], this.root = z, this.vals = [z, -1], this.node = et, this.nodes = [et, -1], this.ctx = ht || {}, this.match = !!yt;
              }
              next() {
                this.stop = !1, this.fromDefault = !1, this.ignoreVal = void 0, this.isRoot = this.pI === 0;
                let z = this.nodes[this.pI];
                for (; +z; )
                  this.pI = +z, z = this.nodes[this.pI], this.dI--;
                z ? (this.node = z, this.updateVal(this.vals[this.pI]), this.key = this.keys[this.pI], this.cI = this.pI, this.sI = this.pI + 1, this.parent = this.parents[this.pI], this.nextSibling = !0, this.type = this.node.t, this.path[this.dI] = this.key, this.oval = this.val) : this.stop = !0;
              }
              updateVal(z) {
                this.val = z, this.valType = typeof this.val, T === this.valType && isNaN(this.val) && (this.valType = f), this.isRoot && !this.match && (this.root = this.val);
              }
            }
            class pt extends TypeError {
              constructor(z, et, ht) {
                super(et.map((yt) => yt.t).join(`
`)), this.gubu = !0, this.name = "GubuError", this.code = z, this.desc = () => ({ name: "GubuError", code: z, err: et, ctx: ht });
              }
              toJSON() {
                return kn(Ge({}, this), { err: this.desc().err, name: this.name, message: this.message });
              }
            }
            const at = { String: !0, Number: !0, Boolean: !0, Object: !0, Array: !0, Function: !0, Symbol: !0, BigInt: !0 }, bt = { string: u, number: 0, boolean: !1, object: {}, array: [], symbol: Symbol(u), bigint: BigInt(0), null: null };
            function Q(R, z) {
              var et, ht, yt, Ct;
              if (At === R)
                R = void 0;
              else if (R != null && (!((et = R.$) === null || et === void 0) && et.gubu$)) {
                if (i === R.$.gubu$)
                  return R.d = z == null ? R.d : z, R;
                if (R.$.gubu$ === !0) {
                  let Gt = Ge({}, R);
                  return Gt.$ = kn(Ge({ v$: "3.1.0" }, Gt.$), { gubu$: i }), Gt.v = Gt.v != null && S === typeof Gt.v ? Ge({}, Gt.v) : Gt.v, Gt.t = Gt.t || typeof Gt.v, g === Gt.t && at[Gt.v.name] && (Gt.t = Gt.v.name.toLowerCase(), Gt.v = Vt(bt[Gt.t])), Gt.r = !!Gt.r, Gt.p = !!Gt.p, Gt.d = z == null ? Gt.d == null ? -1 : Gt.d : z, Gt.b = Gt.b || [], Gt.a = Gt.a || [], Gt.u = Gt.u || {}, Gt;
                }
              }
              let Et = R === null ? l : typeof R, Zt = R, Qt = r, Rt = !1, Lt = {}, te = [], Oe = [];
              if (S === (Et = b === Et ? k : Et))
                V(Zt) ? (Et = _, Zt.length === 1 && (Qt = Zt[0], Zt = [])) : Zt != null && Function !== Zt.constructor && Object !== Zt.constructor && Zt.constructor != null ? (Et = A, Lt.n = Zt.constructor.name, Lt.i = Zt.constructor) : ct(Zt).length === 0 && (Qt = F());
              else if (g === Et)
                if (at[R.name])
                  Et = R.name.toLowerCase(), Rt = !0, Zt = Vt(bt[Et]), M === R.name && (Qt = F());
                else if (Zt.gubu === s || ((ht = Zt.$) === null || ht === void 0 ? void 0 : ht.gubu) === !0) {
                  let Gt = Zt.node ? Zt.node() : Zt;
                  Et = Gt.t, Zt = Gt.v, Rt = Gt.r, Lt = Ge({}, Gt.u), te = [...Gt.a], Oe = [...Gt.b];
                } else
                  Zt.constructor.name === "Function" && o.test(Zt.name) && (Et = A, Rt = !0, Lt.n = (Ct = (yt = Zt.prototype) === null || yt === void 0 ? void 0 : yt.constructor) === null || Ct === void 0 ? void 0 : Ct.name, Lt.i = Zt);
              else
                T === Et && isNaN(Zt) ? Et = f : d === Et && u === Zt && (Lt.empty = !0);
              let ke = Zt == null || S !== Et && _ !== Et ? Zt : Ge({}, Zt);
              return { $: s, t: Et, v: ke, n: ke != null && S === typeof ke ? ct(ke).length : 0, c: Qt, r: Rt, p: !1, d: z == null ? -1 : z, u: Lt, a: te, b: Oe };
            }
            function At(R, z) {
              const et = z == null ? {} : z;
              et.name = et.name == null ? "G" + (u + Math.random()).substring(2, 8) : u + et.name;
              let ht = Q(R, 0);
              function yt(Zt, Qt, Rt) {
                let Lt = new Ut(Zt, ht, Qt, Rt);
                for (; Lt.next(), !Lt.stop; ) {
                  let te = Lt.node, Oe = !1;
                  if (0 < te.b.length)
                    for (let Gt = 0; Gt < te.b.length; Gt++) {
                      let be = Pt(te.b[Gt], Lt);
                      te = Lt.node, be.done !== void 0 && (Oe = be.done);
                    }
                  if (!Oe)
                    if (y === Lt.type)
                      Lt.err.push(qt(y, Lt, 1070));
                    else if (S === Lt.type) {
                      let Gt;
                      if (te.r && Lt.val === void 0 ? (Lt.ignoreVal = !0, Lt.err.push(qt(h, Lt, 1010))) : Lt.val === void 0 || Lt.val !== null && S === Lt.valType && !V(Lt.val) ? te.p && Lt.val == null || (Lt.updateVal(Lt.val || (Lt.fromDefault = !0, {})), Gt = Lt.val) : (Lt.err.push(qt(E, Lt, 1020)), Gt = V(Lt.val) ? Lt.val : {}), (Gt = Gt == null && Lt.ctx.err === !1 ? {} : Gt) != null) {
                        let be = !1, ve = ct(te.v), we = Lt.nI;
                        if (0 < ve.length) {
                          be = !0, Lt.pI = we;
                          for (let Ue of ve) {
                            let rn = te.v[Ue] = Q(te.v[Ue], 1 + Lt.dI);
                            Lt.nodes[Lt.nI] = rn, Lt.vals[Lt.nI] = Gt[Ue], Lt.parents[Lt.nI] = Gt, Lt.keys[Lt.nI] = Ue, Lt.nI++;
                          }
                        }
                        let se = ct(Gt).filter((Ue) => te.v[Ue] === void 0);
                        if (0 < se.length)
                          if (r === te.c)
                            Lt.ignoreVal = !0, Lt.err.push(qt("closed", Lt, 1100, void 0, { k: se }));
                          else {
                            be = !0, Lt.pI = we;
                            for (let Ue of se) {
                              let rn = te.c = Q(te.c, 1 + Lt.dI);
                              Lt.nodes[Lt.nI] = rn, Lt.vals[Lt.nI] = Gt[Ue], Lt.parents[Lt.nI] = Gt, Lt.keys[Lt.nI] = Ue, Lt.nI++;
                            }
                          }
                        be && (Lt.dI++, Lt.nodes[Lt.nI++] = Lt.sI, Lt.nextSibling = !1);
                      }
                    } else if (_ === Lt.type)
                      if (te.r && Lt.val === void 0)
                        Lt.ignoreVal = !0, Lt.err.push(qt(h, Lt, 1030));
                      else if (Lt.val === void 0 || V(Lt.val)) {
                        if (!te.p || Lt.val != null) {
                          Lt.updateVal(Lt.val || (Lt.fromDefault = !0, []));
                          let Gt = 0 < Lt.val.length, be = r !== te.c, ve = ct(te.v).filter((se) => !isNaN(+se)), we = 0 < ve.length;
                          if (Gt || we) {
                            Lt.pI = Lt.nI;
                            let se = 0;
                            if (we)
                              if (ve.length < Lt.val.length && !be)
                                Lt.ignoreVal = !0, Lt.err.push(qt("closed", Lt, 1090, void 0, { k: ve.length }));
                              else
                                for (; se < ve.length; se++) {
                                  let Ue = te.v[se] = Q(te.v[se], 1 + Lt.dI);
                                  Lt.nodes[Lt.nI] = Ue, Lt.vals[Lt.nI] = Lt.val[se], Lt.parents[Lt.nI] = Lt.val, Lt.keys[Lt.nI] = u + se, Lt.nI++;
                                }
                            if (be && Gt) {
                              let Ue = te.c = Q(te.c, 1 + Lt.dI);
                              for (; se < Lt.val.length; se++)
                                Lt.nodes[Lt.nI] = Ue, Lt.vals[Lt.nI] = Lt.val[se], Lt.parents[Lt.nI] = Lt.val, Lt.keys[Lt.nI] = u + se, Lt.nI++;
                            }
                            Lt.ignoreVal || (Lt.dI++, Lt.nodes[Lt.nI++] = Lt.sI, Lt.nextSibling = !1);
                          }
                        }
                      } else
                        Lt.err.push(qt(E, Lt, 1040));
                    else if (k === Lt.type || O === Lt.type || Lt.val === void 0 || Lt.type === Lt.valType || A === Lt.type && te.u.i && Lt.val instanceof te.u.i || l === Lt.type && Lt.val === null)
                      if (Lt.val === void 0) {
                        let Gt = Lt.path[Lt.dI];
                        !te.r || b === Lt.type && Lt.parent.hasOwnProperty(Gt) ? te.v !== void 0 && !te.p || b === Lt.type ? (Lt.updateVal(te.v), Lt.fromDefault = !0) : k === Lt.type && (Lt.ignoreVal = Lt.ignoreVal === void 0 || Lt.ignoreVal) : (Lt.ignoreVal = !0, Lt.err.push(qt(h, Lt, 1060)));
                      } else
                        d !== Lt.type || u !== Lt.val || te.u.empty || Lt.err.push(qt(h, Lt, 1080));
                    else
                      Lt.err.push(qt(E, Lt, 1050));
                  if (0 < te.a.length)
                    for (let Gt = 0; Gt < te.a.length; Gt++) {
                      let be = Pt(te.a[Gt], Lt);
                      te = Lt.node, be.done !== void 0 && (Oe = be.done);
                    }
                  let ke = Lt.node.p ? Lt.ignoreVal !== !1 : !!Lt.ignoreVal;
                  !Lt.match && Lt.parent != null && !Oe && !ke && (Lt.parent[Lt.key] = Lt.val), Lt.nextSibling && (Lt.pI = Lt.sI);
                }
                if (0 < Lt.err.length) {
                  if (V(Lt.ctx.err))
                    Lt.ctx.err.push(...Lt.err);
                  else if (!Lt.match && Lt.ctx.err !== !1)
                    throw new pt("shape", Lt.err, Lt.ctx);
                }
                return Lt.match ? Lt.err.length === 0 : Lt.root;
              }
              function Ct(Zt, Qt) {
                return yt(Zt, Qt, !1);
              }
              Ct.valid = function(Zt, Qt) {
                let Rt = Qt || {};
                return Rt.err = Rt.err || [], yt(Zt, Rt, !1), Rt.err.length === 0;
              }, Ct.match = (Zt, Qt) => yt(Zt, Qt = Qt || {}, !0), Ct.error = (Zt, Qt) => {
                let Rt = Qt || {};
                return Rt.err = Rt.err || [], yt(Zt, Rt, !1), Rt.err;
              }, Ct.spec = () => (Ct(void 0, { err: !1 }), ot($(ht, (Zt, Qt) => i === Qt || Qt, !1, !0))), Ct.node = () => (Ct.spec(), ht);
              let Et = u;
              return Ct.toString = () => (Et = He(u === Et ? $(ht && ht.$ && (i === ht.$.gubu$ || ht.$.gubu$ === !0) ? ht.v : ht) : Et), `[Gubu ${et.name} ${Et}]`), v.inspect && v.inspect.custom && (Ct[v.inspect.custom] = Ct.toString), Ct.gubu = s, Ct;
            }
            function Pt(R, z) {
              var et;
              let ht, yt = {}, Ct = !1;
              try {
                Ct = !(z.val !== void 0 || (et = R.gubu$) === null || et === void 0 || !et.Check) || R(z.val, yt, z);
              } catch (Zt) {
                ht = Zt;
              }
              let Et = V(yt.err) ? 0 < yt.err.length : yt.err != null;
              if (!Ct || Et) {
                if (z.val === void 0 && (z.node.p || !z.node.r) && yt.done !== !0)
                  return delete yt.err, yt;
                let Zt = yt.why || "check", Qt = q(z);
                if (d === typeof yt.err)
                  z.err.push(it(z, yt.err));
                else if (S === typeof yt.err)
                  z.err.push(...[yt.err].flat().map((Rt) => (Rt.p = Rt.p == null ? Qt : Rt.p, Rt.m = Rt.m == null ? 2010 : Rt.m, Rt)));
                else {
                  let Rt = R.name;
                  Rt != null && u != Rt || (Rt = He(R.toString().replace(/[ \t\r\n]+/g, " "))), z.err.push(qt(Zt, z, 1045, void 0, { thrown: ht }, Rt));
                }
                yt.done = yt.done == null || yt.done;
              }
              return yt.hasOwnProperty("uval") ? (z.updateVal(yt.uval), z.ignoreVal = !1) : yt.val === void 0 || Number.isNaN(yt.val) || (z.updateVal(yt.val), z.ignoreVal = !1), yt.node !== void 0 && (z.node = yt.node), yt.type !== void 0 && (z.type = yt.type), yt;
            }
            function q(R) {
              return R.path.slice(1, R.dI + 1).filter((z) => z != null).join(".");
            }
            const G = function(R) {
              let z = Dt(this, R);
              return z.r = !0, z.p = !1, R === void 0 && arguments.length === 1 && (z.t = b, z.v = void 0), z;
            }, lt = function(R) {
              let z = Dt(this, R);
              return z.r = !1, R === void 0 && arguments.length === 1 && (z.t = b, z.v = void 0), z;
            }, It = function(R) {
              let z = Dt(this, R);
              return z.r = !1, z.p = !0, z;
            }, Ft = function(R) {
              let z = Dt(this);
              return z.t = g, z.v = R, z;
            }, H = function(R) {
              let z = Dt(this, R);
              return z.u.empty = !0, z;
            }, F = function(R) {
              let z = Dt(this, R);
              return z.t = k, R !== void 0 && (z.v = R), z;
            }, P = function(R) {
              let z = Dt(this, R);
              return z.t = y, z;
            }, U = function(...R) {
              let z = Dt();
              z.t = O, z.r = !0;
              let et = R.map((ht) => W(ht));
              return z.u.list = R, z.b.push(function(ht, yt, Ct) {
                let Et = !0;
                for (let Zt of et) {
                  let Qt = kn(Ge({}, Ct.ctx), { err: [] });
                  Zt(ht, Qt), 0 < Qt.err.length && (Et = !1);
                }
                return Et || (yt.why = "All", yt.err = [it(Ct, j + " " + nt + Z + tt + " does not satisfy all of: " + R.map((Zt) => $(Zt, null, !0)).join(", "))]), Et;
              }), z;
            }, rt = function(...R) {
              let z = Dt();
              z.t = O, z.r = !0;
              let et = R.map((ht) => W(ht));
              return z.u.list = R, z.b.push(function(ht, yt, Ct) {
                let Et = !1;
                for (let Zt of et) {
                  let Qt = kn(Ge({}, Ct.ctx), { err: [] }), Rt = Zt.match(ht, Qt);
                  Rt && (yt.val = Zt(ht, Qt)), Et || (Et = Rt);
                }
                return Et || (yt.why = D, yt.err = [it(Ct, j + " " + nt + Z + tt + " does not satisfy any of: " + R.map((Zt) => $(Zt, null, !0)).join(", "))]), Et;
              }), z;
            }, ft = function(...R) {
              let z = Dt();
              z.t = O, z.r = !0;
              let et = R.map((ht) => W(ht));
              return z.u.list = R, z.b.push(function(ht, yt, Ct) {
                let Et = 0;
                for (let Zt of et) {
                  let Qt = kn(Ge({}, Ct.ctx), { err: [] });
                  if (Zt.match(ht, Qt)) {
                    Et++, yt.val = Zt(ht, Qt);
                    break;
                  }
                }
                return Et !== 1 && (yt.why = "One", yt.err = [it(Ct, j + " " + nt + Z + tt + " does not satisfy one of: " + R.map((Zt) => $(Zt, null, !0)).join(", "))]), !0;
              }), z;
            }, Ot = function(...R) {
              let z = Dt();
              return z.b.push(function(et, ht, yt) {
                for (let Ct = 0; Ct < R.length; Ct++)
                  if (et === R[Ct])
                    return !0;
                return ht.err = it(yt, j + " " + nt + Z + tt + " must be exactly one of: " + yt.node.s + "."), ht.done = !0, !1;
              }), z.s = R.map((et) => $(et, null, !0)).join(", "), z;
            }, Wt = function(R, z) {
              let et = Dt(this, z);
              return et.b.push(R), et;
            }, ce = function(R, z) {
              let et = Dt(this, z);
              return et.a.push(R), et;
            }, ye = function(R, z) {
              let et = Dt(this, z);
              if (g === typeof R) {
                let ht = R;
                ht.gubu$ = ht.gubu$ || {}, ht.gubu$.Check = !0, et.b.push(R), et.s = (et.s == null ? u : et.s + ";") + $(R, null, !0), et.r = !0;
              } else if (S === typeof R) {
                if (Object.prototype.toString.call(R).includes("RegExp")) {
                  let ht = (yt) => yt != null && !Number.isNaN(yt) && !!String(yt).match(R);
                  ut(ht, a, { value: String(R) }), ut(ht, "gubu$", { value: { Check: !0 } }), et.b.push(ht), et.s = $(R), et.r = !0;
                }
              } else
                d === typeof R && (et.t = R, et.r = !0);
              return et;
            }, ge = function(R) {
              let z = Dt(this, R);
              return z.c = F(), z;
            }, Ce = function(R) {
              let z = Dt(this, R);
              return _ === z.t && r !== z.c && z.n === 0 && (z.v = [z.c]), z.c = r, z;
            }, _e = function(R, z) {
              let et = Dt(this, z), ht = d === typeof R ? R : (S === typeof R && R || {}).name;
              return ht != null && u != ht && et.b.push(function(yt, Ct, Et) {
                return (Et.ctx.ref = Et.ctx.ref || {})[ht] = Et.node, !0;
              }), et;
            }, je = function(R, z) {
              let et = Dt(this, z), ht = S === typeof R && R || {}, yt = d === typeof R ? R : ht.name, Ct = !!ht.fill;
              return yt != null && u != yt && et.b.push(function(Et, Zt, Qt) {
                if (Et !== void 0 || Ct) {
                  let Rt = Qt.ctx.ref = Qt.ctx.ref || {};
                  if (Rt[yt] !== void 0) {
                    let Lt = Ge({}, Rt[yt]);
                    Lt.t = Lt.t || y, Zt.node = Lt, Zt.type = Lt.t;
                  }
                }
                return !0;
              }), et;
            }, Ie = function(R, z) {
              let et = Dt(this, z), ht = S === typeof R && R || {}, yt = d === typeof R ? R : ht.name, Ct = typeof ht.keep == "boolean" ? ht.keep : void 0, Et = V(ht.claim) ? ht.claim : [];
              if (yt != null && u != yt) {
                let Zt = (Rt, Lt, te) => {
                  if (Rt === void 0 && 0 < Et.length) {
                    te.ctx.Rename = te.ctx.Rename || {}, te.ctx.Rename.fromDefault = te.ctx.Rename.fromDefault || {};
                    for (let Oe of Et) {
                      let ke = te.ctx.Rename.fromDefault[Oe] || {};
                      if (te.parent[Oe] !== void 0 && !ke.yes) {
                        Lt.val = te.parent[Oe], te.match || (te.parent[yt] = Lt.val), Lt.node = ke.node;
                        for (let Gt = 0; Gt < te.err.length; Gt++)
                          te.err[Gt].k === ke.key && (te.err.splice(Gt, 1), Gt--);
                        if (Ct) {
                          let Gt = te.cI + 1;
                          te.nodes.splice(Gt, 0, Q(ke.dval)), te.vals.splice(Gt, 0, void 0), te.parents.splice(Gt, 0, te.parent), te.keys.splice(Gt, 0, Oe), te.nI++, te.pI++;
                        } else
                          delete te.parent[Oe];
                        break;
                      }
                    }
                    Lt.val === void 0 && (Lt.val = te.node.v);
                  }
                  return !0;
                };
                ut(Zt, a, { value: "Rename:" + yt }), et.b.push(Zt);
                let Qt = (Rt, Lt, te) => (te.parent[yt] = Rt, te.match || Ct || te.key === yt || V(te.parent) && Ct !== !1 || (delete te.parent[te.key], Lt.done = !0), te.ctx.Rename = te.ctx.Rename || {}, te.ctx.Rename.fromDefault = te.ctx.Rename.fromDefault || {}, te.ctx.Rename.fromDefault[yt] = { yes: te.fromDefault, key: te.key, dval: te.node.v, node: te.node }, !0);
                ut(Qt, a, { value: "Rename:" + yt }), et.a.push(Qt);
              }
              return et;
            };
            function $e(R) {
              return T === typeof R ? R : T === typeof (R == null ? void 0 : R.length) ? R.length : R != null && S === typeof R ? ct(R).length : NaN;
            }
            function He(R, z) {
              let et = String(R), ht = z == null || isNaN(z) ? 30 : z < 0 ? 0 : ~~z, yt = R == null ? 0 : et.length, Ct = R == null ? u : et.substring(0, yt);
              return (Ct = ht < yt ? Ct.substring(0, ht - 3) + "..." : Ct).substring(0, ht);
            }
            const De = function(R, z) {
              let et = Dt(this, z);
              return et.b.push(function(ht, yt, Ct) {
                let Et = $e(ht);
                if (R <= Et)
                  return !0;
                let Zt = T === typeof ht ? u : "length ";
                return yt.err = it(Ct, j + " " + nt + Z + tt + ` must be a minimum ${Zt}of ${R} (was ${Et}).`), !1;
              }), et.s = "Min(" + R + (z == null ? u : "," + $(z)) + ")", et;
            }, _t = function(R, z) {
              let et = Dt(this, z);
              return et.b.push(function(ht, yt, Ct) {
                let Et = $e(ht);
                if (Et <= R)
                  return !0;
                let Zt = T === typeof ht ? u : "length ";
                return yt.err = it(Ct, j + " " + nt + Z + tt + ` must be a maximum ${Zt}of ${R} (was ${Et}).`), !1;
              }), et.s = "Max(" + R + (z == null ? u : "," + $(z)) + ")", et;
            }, jt = function(R, z) {
              let et = Dt(this, z);
              return et.b.push(function(ht, yt, Ct) {
                let Et = $e(ht);
                if (R < Et)
                  return !0;
                let Zt = T === typeof ht ? "be" : "have length";
                return yt.err = it(Ct, j + " " + nt + Z + tt + ` must ${Zt} above ${R} (was ${Et}).`), !1;
              }), et.s = X + "(" + R + (z == null ? u : "," + $(z)) + ")", et;
            }, mt = function(R, z) {
              let et = Dt(this, z);
              return et.b.push(function(ht, yt, Ct) {
                let Et = $e(ht);
                if (Et < R)
                  return !0;
                let Zt = T === typeof ht ? "be" : "have length";
                return yt.err = it(Ct, j + " " + nt + Z + tt + ` must ${Zt} below ${R} (was ${Et}).`), !1;
              }), et.s = K + "(" + R + (z == null ? u : "," + $(z)) + ")", et;
            }, St = function(R, z) {
              let et = Dt(this, z || F());
              return et.b.push(function(ht, yt, Ct) {
                let Et = $e(ht);
                if (R === Et)
                  return !0;
                let Zt = T === typeof ht ? u : " in length";
                return yt.err = it(Ct, j + " " + nt + Z + tt + ` must be exactly ${R}${Zt} (was ${Et}).`), !1;
              }), et.s = "Len(" + R + (z == null ? u : "," + $(z)) + ")", et;
            }, kt = function(R, z) {
              let et = Dt(z == null ? this : z), ht = Q(R);
              return et.c = ht, et;
            };
            function Dt(R, z) {
              let et = Q(R == null || R.window === R || R.global === R ? z : R);
              return Object.assign(et, { Above: jt, After: ce, Any: F, Before: Wt, Below: mt, Check: ye, Closed: Ce, Open: ge, Define: _e, Empty: H, Exact: Ot, Max: _t, Min: De, Never: P, Len: St, Refer: je, Rename: Ie, Required: G, Skip: It, Value: kt });
            }
            function it(R, z, et, ht) {
              return qt(et || "check", R, 4e3, z, ht);
            }
            function qt(R, z, et, ht, yt, Ct) {
              let Et = { k: z.key, n: z.node, v: z.val, p: q(z), w: R, m: et, t: u, u: yt || {} }, Zt = He((z.val === void 0 ? u : $(z.val)).replace(/"/g, u));
              if (ht == null || u === ht) {
                let Qt = Zt.startsWith("[") ? _ : Zt.startsWith("{") ? S : "value", Rt = Zt.startsWith("[") || V(z.parents[z.pI]) ? "index" : "property", Lt = "is", te = yt == null ? void 0 : yt.k;
                te = V(te) ? (Rt = 1 < te.length ? (Lt = "are", "properties") : Rt, te.join(", ")) : te, Et.t = "Validation failed for " + (0 < Et.p.length ? `${Rt} "${Et.p}" with ` : u) + `${Qt} "${Zt}" because ` + (E === R ? A === z.node.t ? `the ${Qt} is not an instance of ${z.node.u.n} ` : `the ${Qt} is not of type ${z.node.t}` : h === R ? u === z.val ? "an empty string is not allowed" : `the ${Qt} is required` : R === "closed" ? `the ${Rt} "${te}" ${Lt} not allowed` : y === R ? "no value is allowed" : `check "${Ct == null ? R : Ct}" failed`) + (Et.u.thrown ? " (threw: " + Et.u.thrown.message + ")" : ".");
              } else
                Et.t = ht.replace(/\$VALUE/g, Zt).replace(/\$PATH/g, Et.p);
              return Et;
            }
            function he(R) {
              return R.s != null && u !== R.s ? R.s : R.r || R.v === void 0 ? R.t : R.v;
            }
            function $(R, z, et, ht) {
              let yt;
              ht || !R || !R.$ || i !== R.$.gubu$ && R.$.gubu$ !== !0 || (R = he(R));
              try {
                yt = xt(R, (Ct, Et) => {
                  var Zt, Qt;
                  if (z && (Et = z(Ct, Et)), Et != null && S === typeof Et && Et.constructor && M !== Et.constructor.name && B !== Et.constructor.name)
                    Et = g === typeof Et.toString ? Et.toString() : Et.constructor.name;
                  else if (g === typeof Et)
                    Et = g === typeof At[Et.name] && isNaN(+Ct) ? void 0 : Et.name != null && u !== Et.name ? Et.name : He(Et.toString().replace(/[ \t\r\n]+/g, " "));
                  else if (typeof Et == "bigint")
                    Et = String(Et.toString());
                  else {
                    if (Number.isNaN(Et))
                      return "NaN";
                    ht === !0 || ((Zt = Et == null ? void 0 : Et.$) === null || Zt === void 0 ? void 0 : Zt.gubu$) !== !0 && i !== ((Qt = Et == null ? void 0 : Et.$) === null || Qt === void 0 ? void 0 : Qt.gubu$) || (Et = he(Et));
                  }
                  return Et;
                }), yt = String(yt);
              } catch (Ct) {
                yt = xt(String(R));
              }
              return et === !0 && (yt = yt.replace(/^"/, u).replace(/"$/, u)), yt;
            }
            function Vt(R) {
              return R == null || S !== typeof R ? R : ot(xt(R));
            }
            if (b !== typeof window) {
              let R = [{ b: jt, n: X }, { b: ce, n: "After" }, { b: U, n: "All" }, { b: F, n: "Any" }, { b: Wt, n: "Before" }, { b: mt, n: K }, { b: ye, n: "Check" }, { b: Ce, n: "Closed" }, { b: _e, n: "Define" }, { b: H, n: "Empty" }, { b: Ot, n: "Exact" }, { b: Ft, n: "Func" }, { b: _t, n: "Max" }, { b: De, n: "Min" }, { b: P, n: "Never" }, { b: St, n: "Len" }, { b: ft, n: "One" }, { b: ge, n: "Open" }, { b: lt, n: "Optional" }, { b: je, n: "Refer" }, { b: Ie, n: "Rename" }, { b: G, n: "Required" }, { b: It, n: "Skip" }, { b: rt, n: D }, { b: kt, n: j }];
              for (let z of R)
                ut(z.b, a, { value: z.n });
            }
            Object.assign(At, { Gubu: At, Above: jt, After: ce, All: U, Any: F, Before: Wt, Below: mt, Check: ye, Closed: Ce, Define: _e, Empty: H, Exact: Ot, Func: Ft, Max: _t, Min: De, Never: P, Len: St, One: ft, Open: ge, Optional: lt, Refer: je, Rename: Ie, Required: G, Skip: It, Some: rt, Value: kt, GAbove: jt, GAfter: ce, GAll: U, GAny: F, GBefore: Wt, GBelow: mt, GCheck: ye, GClosed: Ce, GDefine: _e, GEmpty: H, GExact: Ot, GFunc: Ft, GMax: _t, GMin: De, GNever: P, GLen: St, GOne: ft, GOpen: ge, GOptional: lt, GRefer: je, GRename: Ie, GRequired: G, GSkip: It, GSome: rt, GValue: kt, G$: (R) => Q(kn(Ge({}, R), { $: { gubu$: !0 } })), buildize: Dt, makeErr: it, stringify: $, truncate: He, nodize: Q }), ut(At, a, { value: "gubu" });
            const W = At;
            n.Gubu = W;
            const { Gubu: N } = n;
            return N;
          });
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 103: [function(x, C, c) {
      var p = x("get-intrinsic"), v = p("%Object.defineProperty%", !0), n = function() {
        if (v)
          try {
            return v({}, "a", { value: 1 }), !0;
          } catch (i) {
            return !1;
          }
        return !1;
      };
      n.hasArrayLengthDefineBug = function() {
        if (!n())
          return null;
        try {
          return v([], "length", { value: 1 }).length !== 1;
        } catch (i) {
          return !0;
        }
      }, C.exports = n;
    }, { "get-intrinsic": 101 }], 104: [function(x, C, c) {
      var p = typeof Symbol != "undefined" && Symbol, v = x("./shams");
      C.exports = function() {
        return typeof p == "function" && typeof Symbol == "function" && typeof p("foo") == "symbol" && typeof Symbol("bar") == "symbol" && v();
      };
    }, { "./shams": 105 }], 105: [function(x, C, c) {
      C.exports = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
          return !1;
        if (typeof Symbol.iterator == "symbol")
          return !0;
        var p = {}, v = Symbol("test"), n = Object(v);
        if (typeof v == "string" || Object.prototype.toString.call(v) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
          return !1;
        for (v in p[v] = 42, p)
          return !1;
        if (typeof Object.keys == "function" && Object.keys(p).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(p).length !== 0)
          return !1;
        var i = Object.getOwnPropertySymbols(p);
        if (i.length !== 1 || i[0] !== v || !Object.prototype.propertyIsEnumerable.call(p, v))
          return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
          var s = Object.getOwnPropertyDescriptor(p, v);
          if (s.value !== 42 || s.enumerable !== !0)
            return !1;
        }
        return !0;
      };
    }, {}], 106: [function(x, C, c) {
      var p = x("has-symbols/shams");
      C.exports = function() {
        return p() && !!Symbol.toStringTag;
      };
    }, { "has-symbols/shams": 105 }], 107: [function(x, C, c) {
      var p = x("function-bind");
      C.exports = p.call(Function.call, Object.prototype.hasOwnProperty);
    }, { "function-bind": 99 }], 108: [function(x, C, c) {
      var p = x("http"), v = x("url"), n = C.exports;
      for (var i in p)
        p.hasOwnProperty(i) && (n[i] = p[i]);
      function s(r) {
        if (typeof r == "string" && (r = v.parse(r)), r.protocol || (r.protocol = "https:"), r.protocol !== "https:")
          throw new Error('Protocol "' + r.protocol + '" not supported. Expected "https:"');
        return r;
      }
      n.request = function(r, o) {
        return r = s(r), p.request.call(this, r, o);
      }, n.get = function(r, o) {
        return r = s(r), p.get.call(this, r, o);
      };
    }, { http: 208, url: 229 }], 109: [function(x, C, c) {
      c.read = function(p, v, n, i, s) {
        var r, o, u = 8 * s - i - 1, a = (1 << u) - 1, f = a >> 1, y = -7, T = n ? s - 1 : 0, h = n ? -1 : 1, _ = p[v + T];
        for (T += h, r = _ & (1 << -y) - 1, _ >>= -y, y += u; y > 0; r = 256 * r + p[v + T], T += h, y -= 8)
          ;
        for (o = r & (1 << -y) - 1, r >>= -y, y += i; y > 0; o = 256 * o + p[v + T], T += h, y -= 8)
          ;
        if (r === 0)
          r = 1 - f;
        else {
          if (r === a)
            return o ? NaN : 1 / 0 * (_ ? -1 : 1);
          o += Math.pow(2, i), r -= f;
        }
        return (_ ? -1 : 1) * o * Math.pow(2, r - i);
      }, c.write = function(p, v, n, i, s, r) {
        var o, u, a, f = 8 * r - s - 1, y = (1 << f) - 1, T = y >> 1, h = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, _ = i ? 0 : r - 1, g = i ? 1 : -1, S = v < 0 || v === 0 && 1 / v < 0 ? 1 : 0;
        for (v = Math.abs(v), isNaN(v) || v === 1 / 0 ? (u = isNaN(v) ? 1 : 0, o = y) : (o = Math.floor(Math.log(v) / Math.LN2), v * (a = Math.pow(2, -o)) < 1 && (o--, a *= 2), (v += o + T >= 1 ? h / a : h * Math.pow(2, 1 - T)) * a >= 2 && (o++, a /= 2), o + T >= y ? (u = 0, o = y) : o + T >= 1 ? (u = (v * a - 1) * Math.pow(2, s), o += T) : (u = v * Math.pow(2, T - 1) * Math.pow(2, s), o = 0)); s >= 8; p[n + _] = 255 & u, _ += g, u /= 256, s -= 8)
          ;
        for (o = o << s | u, f += s; f > 0; p[n + _] = 255 & o, _ += g, o /= 256, f -= 8)
          ;
        p[n + _ - g] |= 128 * S;
      };
    }, {}], 110: [function(x, C, c) {
      typeof Object.create == "function" ? C.exports = function(p, v) {
        v && (p.super_ = v, p.prototype = Object.create(v.prototype, { constructor: { value: p, enumerable: !1, writable: !0, configurable: !0 } }));
      } : C.exports = function(p, v) {
        if (v) {
          p.super_ = v;
          var n = function() {
          };
          n.prototype = v.prototype, p.prototype = new n(), p.prototype.constructor = p;
        }
      };
    }, {}], 111: [function(x, C, c) {
      var p = x("has-tostringtag/shams")(), v = x("call-bind/callBound"), n = v("Object.prototype.toString"), i = function(o) {
        return !(p && o && typeof o == "object" && Symbol.toStringTag in o) && n(o) === "[object Arguments]";
      }, s = function(o) {
        return !!i(o) || o !== null && typeof o == "object" && typeof o.length == "number" && o.length >= 0 && n(o) !== "[object Array]" && n(o.callee) === "[object Function]";
      }, r = function() {
        return i(arguments);
      }();
      i.isLegacyArguments = s, C.exports = r ? i : s;
    }, { "call-bind/callBound": 48, "has-tostringtag/shams": 106 }], 112: [function(x, C, c) {
      var p, v, n = Function.prototype.toString, i = typeof Reflect == "object" && Reflect !== null && Reflect.apply;
      if (typeof i == "function" && typeof Object.defineProperty == "function")
        try {
          p = Object.defineProperty({}, "length", { get: function() {
            throw v;
          } }), v = {}, i(function() {
            throw 42;
          }, null, p);
        } catch (h) {
          h !== v && (i = null);
        }
      else
        i = null;
      var s = /^\s*class\b/, r = function(h) {
        try {
          var _ = n.call(h);
          return s.test(_);
        } catch (g) {
          return !1;
        }
      }, o = function(h) {
        try {
          return !r(h) && (n.call(h), !0);
        } catch (_) {
          return !1;
        }
      }, u = Object.prototype.toString, a = "[object Function]", f = "[object GeneratorFunction]", y = typeof Symbol == "function" && !!Symbol.toStringTag, T = typeof document == "object" && document.all === void 0 && document.all !== void 0 ? document.all : {};
      C.exports = i ? function(h) {
        if (h === T)
          return !0;
        if (!h || typeof h != "function" && typeof h != "object")
          return !1;
        if (typeof h == "function" && !h.prototype)
          return !0;
        try {
          i(h, null, p);
        } catch (_) {
          if (_ !== v)
            return !1;
        }
        return !r(h);
      } : function(h) {
        if (h === T)
          return !0;
        if (!h || typeof h != "function" && typeof h != "object")
          return !1;
        if (typeof h == "function" && !h.prototype)
          return !0;
        if (y)
          return o(h);
        if (r(h))
          return !1;
        var _ = u.call(h);
        return _ === a || _ === f;
      };
    }, {}], 113: [function(x, C, c) {
      var p = Date.prototype.getDay, v = function(r) {
        try {
          return p.call(r), !0;
        } catch (o) {
          return !1;
        }
      }, n = Object.prototype.toString, i = "[object Date]", s = x("has-tostringtag/shams")();
      C.exports = function(r) {
        return typeof r == "object" && r !== null && (s ? v(r) : n.call(r) === i);
      };
    }, { "has-tostringtag/shams": 106 }], 114: [function(x, C, c) {
      var p, v = Object.prototype.toString, n = Function.prototype.toString, i = /^\s*(?:function)?\*/, s = x("has-tostringtag/shams")(), r = Object.getPrototypeOf, o = function() {
        if (!s)
          return !1;
        try {
          return Function("return function*() {}")();
        } catch (u) {
        }
      };
      C.exports = function(u) {
        if (typeof u != "function")
          return !1;
        if (i.test(n.call(u)))
          return !0;
        if (!s)
          return v.call(u) === "[object GeneratorFunction]";
        if (!r)
          return !1;
        if (p === void 0) {
          var a = o();
          p = !!a && r(a);
        }
        return r(u) === p;
      };
    }, { "has-tostringtag/shams": 106 }], 115: [function(x, C, c) {
      var p, v, n, i, s = x("call-bind/callBound"), r = x("has-tostringtag/shams")();
      if (r) {
        p = s("Object.prototype.hasOwnProperty"), v = s("RegExp.prototype.exec"), n = {};
        var o = function() {
          throw n;
        };
        i = { toString: o, valueOf: o }, typeof Symbol.toPrimitive == "symbol" && (i[Symbol.toPrimitive] = o);
      }
      var u = s("Object.prototype.toString"), a = Object.getOwnPropertyDescriptor, f = "[object RegExp]";
      C.exports = r ? function(y) {
        if (!y || typeof y != "object")
          return !1;
        var T = a(y, "lastIndex");
        if (!(T && p(T, "value")))
          return !1;
        try {
          v(y, i);
        } catch (h) {
          return h === n;
        }
      } : function(y) {
        return !(!y || typeof y != "object" && typeof y != "function") && u(y) === f;
      };
    }, { "call-bind/callBound": 48, "has-tostringtag/shams": 106 }], 116: [function(x, C, c) {
      var p = String.prototype.valueOf, v = function(r) {
        try {
          return p.call(r), !0;
        } catch (o) {
          return !1;
        }
      }, n = Object.prototype.toString, i = "[object String]", s = x("has-tostringtag/shams")();
      C.exports = function(r) {
        return typeof r == "string" || typeof r == "object" && (s ? v(r) : n.call(r) === i);
      };
    }, { "has-tostringtag/shams": 106 }], 117: [function(x, C, c) {
      var p = Object.prototype.toString, v = x("has-symbols")();
      if (v) {
        var n = Symbol.prototype.toString, i = /^Symbol\(.*\)$/, s = function(r) {
          return typeof r.valueOf() == "symbol" && i.test(n.call(r));
        };
        C.exports = function(r) {
          if (typeof r == "symbol")
            return !0;
          if (p.call(r) !== "[object Symbol]")
            return !1;
          try {
            return s(r);
          } catch (o) {
            return !1;
          }
        };
      } else
        C.exports = function(r) {
          return !1;
        };
    }, { "has-symbols": 104 }], 118: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = x("for-each"), n = x("available-typed-arrays"), i = x("call-bind/callBound"), s = i("Object.prototype.toString"), r = x("has-tostringtag/shams")(), o = typeof globalThis == "undefined" ? p : globalThis, u = n(), a = i("Array.prototype.indexOf", !0) || function(g, S) {
            for (var d = 0; d < g.length; d += 1)
              if (g[d] === S)
                return d;
            return -1;
          }, f = i("String.prototype.slice"), y = {}, T = x("es-abstract/helpers/getOwnPropertyDescriptor"), h = Object.getPrototypeOf;
          r && T && h && v(u, function(g) {
            var S = new o[g]();
            if (Symbol.toStringTag in S) {
              var d = h(S), b = T(d, Symbol.toStringTag);
              if (!b) {
                var k = h(d);
                b = T(k, Symbol.toStringTag);
              }
              y[g] = b.get;
            }
          });
          var _ = function(g) {
            var S = !1;
            return v(y, function(d, b) {
              if (!S)
                try {
                  S = d.call(g) === b;
                } catch (k) {
                }
            }), S;
          };
          C.exports = function(g) {
            if (!g || typeof g != "object")
              return !1;
            if (!(r && Symbol.toStringTag in g)) {
              var S = f(s(g), 8, -1);
              return a(u, S) > -1;
            }
            return !!T && _(g);
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "available-typed-arrays": 40, "call-bind/callBound": 48, "es-abstract/helpers/getOwnPropertyDescriptor": 84, "for-each": 97, "has-tostringtag/shams": 106 }], 119: [function(x, C, c) {
      (function() {
        var p = this || {}, v = p.jsonic, n = p.jsonic = function(s) {
          return Object.prototype.toString.call(s) !== "[object String]" ? Object.prototype.toString.call(s).match(/\[object (Object|Array)\]/) ? s : "" + s : ((s = s.trim())[0] != "{" && s[0] != "[" && (s = "{" + s + "}"), i.parse(s));
        };
        n.noConflict = function() {
          return p.jsonic = v, n;
        };
        var i = function() {
          function s(r, o, u, a, f, y) {
            this.message = r, this.expected = o, this.found = u, this.offset = a, this.line = f, this.column = y, this.name = "SyntaxError";
          }
          return function(r, o) {
            function u() {
              this.constructor = r;
            }
            u.prototype = o.prototype, r.prototype = new u();
          }(s, Error), { SyntaxError: s, parse: function(r) {
            var o, u = arguments.length > 1 ? arguments[1] : {}, a = {}, f = { start: wn }, y = wn, T = a, h = function(Tt) {
              return Tt;
            }, _ = function(Tt) {
              return Tt;
            }, g = "{", S = { type: "literal", value: "{", description: '"{"' }, d = "}", b = { type: "literal", value: "}", description: '"}"' }, k = function() {
              return {};
            }, O = function(Tt) {
              return Tt;
            }, A = null, l = ",", E = { type: "literal", value: ",", description: '","' }, M = function(Tt, Mt) {
              var re = {};
              Tt && (re[Tt[0]] = an(Tt[1]));
              for (var fe = 0; fe < Mt.length; fe++)
                re[Mt[fe][2][0]] = an(Mt[fe][2][1]);
              return re;
            }, B = ":", X = { type: "literal", value: ":", description: '":"' }, K = function(Tt, Mt) {
              return [Tt, Mt];
            }, D = "[", j = { type: "literal", value: "[", description: '"["' }, Z = "]", tt = { type: "literal", value: "]", description: '"]"' }, nt = function() {
              return [];
            }, ct = function(Tt) {
              return Tt;
            }, ut = function(Tt, Mt) {
              var re = [];
              Tt != null && re.push(an(Tt));
              for (var fe = 0; fe < Mt.length; fe++)
                re.push(an(Mt[fe][2]));
              return re;
            }, V = "true", ot = { type: "literal", value: "true", description: '"true"' }, xt = function() {
              return !0;
            }, Ut = "false", pt = { type: "literal", value: "false", description: '"false"' }, at = function() {
              return !1;
            }, bt = "null", Q = { type: "literal", value: "null", description: '"null"' }, At = function() {
              return mn;
            }, Pt = function(Tt) {
              return Tt.join("").trim();
            }, q = { type: "other", description: "double-quote string" }, G = '"', lt = { type: "literal", value: '"', description: '"\\""' }, It = function() {
              return "";
            }, Ft = function(Tt) {
              return Tt;
            }, H = { type: "other", description: "single-quote string" }, F = "'", P = { type: "literal", value: "'", description: `"'"` }, U = function(Tt) {
              return Tt.join("");
            }, rt = /^[^"\\\0-\x1F]/, ft = { type: "class", value: '[^"\\\\\\0-\\x1F]', description: '[^"\\\\\\0-\\x1F]' }, Ot = '\\"', Wt = { type: "literal", value: '\\"', description: '"\\\\\\""' }, ce = function() {
              return '"';
            }, ye = "\\\\", ge = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, Ce = function() {
              return "\\";
            }, _e = "\\/", je = { type: "literal", value: "\\/", description: '"\\\\/"' }, Ie = function() {
              return "/";
            }, $e = "\\b", He = { type: "literal", value: "\\b", description: '"\\\\b"' }, De = function() {
              return "\b";
            }, _t = "\\f", jt = { type: "literal", value: "\\f", description: '"\\\\f"' }, mt = function() {
              return "\f";
            }, St = "\\n", kt = { type: "literal", value: "\\n", description: '"\\\\n"' }, Dt = function() {
              return `
`;
            }, it = "\\r", qt = { type: "literal", value: "\\r", description: '"\\\\r"' }, he = function() {
              return "\r";
            }, $ = "\\t", Vt = { type: "literal", value: "\\t", description: '"\\\\t"' }, W = function() {
              return "	";
            }, N = "\\u", R = { type: "literal", value: "\\u", description: '"\\\\u"' }, z = function(Tt, Mt, re, fe) {
              return String.fromCharCode(parseInt("0x" + Tt + Mt + re + fe));
            }, et = /^[^'\\\0-\x1F]/, ht = { type: "class", value: "[^'\\\\\\0-\\x1F]", description: "[^'\\\\\\0-\\x1F]" }, yt = "\\'", Ct = { type: "literal", value: "\\'", description: `"\\\\'"` }, Et = function() {
              return "'";
            }, Zt = { type: "other", description: "key" }, Qt = /^[a-zA-Z0-9_$\-]/, Rt = { type: "class", value: "[a-zA-Z0-9_$\\-]", description: "[a-zA-Z0-9_$\\-]" }, Lt = function(Tt) {
              return Tt.join("");
            }, te = /^[^,}\]]/, Oe = { type: "class", value: "[^,}\\]]", description: "[^,}\\]]" }, ke = { type: "other", description: "number" }, Gt = function(Tt, Mt, re, fe) {
              return fe.length === 0 ? parseFloat(Tt + Mt + re) : (Tt + Mt + re + fe.join("")).trim();
            }, be = function(Tt, Mt, re) {
              return re.length === 0 ? parseFloat(Tt + Mt) : (Tt + Mt + re.join("")).trim();
            }, ve = function(Tt, Mt, re) {
              return re.length === 0 ? parseFloat(Tt + Mt) : (Tt + Mt + re.join("")).trim();
            }, we = function(Tt, Mt) {
              return Mt.length === 0 ? parseFloat(Tt) : (Tt + Mt.join("")).trim();
            }, se = function(Tt, Mt) {
              return Tt + Mt;
            }, Ue = "-", rn = { type: "literal", value: "-", description: '"-"' }, pn = function(Tt, Mt) {
              return "-" + Tt + Mt;
            }, Tn = function(Tt) {
              return "-" + Tt;
            }, An = ".", vn = { type: "literal", value: ".", description: '"."' }, ln = function(Tt) {
              return "." + Tt;
            }, Yt = function(Tt, Mt) {
              return Tt + Mt;
            }, oe = function(Tt) {
              return Tt.join("");
            }, ie = /^[eE]/, Ye = { type: "class", value: "[eE]", description: "[eE]" }, We = /^[+\-]/, Le = { type: "class", value: "[+\\-]", description: "[+\\-]" }, Te = function(Tt, Mt) {
              return Tt + (Mt || "");
            }, Re = /^[0-9]/, en = { type: "class", value: "[0-9]", description: "[0-9]" }, cn = /^[1-9]/, J = { type: "class", value: "[1-9]", description: "[1-9]" }, st = /^[0-9a-fA-F]/, gt = { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" }, zt = { type: "other", description: "whitespace" }, Xt = /^[ \t\n\r]/, Jt = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" }, vt = 0, Me = 0, qe = { line: 1, column: 1, seenCR: !1 }, Ke = 0, Ae = [], le = 0;
            if ("startRule" in u) {
              if (!(u.startRule in f))
                throw new Error(`Can't start parsing from rule "` + u.startRule + '".');
              y = f[u.startRule];
            }
            function gn(Tt) {
              return Me !== Tt && (Me > Tt && (Me = 0, qe = { line: 1, column: 1, seenCR: !1 }), function(Mt, re, fe) {
                var de, me;
                for (de = re; de < fe; de++)
                  (me = r.charAt(de)) === `
` ? (Mt.seenCR || Mt.line++, Mt.column = 1, Mt.seenCR = !1) : me === "\r" || me === "\u2028" || me === "\u2029" ? (Mt.line++, Mt.column = 1, Mt.seenCR = !0) : (Mt.column++, Mt.seenCR = !1);
              }(qe, Me, Tt), Me = Tt), qe;
            }
            function pe(Tt) {
              vt < Ke || (vt > Ke && (Ke = vt, Ae = []), Ae.push(Tt));
            }
            function bn(Tt, Mt, re) {
              var fe = gn(re), de = re < r.length ? r.charAt(re) : null;
              return Mt !== null && function(me) {
                var Ze = 1;
                for (me.sort(function(xe, ze) {
                  return xe.description < ze.description ? -1 : xe.description > ze.description ? 1 : 0;
                }); Ze < me.length; )
                  me[Ze - 1] === me[Ze] ? me.splice(Ze, 1) : Ze++;
              }(Mt), new s(Tt !== null ? Tt : function(me, Ze) {
                var xe, ze = new Array(me.length);
                for (xe = 0; xe < me.length; xe++)
                  ze[xe] = me[xe].description;
                return "Expected " + (me.length > 1 ? ze.slice(0, -1).join(", ") + " or " + ze[me.length - 1] : ze[0]) + " but " + (Ze ? '"' + function(wt) {
                  function Bt(Ht) {
                    return Ht.charCodeAt(0).toString(16).toUpperCase();
                  }
                  return wt.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(Ht) {
                    return "\\x0" + Bt(Ht);
                  }).replace(/[\x10-\x1F\x80-\xFF]/g, function(Ht) {
                    return "\\x" + Bt(Ht);
                  }).replace(/[\u0180-\u0FFF]/g, function(Ht) {
                    return "\\u0" + Bt(Ht);
                  }).replace(/[\u1080-\uFFFF]/g, function(Ht) {
                    return "\\u" + Bt(Ht);
                  });
                }(Ze) + '"' : "end of input") + " found.";
              }(Mt, de), Mt, de, re, fe.line, fe.column);
            }
            function wn() {
              var Tt, Mt;
              return Tt = vt, Ve() !== a && (Mt = Mn()) !== a ? Tt = h(Mt) : (vt = Tt, Tt = T), Tt === a && (Tt = vt, Ve() !== a && (Mt = On()) !== a ? Tt = _(Mt) : (vt = Tt, Tt = T)), Tt;
            }
            function Mn() {
              var Tt, Mt, re, fe;
              return Tt = vt, r.charCodeAt(vt) === 123 ? (Mt = g, vt++) : (Mt = a, le === 0 && pe(S)), Mt !== a && Ve() !== a ? (r.charCodeAt(vt) === 125 ? (re = d, vt++) : (re = a, le === 0 && pe(b)), re !== a && (fe = Ve()) !== a ? Tt = Mt = k() : (vt = Tt, Tt = T)) : (vt = Tt, Tt = T), Tt === a && (Tt = vt, r.charCodeAt(vt) === 123 ? (Mt = g, vt++) : (Mt = a, le === 0 && pe(S)), Mt !== a && Ve() !== a && (re = function() {
                var de, me, Ze, xe, ze, wt, Bt, Ht;
                if (de = vt, r.charCodeAt(vt) === 44 ? (me = l, vt++) : (me = a, le === 0 && pe(E)), me === a && (me = A), me !== a)
                  if ((Ze = Pn()) === a && (Ze = A), Ze !== a) {
                    for (xe = [], ze = vt, r.charCodeAt(vt) === 44 ? (wt = l, vt++) : (wt = a, le === 0 && pe(E)), wt !== a && (Bt = Ve()) !== a && (Ht = Pn()) !== a ? ze = wt = [wt, Bt, Ht] : (vt = ze, ze = T); ze !== a; )
                      xe.push(ze), ze = vt, r.charCodeAt(vt) === 44 ? (wt = l, vt++) : (wt = a, le === 0 && pe(E)), wt !== a && (Bt = Ve()) !== a && (Ht = Pn()) !== a ? ze = wt = [wt, Bt, Ht] : (vt = ze, ze = T);
                    xe !== a ? (r.charCodeAt(vt) === 44 ? (ze = l, vt++) : (ze = a, le === 0 && pe(E)), ze === a && (ze = A), ze !== a && (wt = Ve()) !== a ? (me = M(Ze, xe), de = me) : (vt = de, de = T)) : (vt = de, de = T);
                  } else
                    vt = de, de = T;
                else
                  vt = de, de = T;
                return de;
              }()) !== a ? (r.charCodeAt(vt) === 125 ? (fe = d, vt++) : (fe = a, le === 0 && pe(b)), fe !== a && Ve() !== a ? Tt = Mt = O(re) : (vt = Tt, Tt = T)) : (vt = Tt, Tt = T)), Tt;
            }
            function Pn() {
              var Tt, Mt, re, fe;
              return Tt = vt, (Mt = function() {
                var de, me, Ze;
                if (le++, (de = $t()) === a && (de = ne()) === a) {
                  if (de = vt, me = [], Qt.test(r.charAt(vt)) ? (Ze = r.charAt(vt), vt++) : (Ze = a, le === 0 && pe(Rt)), Ze !== a)
                    for (; Ze !== a; )
                      me.push(Ze), Qt.test(r.charAt(vt)) ? (Ze = r.charAt(vt), vt++) : (Ze = a, le === 0 && pe(Rt));
                  else
                    me = T;
                  me !== a && (me = Lt(me)), de = me;
                }
                return le--, de === a && (me = a, le === 0 && pe(Zt)), de;
              }()) !== a && Ve() !== a ? (r.charCodeAt(vt) === 58 ? (re = B, vt++) : (re = a, le === 0 && pe(X)), re !== a && Ve() !== a && (fe = Ln()) !== a ? Tt = Mt = K(Mt, fe) : (vt = Tt, Tt = T)) : (vt = Tt, Tt = T), Tt;
            }
            function On() {
              var Tt, Mt, re, fe;
              return Tt = vt, r.charCodeAt(vt) === 91 ? (Mt = D, vt++) : (Mt = a, le === 0 && pe(j)), Mt !== a && Ve() !== a ? (r.charCodeAt(vt) === 93 ? (re = Z, vt++) : (re = a, le === 0 && pe(tt)), re !== a && (fe = Ve()) !== a ? Tt = Mt = nt() : (vt = Tt, Tt = T)) : (vt = Tt, Tt = T), Tt === a && (Tt = vt, r.charCodeAt(vt) === 91 ? (Mt = D, vt++) : (Mt = a, le === 0 && pe(j)), Mt !== a && Ve() !== a && (re = function() {
                var de, me, Ze, xe, ze, wt, Bt, Ht;
                if (de = vt, r.charCodeAt(vt) === 44 ? (me = l, vt++) : (me = a, le === 0 && pe(E)), me === a && (me = A), me !== a)
                  if ((Ze = Ln()) === a && (Ze = A), Ze !== a) {
                    for (xe = [], ze = vt, r.charCodeAt(vt) === 44 ? (wt = l, vt++) : (wt = a, le === 0 && pe(E)), wt !== a && (Bt = Ve()) !== a && (Ht = Ln()) !== a ? ze = wt = [wt, Bt, Ht] : (vt = ze, ze = T); ze !== a; )
                      xe.push(ze), ze = vt, r.charCodeAt(vt) === 44 ? (wt = l, vt++) : (wt = a, le === 0 && pe(E)), wt !== a && (Bt = Ve()) !== a && (Ht = Ln()) !== a ? ze = wt = [wt, Bt, Ht] : (vt = ze, ze = T);
                    xe !== a ? (r.charCodeAt(vt) === 44 ? (ze = l, vt++) : (ze = a, le === 0 && pe(E)), ze === a && (ze = A), ze !== a && (wt = Ve()) !== a ? (me = ut(Ze, xe), de = me) : (vt = de, de = T)) : (vt = de, de = T);
                  } else
                    vt = de, de = T;
                else
                  vt = de, de = T;
                return de;
              }()) !== a ? (r.charCodeAt(vt) === 93 ? (fe = Z, vt++) : (fe = a, le === 0 && pe(tt)), fe !== a && Ve() !== a ? Tt = Mt = ct(re) : (vt = Tt, Tt = T)) : (vt = Tt, Tt = T)), Tt;
            }
            function Ln() {
              var Tt, Mt;
              return (Tt = $t()) === a && (Tt = ne()) === a && (Tt = Mn()) === a && (Tt = On()) === a && (Tt = vt, r.substr(vt, 4) === V ? (Mt = V, vt += 4) : (Mt = a, le === 0 && pe(ot)), Mt !== a && Ve() !== a ? Tt = Mt = xt() : (vt = Tt, Tt = T), Tt === a && (Tt = vt, r.substr(vt, 5) === Ut ? (Mt = Ut, vt += 5) : (Mt = a, le === 0 && pe(pt)), Mt !== a && Ve() !== a ? Tt = Mt = at() : (vt = Tt, Tt = T), Tt === a && (Tt = vt, r.substr(vt, 4) === bt ? (Mt = bt, vt += 4) : (Mt = a, le === 0 && pe(Q)), Mt !== a && Ve() !== a ? Tt = Mt = At() : (vt = Tt, Tt = T), Tt === a && (Tt = function() {
                var re, fe, de, me, Ze, xe, ze;
                if (le++, re = vt, (fe = Ee()) !== a)
                  if ((de = on()) !== a)
                    if ((me = Ne()) !== a)
                      if ((Ze = Ve()) !== a) {
                        for (xe = [], ze = Fe(); ze !== a; )
                          xe.push(ze), ze = Fe();
                        xe !== a ? (fe = Gt(fe, de, me, xe), re = fe) : (vt = re, re = T);
                      } else
                        vt = re, re = T;
                    else
                      vt = re, re = T;
                  else
                    vt = re, re = T;
                else
                  vt = re, re = T;
                if (re === a) {
                  if (re = vt, (fe = Ee()) !== a)
                    if ((de = on()) !== a)
                      if ((me = Ve()) !== a) {
                        for (Ze = [], xe = Fe(); xe !== a; )
                          Ze.push(xe), xe = Fe();
                        Ze !== a ? (fe = be(fe, de, Ze), re = fe) : (vt = re, re = T);
                      } else
                        vt = re, re = T;
                    else
                      vt = re, re = T;
                  else
                    vt = re, re = T;
                  if (re === a) {
                    if (re = vt, (fe = Ee()) !== a)
                      if ((de = Ne()) !== a)
                        if ((me = Ve()) !== a) {
                          for (Ze = [], xe = Fe(); xe !== a; )
                            Ze.push(xe), xe = Fe();
                          Ze !== a ? (fe = ve(fe, de, Ze), re = fe) : (vt = re, re = T);
                        } else
                          vt = re, re = T;
                      else
                        vt = re, re = T;
                    else
                      vt = re, re = T;
                    if (re === a)
                      if (re = vt, (fe = Ee()) !== a)
                        if ((de = Ve()) !== a) {
                          for (me = [], Ze = Fe(); Ze !== a; )
                            me.push(Ze), Ze = Fe();
                          me !== a ? (fe = we(fe, me), re = fe) : (vt = re, re = T);
                        } else
                          vt = re, re = T;
                      else
                        vt = re, re = T;
                  }
                }
                return le--, re === a && (fe = a, le === 0 && pe(ke)), re;
              }()) === a && (Tt = vt, (Mt = function() {
                var re, fe;
                if (re = [], (fe = Fe()) !== a)
                  for (; fe !== a; )
                    re.push(fe), fe = Fe();
                else
                  re = T;
                return re;
              }()) !== a && (Mt = Pt(Mt)), Tt = Mt)))), Tt;
            }
            function $t() {
              var Tt, Mt, re, fe;
              return le++, Tt = vt, r.charCodeAt(vt) === 34 ? (Mt = G, vt++) : (Mt = a, le === 0 && pe(lt)), Mt !== a ? (r.charCodeAt(vt) === 34 ? (re = G, vt++) : (re = a, le === 0 && pe(lt)), re !== a && (fe = Ve()) !== a ? Tt = Mt = It() : (vt = Tt, Tt = T)) : (vt = Tt, Tt = T), Tt === a && (Tt = vt, r.charCodeAt(vt) === 34 ? (Mt = G, vt++) : (Mt = a, le === 0 && pe(lt)), Mt !== a && (re = function() {
                var de, me;
                if (de = [], (me = ae()) !== a)
                  for (; me !== a; )
                    de.push(me), me = ae();
                else
                  de = T;
                return de !== a && (de = U(de)), de;
              }()) !== a ? (r.charCodeAt(vt) === 34 ? (fe = G, vt++) : (fe = a, le === 0 && pe(lt)), fe !== a && Ve() !== a ? Tt = Mt = Ft(re) : (vt = Tt, Tt = T)) : (vt = Tt, Tt = T)), le--, Tt === a && (Mt = a, le === 0 && pe(q)), Tt;
            }
            function ne() {
              var Tt, Mt, re, fe;
              return le++, Tt = vt, r.charCodeAt(vt) === 39 ? (Mt = F, vt++) : (Mt = a, le === 0 && pe(P)), Mt !== a ? (r.charCodeAt(vt) === 39 ? (re = F, vt++) : (re = a, le === 0 && pe(P)), re !== a && (fe = Ve()) !== a ? Tt = Mt = It() : (vt = Tt, Tt = T)) : (vt = Tt, Tt = T), Tt === a && (Tt = vt, r.charCodeAt(vt) === 39 ? (Mt = F, vt++) : (Mt = a, le === 0 && pe(P)), Mt !== a && (re = function() {
                var de, me;
                if (de = [], (me = Be()) !== a)
                  for (; me !== a; )
                    de.push(me), me = Be();
                else
                  de = T;
                return de !== a && (de = U(de)), de;
              }()) !== a ? (r.charCodeAt(vt) === 39 ? (fe = F, vt++) : (fe = a, le === 0 && pe(P)), fe !== a && Ve() !== a ? Tt = Mt = Ft(re) : (vt = Tt, Tt = T)) : (vt = Tt, Tt = T)), le--, Tt === a && (Mt = a, le === 0 && pe(H)), Tt;
            }
            function ae() {
              var Tt, Mt, re, fe, de, me;
              return rt.test(r.charAt(vt)) ? (Tt = r.charAt(vt), vt++) : (Tt = a, le === 0 && pe(ft)), Tt === a && (Tt = vt, r.substr(vt, 2) === Ot ? (Mt = Ot, vt += 2) : (Mt = a, le === 0 && pe(Wt)), Mt !== a && (Mt = ce()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === ye ? (Mt = ye, vt += 2) : (Mt = a, le === 0 && pe(ge)), Mt !== a && (Mt = Ce()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === _e ? (Mt = _e, vt += 2) : (Mt = a, le === 0 && pe(je)), Mt !== a && (Mt = Ie()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === $e ? (Mt = $e, vt += 2) : (Mt = a, le === 0 && pe(He)), Mt !== a && (Mt = De()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === _t ? (Mt = _t, vt += 2) : (Mt = a, le === 0 && pe(jt)), Mt !== a && (Mt = mt()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === St ? (Mt = St, vt += 2) : (Mt = a, le === 0 && pe(kt)), Mt !== a && (Mt = Dt()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === it ? (Mt = it, vt += 2) : (Mt = a, le === 0 && pe(qt)), Mt !== a && (Mt = he()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === $ ? (Mt = $, vt += 2) : (Mt = a, le === 0 && pe(Vt)), Mt !== a && (Mt = W()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === N ? (Mt = N, vt += 2) : (Mt = a, le === 0 && pe(R)), Mt !== a && (re = un()) !== a && (fe = un()) !== a && (de = un()) !== a && (me = un()) !== a ? Tt = Mt = z(re, fe, de, me) : (vt = Tt, Tt = T)))))))))), Tt;
            }
            function Be() {
              var Tt, Mt, re, fe, de, me;
              return et.test(r.charAt(vt)) ? (Tt = r.charAt(vt), vt++) : (Tt = a, le === 0 && pe(ht)), Tt === a && (Tt = vt, r.substr(vt, 2) === yt ? (Mt = yt, vt += 2) : (Mt = a, le === 0 && pe(Ct)), Mt !== a && (Mt = Et()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === ye ? (Mt = ye, vt += 2) : (Mt = a, le === 0 && pe(ge)), Mt !== a && (Mt = Ce()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === _e ? (Mt = _e, vt += 2) : (Mt = a, le === 0 && pe(je)), Mt !== a && (Mt = Ie()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === $e ? (Mt = $e, vt += 2) : (Mt = a, le === 0 && pe(He)), Mt !== a && (Mt = De()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === _t ? (Mt = _t, vt += 2) : (Mt = a, le === 0 && pe(jt)), Mt !== a && (Mt = mt()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === St ? (Mt = St, vt += 2) : (Mt = a, le === 0 && pe(kt)), Mt !== a && (Mt = Dt()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === it ? (Mt = it, vt += 2) : (Mt = a, le === 0 && pe(qt)), Mt !== a && (Mt = he()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === $ ? (Mt = $, vt += 2) : (Mt = a, le === 0 && pe(Vt)), Mt !== a && (Mt = W()), (Tt = Mt) === a && (Tt = vt, r.substr(vt, 2) === N ? (Mt = N, vt += 2) : (Mt = a, le === 0 && pe(R)), Mt !== a && (re = un()) !== a && (fe = un()) !== a && (de = un()) !== a && (me = un()) !== a ? Tt = Mt = z(re, fe, de, me) : (vt = Tt, Tt = T)))))))))), Tt;
            }
            function Fe() {
              var Tt;
              return te.test(r.charAt(vt)) ? (Tt = r.charAt(vt), vt++) : (Tt = a, le === 0 && pe(Oe)), Tt;
            }
            function Ee() {
              var Tt, Mt, re, fe;
              return Tt = vt, (Mt = jn()) !== a && (re = _n()) !== a ? Tt = Mt = se(Mt, re) : (vt = Tt, Tt = T), Tt === a && (Tt = dn()) === a && (Tt = vt, r.charCodeAt(vt) === 45 ? (Mt = Ue, vt++) : (Mt = a, le === 0 && pe(rn)), Mt !== a && (re = jn()) !== a && (fe = _n()) !== a ? Tt = Mt = pn(re, fe) : (vt = Tt, Tt = T), Tt === a && (Tt = vt, r.charCodeAt(vt) === 45 ? (Mt = Ue, vt++) : (Mt = a, le === 0 && pe(rn)), Mt !== a && (re = dn()) !== a ? Tt = Mt = Tn(re) : (vt = Tt, Tt = T))), Tt;
            }
            function on() {
              var Tt, Mt, re;
              return Tt = vt, r.charCodeAt(vt) === 46 ? (Mt = An, vt++) : (Mt = a, le === 0 && pe(vn)), Mt !== a && (re = _n()) !== a ? Tt = Mt = ln(re) : (vt = Tt, Tt = T), Tt;
            }
            function Ne() {
              var Tt, Mt, re;
              return Tt = vt, (Mt = function() {
                var fe, de, me;
                return fe = vt, ie.test(r.charAt(vt)) ? (de = r.charAt(vt), vt++) : (de = a, le === 0 && pe(Ye)), de !== a ? (We.test(r.charAt(vt)) ? (me = r.charAt(vt), vt++) : (me = a, le === 0 && pe(Le)), me === a && (me = A), me !== a ? (de = Te(de, me), fe = de) : (vt = fe, fe = T)) : (vt = fe, fe = T), fe;
              }()) !== a && (re = _n()) !== a ? Tt = Mt = Yt(Mt, re) : (vt = Tt, Tt = T), Tt;
            }
            function _n() {
              var Tt, Mt;
              if (Tt = [], (Mt = dn()) !== a)
                for (; Mt !== a; )
                  Tt.push(Mt), Mt = dn();
              else
                Tt = T;
              return Tt !== a && (Tt = oe(Tt)), Tt;
            }
            function dn() {
              var Tt;
              return Re.test(r.charAt(vt)) ? (Tt = r.charAt(vt), vt++) : (Tt = a, le === 0 && pe(en)), Tt;
            }
            function jn() {
              var Tt;
              return cn.test(r.charAt(vt)) ? (Tt = r.charAt(vt), vt++) : (Tt = a, le === 0 && pe(J)), Tt;
            }
            function un() {
              var Tt;
              return st.test(r.charAt(vt)) ? (Tt = r.charAt(vt), vt++) : (Tt = a, le === 0 && pe(gt)), Tt;
            }
            function Ve() {
              var Tt, Mt;
              for (le++, Tt = [], Mt = Cn(); Mt !== a; )
                Tt.push(Mt), Mt = Cn();
              return le--, Tt === a && (Mt = a, le === 0 && pe(zt)), Tt;
            }
            function Cn() {
              var Tt;
              return Xt.test(r.charAt(vt)) ? (Tt = r.charAt(vt), vt++) : (Tt = a, le === 0 && pe(Jt)), Tt;
            }
            var mn = new Object();
            function an(Tt) {
              return Tt === mn ? null : Tt;
            }
            if ((o = y()) !== a && vt === r.length)
              return o;
            throw o !== a && vt < r.length && pe({ type: "end", description: "end of input" }), bn(null, Ae, Ke);
          } };
        }();
        n.stringify = function(s, r) {
          try {
            r = r || {};
            var o = {};
            o.showfunc = r.showfunc || r.f || !1, o.custom = r.custom || r.c || !1, o.depth = r.depth || r.d || 3, o.maxitems = r.maxitems || r.mi || 11, o.maxchars = r.maxchars || r.mc || 111, o.exclude = r.exclude || r.x || ["$"];
            var u = r.omit || r.o || [];
            o.omit = {};
            for (var a = 0; a < u.length; a++)
              o.omit[u[a]] = !0;
            var f = function y(T, h, _) {
              if (_++, T == null)
                return "null";
              var g = Object.prototype.toString.call(T).charAt(8);
              if (g === "F" && !h.showfunc)
                return null;
              if (h.custom) {
                if (T.hasOwnProperty("toString"))
                  return T.toString();
                if (T.hasOwnProperty("inspect"))
                  return T.inspect();
              }
              var S, d, b, k = 0;
              if (g === "N")
                return isNaN(T) ? "null" : T.toString();
              if (g === "O") {
                if (S = [], _ <= h.depth)
                  for (k in d = 0, T) {
                    if (d >= h.maxitems)
                      break;
                    var O = !0;
                    for (b = 0; b < h.exclude.length && O; b++)
                      O = !~k.indexOf(h.exclude[b]);
                    if (O = O && !h.omit[k], (l = y(T[k], h, _)) != null && O) {
                      var A = k.match(/^[a-zA-Z0-9_$]+$/) ? k : JSON.stringify(k);
                      S.push(A + ":" + l), d++;
                    }
                  }
                return "{" + S.join(",") + "}";
              }
              if (g === "A") {
                if (S = [], _ <= h.depth)
                  for (; k < T.length && k < h.maxitems; k++) {
                    var l;
                    (l = y(T[k], h, _)) != null && S.push(l);
                  }
                return "[" + S.join(",") + "]";
              }
              var E = T.toString();
              return (~` "'\r
	,}]`.indexOf(E[0]) || !~E.match(/,}]/) || ~` \r
	`.indexOf(E[E.length - 1])) && (E = "'" + E.replace(/'/g, "\\'") + "'"), E;
            }(s, o, 0);
            return f = f == null ? "" : f.substring(0, o.maxchars);
          } catch (y) {
            return "ERROR: jsonic.stringify: " + y + " input was: " + JSON.stringify(s);
          }
        }, typeof c != "undefined" ? (typeof C != "undefined" && C.exports && (c = C.exports = n), c.jsonic = n) : p.jsonic = n;
      }).call(this);
    }, {}], 120: [function(x, C, c) {
      var p = /<%=([\s\S]+?)%>/g;
      C.exports = p;
    }, {}], 121: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = 200, n = "__lodash_hash_undefined__", i = 800, s = 16, r = 9007199254740991, o = "[object Arguments]", u = "[object Array]", a = "[object AsyncFunction]", f = "[object Boolean]", y = "[object Date]", T = "[object Error]", h = "[object Function]", _ = "[object GeneratorFunction]", g = "[object Map]", S = "[object Number]", d = "[object Null]", b = "[object Object]", k = "[object Proxy]", O = "[object RegExp]", A = "[object Set]", l = "[object String]", E = "[object Undefined]", M = "[object WeakMap]", B = "[object ArrayBuffer]", X = "[object DataView]", K = "[object Float32Array]", D = "[object Float64Array]", j = "[object Int8Array]", Z = "[object Int16Array]", tt = "[object Int32Array]", nt = "[object Uint8Array]", ct = "[object Uint8ClampedArray]", ut = "[object Uint16Array]", V = "[object Uint32Array]", ot = /[\\^$.*+?()[\]{}|]/g, xt = /^\[object .+?Constructor\]$/, Ut = /^(?:0|[1-9]\d*)$/, pt = {};
          pt[K] = pt[D] = pt[j] = pt[Z] = pt[tt] = pt[nt] = pt[ct] = pt[ut] = pt[V] = !0, pt[o] = pt[u] = pt[B] = pt[f] = pt[X] = pt[y] = pt[T] = pt[h] = pt[g] = pt[S] = pt[b] = pt[O] = pt[A] = pt[l] = pt[M] = !1;
          var at = typeof p == "object" && p && p.Object === Object && p, bt = typeof self == "object" && self && self.Object === Object && self, Q = at || bt || Function("return this")(), At = typeof c == "object" && c && !c.nodeType && c, Pt = At && typeof C == "object" && C && !C.nodeType && C, q = Pt && Pt.exports === At, G = q && at.process, lt = function() {
            try {
              var wt = Pt && Pt.require && Pt.require("util").types;
              return wt || G && G.binding && G.binding("util");
            } catch (Bt) {
            }
          }(), It = lt && lt.isTypedArray;
          function Ft(wt, Bt, Ht) {
            switch (Ht.length) {
              case 0:
                return wt.call(Bt);
              case 1:
                return wt.call(Bt, Ht[0]);
              case 2:
                return wt.call(Bt, Ht[0], Ht[1]);
              case 3:
                return wt.call(Bt, Ht[0], Ht[1], Ht[2]);
            }
            return wt.apply(Bt, Ht);
          }
          function H(wt, Bt) {
            for (var Ht = -1, Se = Array(wt); ++Ht < wt; )
              Se[Ht] = Bt(Ht);
            return Se;
          }
          function F(wt) {
            return function(Bt) {
              return wt(Bt);
            };
          }
          function P(wt, Bt) {
            return wt == null ? void 0 : wt[Bt];
          }
          function U(wt, Bt) {
            return function(Ht) {
              return wt(Bt(Ht));
            };
          }
          var rt = Array.prototype, ft = Function.prototype, Ot = Object.prototype, Wt = Q["__core-js_shared__"], ce = ft.toString, ye = Ot.hasOwnProperty, ge = function() {
            var wt = /[^.]+$/.exec(Wt && Wt.keys && Wt.keys.IE_PROTO || "");
            return wt ? "Symbol(src)_1." + wt : "";
          }(), Ce = Ot.toString, _e = ce.call(Object), je = RegExp("^" + ce.call(ye).replace(ot, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Ie = q ? Q.Buffer : void 0, $e = Q.Symbol, He = Q.Uint8Array, De = Ie ? Ie.allocUnsafe : void 0, _t = U(Object.getPrototypeOf, Object), jt = Object.create, mt = Ot.propertyIsEnumerable, St = rt.splice, kt = $e ? $e.toStringTag : void 0, Dt = function() {
            try {
              var wt = le(Object, "defineProperty");
              return wt({}, "", {}), wt;
            } catch (Bt) {
            }
          }(), it = Ie ? Ie.isBuffer : void 0, qt = Math.max, he = Date.now, $ = le(Q, "Map"), Vt = le(Object, "create"), W = function() {
            function wt() {
            }
            return function(Bt) {
              if (!mn(Bt))
                return {};
              if (jt)
                return jt(Bt);
              wt.prototype = Bt;
              var Ht = new wt();
              return wt.prototype = void 0, Ht;
            };
          }();
          function N(wt) {
            var Bt = -1, Ht = wt == null ? 0 : wt.length;
            for (this.clear(); ++Bt < Ht; ) {
              var Se = wt[Bt];
              this.set(Se[0], Se[1]);
            }
          }
          function R() {
            this.__data__ = Vt ? Vt(null) : {}, this.size = 0;
          }
          function z(wt) {
            var Bt = this.has(wt) && delete this.__data__[wt];
            return this.size -= Bt ? 1 : 0, Bt;
          }
          function et(wt) {
            var Bt = this.__data__;
            if (Vt) {
              var Ht = Bt[wt];
              return Ht === n ? void 0 : Ht;
            }
            return ye.call(Bt, wt) ? Bt[wt] : void 0;
          }
          function ht(wt) {
            var Bt = this.__data__;
            return Vt ? Bt[wt] !== void 0 : ye.call(Bt, wt);
          }
          function yt(wt, Bt) {
            var Ht = this.__data__;
            return this.size += this.has(wt) ? 0 : 1, Ht[wt] = Vt && Bt === void 0 ? n : Bt, this;
          }
          function Ct(wt) {
            var Bt = -1, Ht = wt == null ? 0 : wt.length;
            for (this.clear(); ++Bt < Ht; ) {
              var Se = wt[Bt];
              this.set(Se[0], Se[1]);
            }
          }
          function Et() {
            this.__data__ = [], this.size = 0;
          }
          function Zt(wt) {
            var Bt = this.__data__, Ht = Yt(Bt, wt);
            return !(Ht < 0) && (Ht == Bt.length - 1 ? Bt.pop() : St.call(Bt, Ht, 1), --this.size, !0);
          }
          function Qt(wt) {
            var Bt = this.__data__, Ht = Yt(Bt, wt);
            return Ht < 0 ? void 0 : Bt[Ht][1];
          }
          function Rt(wt) {
            return Yt(this.__data__, wt) > -1;
          }
          function Lt(wt, Bt) {
            var Ht = this.__data__, Se = Yt(Ht, wt);
            return Se < 0 ? (++this.size, Ht.push([wt, Bt])) : Ht[Se][1] = Bt, this;
          }
          function te(wt) {
            var Bt = -1, Ht = wt == null ? 0 : wt.length;
            for (this.clear(); ++Bt < Ht; ) {
              var Se = wt[Bt];
              this.set(Se[0], Se[1]);
            }
          }
          function Oe() {
            this.size = 0, this.__data__ = { hash: new N(), map: new ($ || Ct)(), string: new N() };
          }
          function ke(wt) {
            var Bt = Ae(this, wt).delete(wt);
            return this.size -= Bt ? 1 : 0, Bt;
          }
          function Gt(wt) {
            return Ae(this, wt).get(wt);
          }
          function be(wt) {
            return Ae(this, wt).has(wt);
          }
          function ve(wt, Bt) {
            var Ht = Ae(this, wt), Se = Ht.size;
            return Ht.set(wt, Bt), this.size += Ht.size == Se ? 0 : 1, this;
          }
          function we(wt) {
            var Bt = this.__data__ = new Ct(wt);
            this.size = Bt.size;
          }
          function se() {
            this.__data__ = new Ct(), this.size = 0;
          }
          function Ue(wt) {
            var Bt = this.__data__, Ht = Bt.delete(wt);
            return this.size = Bt.size, Ht;
          }
          function rn(wt) {
            return this.__data__.get(wt);
          }
          function pn(wt) {
            return this.__data__.has(wt);
          }
          function Tn(wt, Bt) {
            var Ht = this.__data__;
            if (Ht instanceof Ct) {
              var Se = Ht.__data__;
              if (!$ || Se.length < v - 1)
                return Se.push([wt, Bt]), this.size = ++Ht.size, this;
              Ht = this.__data__ = new te(Se);
            }
            return Ht.set(wt, Bt), this.size = Ht.size, this;
          }
          function An(wt, Bt) {
            var Ht = _n(wt), Se = !Ht && Ne(wt), Je = !Ht && !Se && un(wt), nn = !Ht && !Se && !Je && Mt(wt), fn = Ht || Se || Je || nn, Qe = fn ? H(wt.length, String) : [], hn = Qe.length;
            for (var En in wt)
              !Bt && !ye.call(wt, En) || fn && (En == "length" || Je && (En == "offset" || En == "parent") || nn && (En == "buffer" || En == "byteLength" || En == "byteOffset") || bn(En, hn)) || Qe.push(En);
            return Qe;
          }
          function vn(wt, Bt, Ht) {
            (Ht === void 0 || on(wt[Bt], Ht)) && (Ht !== void 0 || Bt in wt) || oe(wt, Bt, Ht);
          }
          function ln(wt, Bt, Ht) {
            var Se = wt[Bt];
            ye.call(wt, Bt) && on(Se, Ht) && (Ht !== void 0 || Bt in wt) || oe(wt, Bt, Ht);
          }
          function Yt(wt, Bt) {
            for (var Ht = wt.length; Ht--; )
              if (on(wt[Ht][0], Bt))
                return Ht;
            return -1;
          }
          function oe(wt, Bt, Ht) {
            Bt == "__proto__" && Dt ? Dt(wt, Bt, { configurable: !0, enumerable: !0, value: Ht, writable: !0 }) : wt[Bt] = Ht;
          }
          N.prototype.clear = R, N.prototype.delete = z, N.prototype.get = et, N.prototype.has = ht, N.prototype.set = yt, Ct.prototype.clear = Et, Ct.prototype.delete = Zt, Ct.prototype.get = Qt, Ct.prototype.has = Rt, Ct.prototype.set = Lt, te.prototype.clear = Oe, te.prototype.delete = ke, te.prototype.get = Gt, te.prototype.has = be, te.prototype.set = ve, we.prototype.clear = se, we.prototype.delete = Ue, we.prototype.get = rn, we.prototype.has = pn, we.prototype.set = Tn;
          var ie = qe();
          function Ye(wt) {
            return wt == null ? wt === void 0 ? E : d : kt && kt in Object(wt) ? gn(wt) : $t(wt);
          }
          function We(wt) {
            return an(wt) && Ye(wt) == o;
          }
          function Le(wt) {
            return !(!mn(wt) || Pn(wt)) && (Ve(wt) ? je : xt).test(Ee(wt));
          }
          function Te(wt) {
            return an(wt) && Cn(wt.length) && !!pt[Ye(wt)];
          }
          function Re(wt) {
            if (!mn(wt))
              return Ln(wt);
            var Bt = On(wt), Ht = [];
            for (var Se in wt)
              (Se != "constructor" || !Bt && ye.call(wt, Se)) && Ht.push(Se);
            return Ht;
          }
          function en(wt, Bt, Ht, Se, Je) {
            wt !== Bt && ie(Bt, function(nn, fn) {
              if (Je || (Je = new we()), mn(nn))
                cn(wt, Bt, fn, Ht, en, Se, Je);
              else {
                var Qe = Se ? Se(ae(wt, fn), nn, fn + "", wt, Bt, Je) : void 0;
                Qe === void 0 && (Qe = nn), vn(wt, fn, Qe);
              }
            }, de);
          }
          function cn(wt, Bt, Ht, Se, Je, nn, fn) {
            var Qe = ae(wt, Ht), hn = ae(Bt, Ht), En = fn.get(hn);
            if (En)
              vn(wt, Ht, En);
            else {
              var Sn = nn ? nn(Qe, hn, Ht + "", wt, Bt, fn) : void 0, xn = Sn === void 0;
              if (xn) {
                var tr = _n(hn), Vn = !tr && un(hn), Rn = !tr && !Vn && Mt(hn);
                Sn = hn, tr || Vn || Rn ? _n(Qe) ? Sn = Qe : jn(Qe) ? Sn = Jt(Qe) : Vn ? (xn = !1, Sn = gt(hn, !0)) : Rn ? (xn = !1, Sn = Xt(hn, !0)) : Sn = [] : Tt(hn) || Ne(hn) ? (Sn = Qe, Ne(Qe) ? Sn = re(Qe) : mn(Qe) && !Ve(Qe) || (Sn = pe(hn))) : xn = !1;
              }
              xn && (fn.set(hn, Sn), Je(Sn, hn, Se, nn, fn), fn.delete(hn)), vn(wt, Ht, Sn);
            }
          }
          function J(wt, Bt) {
            return Be(ne(wt, Bt, xe), wt + "");
          }
          var st = Dt ? function(wt, Bt) {
            return Dt(wt, "toString", { configurable: !0, enumerable: !1, value: Ze(Bt), writable: !0 });
          } : xe;
          function gt(wt, Bt) {
            if (Bt)
              return wt.slice();
            var Ht = wt.length, Se = De ? De(Ht) : new wt.constructor(Ht);
            return wt.copy(Se), Se;
          }
          function zt(wt) {
            var Bt = new wt.constructor(wt.byteLength);
            return new He(Bt).set(new He(wt)), Bt;
          }
          function Xt(wt, Bt) {
            var Ht = Bt ? zt(wt.buffer) : wt.buffer;
            return new wt.constructor(Ht, wt.byteOffset, wt.length);
          }
          function Jt(wt, Bt) {
            var Ht = -1, Se = wt.length;
            for (Bt || (Bt = Array(Se)); ++Ht < Se; )
              Bt[Ht] = wt[Ht];
            return Bt;
          }
          function vt(wt, Bt, Ht, Se) {
            var Je = !Ht;
            Ht || (Ht = {});
            for (var nn = -1, fn = Bt.length; ++nn < fn; ) {
              var Qe = Bt[nn], hn = Se ? Se(Ht[Qe], wt[Qe], Qe, Ht, wt) : void 0;
              hn === void 0 && (hn = wt[Qe]), Je ? oe(Ht, Qe, hn) : ln(Ht, Qe, hn);
            }
            return Ht;
          }
          function Me(wt) {
            return J(function(Bt, Ht) {
              var Se = -1, Je = Ht.length, nn = Je > 1 ? Ht[Je - 1] : void 0, fn = Je > 2 ? Ht[2] : void 0;
              for (nn = wt.length > 3 && typeof nn == "function" ? (Je--, nn) : void 0, fn && wn(Ht[0], Ht[1], fn) && (nn = Je < 3 ? void 0 : nn, Je = 1), Bt = Object(Bt); ++Se < Je; ) {
                var Qe = Ht[Se];
                Qe && wt(Bt, Qe, Se, nn);
              }
              return Bt;
            });
          }
          function qe(wt) {
            return function(Bt, Ht, Se) {
              for (var Je = -1, nn = Object(Bt), fn = Se(Bt), Qe = fn.length; Qe--; ) {
                var hn = fn[wt ? Qe : ++Je];
                if (Ht(nn[hn], hn, nn) === !1)
                  break;
              }
              return Bt;
            };
          }
          function Ke(wt, Bt, Ht, Se, Je, nn) {
            return mn(wt) && mn(Bt) && (nn.set(Bt, wt), en(wt, Bt, void 0, Ke, nn), nn.delete(Bt)), wt;
          }
          function Ae(wt, Bt) {
            var Ht = wt.__data__;
            return Mn(Bt) ? Ht[typeof Bt == "string" ? "string" : "hash"] : Ht.map;
          }
          function le(wt, Bt) {
            var Ht = P(wt, Bt);
            return Le(Ht) ? Ht : void 0;
          }
          function gn(wt) {
            var Bt = ye.call(wt, kt), Ht = wt[kt];
            try {
              wt[kt] = void 0;
              var Se = !0;
            } catch (nn) {
            }
            var Je = Ce.call(wt);
            return Se && (Bt ? wt[kt] = Ht : delete wt[kt]), Je;
          }
          function pe(wt) {
            return typeof wt.constructor != "function" || On(wt) ? {} : W(_t(wt));
          }
          function bn(wt, Bt) {
            var Ht = typeof wt;
            return !!(Bt = Bt == null ? r : Bt) && (Ht == "number" || Ht != "symbol" && Ut.test(wt)) && wt > -1 && wt % 1 == 0 && wt < Bt;
          }
          function wn(wt, Bt, Ht) {
            if (!mn(Ht))
              return !1;
            var Se = typeof Bt;
            return !!(Se == "number" ? dn(Ht) && bn(Bt, Ht.length) : Se == "string" && Bt in Ht) && on(Ht[Bt], wt);
          }
          function Mn(wt) {
            var Bt = typeof wt;
            return Bt == "string" || Bt == "number" || Bt == "symbol" || Bt == "boolean" ? wt !== "__proto__" : wt === null;
          }
          function Pn(wt) {
            return !!ge && ge in wt;
          }
          function On(wt) {
            var Bt = wt && wt.constructor;
            return wt === (typeof Bt == "function" && Bt.prototype || Ot);
          }
          function Ln(wt) {
            var Bt = [];
            if (wt != null)
              for (var Ht in Object(wt))
                Bt.push(Ht);
            return Bt;
          }
          function $t(wt) {
            return Ce.call(wt);
          }
          function ne(wt, Bt, Ht) {
            return Bt = qt(Bt === void 0 ? wt.length - 1 : Bt, 0), function() {
              for (var Se = arguments, Je = -1, nn = qt(Se.length - Bt, 0), fn = Array(nn); ++Je < nn; )
                fn[Je] = Se[Bt + Je];
              Je = -1;
              for (var Qe = Array(Bt + 1); ++Je < Bt; )
                Qe[Je] = Se[Je];
              return Qe[Bt] = Ht(fn), Ft(wt, this, Qe);
            };
          }
          function ae(wt, Bt) {
            if ((Bt !== "constructor" || typeof wt[Bt] != "function") && Bt != "__proto__")
              return wt[Bt];
          }
          var Be = Fe(st);
          function Fe(wt) {
            var Bt = 0, Ht = 0;
            return function() {
              var Se = he(), Je = s - (Se - Ht);
              if (Ht = Se, Je > 0) {
                if (++Bt >= i)
                  return arguments[0];
              } else
                Bt = 0;
              return wt.apply(void 0, arguments);
            };
          }
          function Ee(wt) {
            if (wt != null) {
              try {
                return ce.call(wt);
              } catch (Bt) {
              }
              try {
                return wt + "";
              } catch (Bt) {
              }
            }
            return "";
          }
          function on(wt, Bt) {
            return wt === Bt || wt != wt && Bt != Bt;
          }
          var Ne = We(function() {
            return arguments;
          }()) ? We : function(wt) {
            return an(wt) && ye.call(wt, "callee") && !mt.call(wt, "callee");
          }, _n = Array.isArray;
          function dn(wt) {
            return wt != null && Cn(wt.length) && !Ve(wt);
          }
          function jn(wt) {
            return an(wt) && dn(wt);
          }
          var un = it || ze;
          function Ve(wt) {
            if (!mn(wt))
              return !1;
            var Bt = Ye(wt);
            return Bt == h || Bt == _ || Bt == a || Bt == k;
          }
          function Cn(wt) {
            return typeof wt == "number" && wt > -1 && wt % 1 == 0 && wt <= r;
          }
          function mn(wt) {
            var Bt = typeof wt;
            return wt != null && (Bt == "object" || Bt == "function");
          }
          function an(wt) {
            return wt != null && typeof wt == "object";
          }
          function Tt(wt) {
            if (!an(wt) || Ye(wt) != b)
              return !1;
            var Bt = _t(wt);
            if (Bt === null)
              return !0;
            var Ht = ye.call(Bt, "constructor") && Bt.constructor;
            return typeof Ht == "function" && Ht instanceof Ht && ce.call(Ht) == _e;
          }
          var Mt = It ? F(It) : Te;
          function re(wt) {
            return vt(wt, de(wt));
          }
          var fe = J(function(wt) {
            return wt.push(void 0, Ke), Ft(me, void 0, wt);
          });
          function de(wt) {
            return dn(wt) ? An(wt, !0) : Re(wt);
          }
          var me = Me(function(wt, Bt, Ht, Se) {
            en(wt, Bt, Ht, Se);
          });
          function Ze(wt) {
            return function() {
              return wt;
            };
          }
          function xe(wt) {
            return wt;
          }
          function ze() {
            return !1;
          }
          C.exports = fe;
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 122: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = 9007199254740991, n = "[object Arguments]", i = "[object Function]", s = "[object GeneratorFunction]", r = typeof p == "object" && p && p.Object === Object && p, o = typeof self == "object" && self && self.Object === Object && self, u = r || o || Function("return this")();
          function a(K, D) {
            for (var j = -1, Z = D.length, tt = K.length; ++j < Z; )
              K[tt + j] = D[j];
            return K;
          }
          var f = Object.prototype, y = f.hasOwnProperty, T = f.toString, h = u.Symbol, _ = f.propertyIsEnumerable, g = h ? h.isConcatSpreadable : void 0;
          function S(K, D, j, Z, tt) {
            var nt = -1, ct = K.length;
            for (j || (j = d), tt || (tt = []); ++nt < ct; ) {
              var ut = K[nt];
              D > 0 && j(ut) ? D > 1 ? S(ut, D - 1, j, Z, tt) : a(tt, ut) : Z || (tt[tt.length] = ut);
            }
            return tt;
          }
          function d(K) {
            return O(K) || k(K) || !!(g && K && K[g]);
          }
          function b(K) {
            return K && K.length ? S(K, 1) : [];
          }
          function k(K) {
            return l(K) && y.call(K, "callee") && (!_.call(K, "callee") || T.call(K) == n);
          }
          var O = Array.isArray;
          function A(K) {
            return K != null && M(K.length) && !E(K);
          }
          function l(K) {
            return X(K) && A(K);
          }
          function E(K) {
            var D = B(K) ? T.call(K) : "";
            return D == i || D == s;
          }
          function M(K) {
            return typeof K == "number" && K > -1 && K % 1 == 0 && K <= v;
          }
          function B(K) {
            var D = typeof K;
            return !!K && (D == "object" || D == "function");
          }
          function X(K) {
            return !!K && typeof K == "object";
          }
          C.exports = b;
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 123: [function(x, C, c) {
      var p = 9007199254740991, v = "[object Arguments]", n = "[object Function]", i = "[object GeneratorFunction]", s = Object.prototype, r = s.hasOwnProperty, o = s.toString, u = s.propertyIsEnumerable;
      function a(S) {
        return y(S) && r.call(S, "callee") && (!u.call(S, "callee") || o.call(S) == v);
      }
      function f(S) {
        return S != null && h(S.length) && !T(S);
      }
      function y(S) {
        return g(S) && f(S);
      }
      function T(S) {
        var d = _(S) ? o.call(S) : "";
        return d == n || d == i;
      }
      function h(S) {
        return typeof S == "number" && S > -1 && S % 1 == 0 && S <= p;
      }
      function _(S) {
        var d = typeof S;
        return !!S && (d == "object" || d == "function");
      }
      function g(S) {
        return !!S && typeof S == "object";
      }
      C.exports = a;
    }, {}], 124: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = "[object Date]", n = typeof p == "object" && p && p.Object === Object && p, i = typeof c == "object" && c && !c.nodeType && c, s = i && typeof C == "object" && C && !C.nodeType && C, r = s && s.exports === i, o = r && n.process, u = function() {
            try {
              return o && o.binding("util");
            } catch (S) {
            }
          }(), a = u && u.isDate;
          function f(S) {
            return function(d) {
              return S(d);
            };
          }
          var y = Object.prototype, T = y.toString;
          function h(S) {
            return g(S) && T.call(S) == v;
          }
          var _ = a ? f(a) : h;
          function g(S) {
            return !!S && typeof S == "object";
          }
          C.exports = _;
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 125: [function(x, C, c) {
      var p = "[object Number]", v = Object.prototype, n = v.toString;
      function i(o) {
        return !!o && typeof o == "object";
      }
      function s(o) {
        return r(o) && o != +o;
      }
      function r(o) {
        return typeof o == "number" || i(o) && n.call(o) == p;
      }
      C.exports = s;
    }, {}], 126: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = "[object RegExp]", n = typeof p == "object" && p && p.Object === Object && p, i = typeof c == "object" && c && !c.nodeType && c, s = i && typeof C == "object" && C && !C.nodeType && C, r = s && s.exports === i, o = r && n.process, u = function() {
            try {
              return o && o.binding("util");
            } catch (S) {
            }
          }(), a = u && u.isRegExp;
          function f(S) {
            return function(d) {
              return S(d);
            };
          }
          var y = Object.prototype, T = y.toString;
          function h(S) {
            return _(S) && T.call(S) == v;
          }
          function _(S) {
            var d = typeof S;
            return !!S && (d == "object" || d == "function");
          }
          var g = a ? f(a) : h;
          C.exports = g;
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 127: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = x("lodash._reinterpolate"), n = x("lodash.templatesettings"), i = 800, s = 16, r = 1 / 0, o = 9007199254740991, u = "[object Arguments]", a = "[object Array]", f = "[object AsyncFunction]", y = "[object Boolean]", T = "[object Date]", h = "[object DOMException]", _ = "[object Error]", g = "[object Function]", S = "[object GeneratorFunction]", d = "[object Map]", b = "[object Number]", k = "[object Null]", O = "[object Object]", A = "[object Proxy]", l = "[object RegExp]", E = "[object Set]", M = "[object String]", B = "[object Symbol]", X = "[object Undefined]", K = "[object WeakMap]", D = "[object ArrayBuffer]", j = "[object DataView]", Z = "[object Float32Array]", tt = "[object Float64Array]", nt = "[object Int8Array]", ct = "[object Int16Array]", ut = "[object Int32Array]", V = "[object Uint8Array]", ot = "[object Uint8ClampedArray]", xt = "[object Uint16Array]", Ut = "[object Uint32Array]", pt = /\b__p \+= '';/g, at = /\b(__p \+=) '' \+/g, bt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Q = /[\\^$.*+?()[\]{}|]/g, At = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Pt = /^\[object .+?Constructor\]$/, q = /^(?:0|[1-9]\d*)$/, G = /($^)/, lt = /['\n\r\u2028\u2029\\]/g, It = {};
          It[Z] = It[tt] = It[nt] = It[ct] = It[ut] = It[V] = It[ot] = It[xt] = It[Ut] = !0, It[u] = It[a] = It[D] = It[y] = It[j] = It[T] = It[_] = It[g] = It[d] = It[b] = It[O] = It[l] = It[E] = It[M] = It[K] = !1;
          var Ft = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, H = typeof p == "object" && p && p.Object === Object && p, F = typeof self == "object" && self && self.Object === Object && self, P = H || F || Function("return this")(), U = typeof c == "object" && c && !c.nodeType && c, rt = U && typeof C == "object" && C && !C.nodeType && C, ft = rt && rt.exports === U, Ot = ft && H.process, Wt = function() {
            try {
              var $t = rt && rt.require && rt.require("util").types;
              return $t || Ot && Ot.binding && Ot.binding("util");
            } catch (ne) {
            }
          }(), ce = Wt && Wt.isTypedArray;
          function ye($t, ne, ae) {
            switch (ae.length) {
              case 0:
                return $t.call(ne);
              case 1:
                return $t.call(ne, ae[0]);
              case 2:
                return $t.call(ne, ae[0], ae[1]);
              case 3:
                return $t.call(ne, ae[0], ae[1], ae[2]);
            }
            return $t.apply(ne, ae);
          }
          function ge($t, ne) {
            for (var ae = -1, Be = $t == null ? 0 : $t.length, Fe = Array(Be); ++ae < Be; )
              Fe[ae] = ne($t[ae], ae, $t);
            return Fe;
          }
          function Ce($t, ne) {
            for (var ae = -1, Be = Array($t); ++ae < $t; )
              Be[ae] = ne(ae);
            return Be;
          }
          function _e($t) {
            return function(ne) {
              return $t(ne);
            };
          }
          function je($t, ne) {
            return ge(ne, function(ae) {
              return $t[ae];
            });
          }
          function Ie($t) {
            return "\\" + Ft[$t];
          }
          function $e($t, ne) {
            return $t == null ? void 0 : $t[ne];
          }
          function He($t, ne) {
            return function(ae) {
              return $t(ne(ae));
            };
          }
          var De = Function.prototype, _t = Object.prototype, jt = P["__core-js_shared__"], mt = De.toString, St = _t.hasOwnProperty, kt = function() {
            var $t = /[^.]+$/.exec(jt && jt.keys && jt.keys.IE_PROTO || "");
            return $t ? "Symbol(src)_1." + $t : "";
          }(), Dt = _t.toString, it = mt.call(Object), qt = RegExp("^" + mt.call(St).replace(Q, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), he = ft ? P.Buffer : void 0, $ = P.Symbol, Vt = He(Object.getPrototypeOf, Object), W = _t.propertyIsEnumerable, N = $ ? $.toStringTag : void 0, R = function() {
            try {
              var $t = Tn(Object, "defineProperty");
              return $t({}, "", {}), $t;
            } catch (ne) {
            }
          }(), z = he ? he.isBuffer : void 0, et = He(Object.keys, Object), ht = Math.max, yt = Date.now, Ct = $ ? $.prototype : void 0, Et = Ct ? Ct.toString : void 0;
          function Zt($t, ne) {
            var ae = J($t), Be = !ae && cn($t), Fe = !ae && !Be && gt($t), Ee = !ae && !Be && !Fe && Ae($t), on = ae || Be || Fe || Ee, Ne = on ? Ce($t.length, String) : [], _n = Ne.length;
            for (var dn in $t)
              !ne && !St.call($t, dn) || on && (dn == "length" || Fe && (dn == "offset" || dn == "parent") || Ee && (dn == "buffer" || dn == "byteLength" || dn == "byteOffset") || vn(dn, _n)) || Ne.push(dn);
            return Ne;
          }
          function Qt($t, ne, ae) {
            var Be = $t[ne];
            St.call($t, ne) && en(Be, ae) && (ae !== void 0 || ne in $t) || Rt($t, ne, ae);
          }
          function Rt($t, ne, ae) {
            ne == "__proto__" && R ? R($t, ne, { configurable: !0, enumerable: !0, value: ae, writable: !0 }) : $t[ne] = ae;
          }
          function Lt($t) {
            return $t == null ? $t === void 0 ? X : k : N && N in Object($t) ? An($t) : Ye($t);
          }
          function te($t) {
            return Me($t) && Lt($t) == u;
          }
          function Oe($t) {
            return !(!vt($t) || Yt($t)) && (Xt($t) ? qt : Pt).test(Re($t));
          }
          function ke($t) {
            return Me($t) && Jt($t.length) && !!It[Lt($t)];
          }
          function Gt($t) {
            if (!oe($t))
              return et($t);
            var ne = [];
            for (var ae in Object($t))
              St.call($t, ae) && ae != "constructor" && ne.push(ae);
            return ne;
          }
          function be($t) {
            if (!vt($t))
              return ie($t);
            var ne = oe($t), ae = [];
            for (var Be in $t)
              (Be != "constructor" || !ne && St.call($t, Be)) && ae.push(Be);
            return ae;
          }
          function ve($t, ne) {
            return Le(We($t, ne, On), $t + "");
          }
          var we = R ? function($t, ne) {
            return R($t, "toString", { configurable: !0, enumerable: !1, value: Pn(ne), writable: !0 });
          } : On;
          function se($t) {
            if (typeof $t == "string")
              return $t;
            if (J($t))
              return ge($t, se) + "";
            if (Ke($t))
              return Et ? Et.call($t) : "";
            var ne = $t + "";
            return ne == "0" && 1 / $t == -r ? "-0" : ne;
          }
          function Ue($t, ne, ae, Be) {
            var Fe = !ae;
            ae || (ae = {});
            for (var Ee = -1, on = ne.length; ++Ee < on; ) {
              var Ne = ne[Ee], _n = Be ? Be(ae[Ne], $t[Ne], Ne, ae, $t) : void 0;
              _n === void 0 && (_n = $t[Ne]), Fe ? Rt(ae, Ne, _n) : Qt(ae, Ne, _n);
            }
            return ae;
          }
          function rn($t) {
            return ve(function(ne, ae) {
              var Be = -1, Fe = ae.length, Ee = Fe > 1 ? ae[Fe - 1] : void 0, on = Fe > 2 ? ae[2] : void 0;
              for (Ee = $t.length > 3 && typeof Ee == "function" ? (Fe--, Ee) : void 0, on && ln(ae[0], ae[1], on) && (Ee = Fe < 3 ? void 0 : Ee, Fe = 1), ne = Object(ne); ++Be < Fe; ) {
                var Ne = ae[Be];
                Ne && $t(ne, Ne, Be, Ee);
              }
              return ne;
            });
          }
          function pn($t, ne, ae, Be) {
            return $t === void 0 || en($t, _t[ae]) && !St.call(Be, ae) ? ne : $t;
          }
          function Tn($t, ne) {
            var ae = $e($t, ne);
            return Oe(ae) ? ae : void 0;
          }
          function An($t) {
            var ne = St.call($t, N), ae = $t[N];
            try {
              $t[N] = void 0;
              var Be = !0;
            } catch (Ee) {
            }
            var Fe = Dt.call($t);
            return Be && (ne ? $t[N] = ae : delete $t[N]), Fe;
          }
          function vn($t, ne) {
            var ae = typeof $t;
            return !!(ne = ne == null ? o : ne) && (ae == "number" || ae != "symbol" && q.test($t)) && $t > -1 && $t % 1 == 0 && $t < ne;
          }
          function ln($t, ne, ae) {
            if (!vt(ae))
              return !1;
            var Be = typeof ne;
            return !!(Be == "number" ? st(ae) && vn(ne, ae.length) : Be == "string" && ne in ae) && en(ae[ne], $t);
          }
          function Yt($t) {
            return !!kt && kt in $t;
          }
          function oe($t) {
            var ne = $t && $t.constructor;
            return $t === (typeof ne == "function" && ne.prototype || _t);
          }
          function ie($t) {
            var ne = [];
            if ($t != null)
              for (var ae in Object($t))
                ne.push(ae);
            return ne;
          }
          function Ye($t) {
            return Dt.call($t);
          }
          function We($t, ne, ae) {
            return ne = ht(ne === void 0 ? $t.length - 1 : ne, 0), function() {
              for (var Be = arguments, Fe = -1, Ee = ht(Be.length - ne, 0), on = Array(Ee); ++Fe < Ee; )
                on[Fe] = Be[ne + Fe];
              Fe = -1;
              for (var Ne = Array(ne + 1); ++Fe < ne; )
                Ne[Fe] = Be[Fe];
              return Ne[ne] = ae(on), ye($t, this, Ne);
            };
          }
          var Le = Te(we);
          function Te($t) {
            var ne = 0, ae = 0;
            return function() {
              var Be = yt(), Fe = s - (Be - ae);
              if (ae = Be, Fe > 0) {
                if (++ne >= i)
                  return arguments[0];
              } else
                ne = 0;
              return $t.apply(void 0, arguments);
            };
          }
          function Re($t) {
            if ($t != null) {
              try {
                return mt.call($t);
              } catch (ne) {
              }
              try {
                return $t + "";
              } catch (ne) {
              }
            }
            return "";
          }
          function en($t, ne) {
            return $t === ne || $t != $t && ne != ne;
          }
          var cn = te(function() {
            return arguments;
          }()) ? te : function($t) {
            return Me($t) && St.call($t, "callee") && !W.call($t, "callee");
          }, J = Array.isArray;
          function st($t) {
            return $t != null && Jt($t.length) && !Xt($t);
          }
          var gt = z || Ln;
          function zt($t) {
            if (!Me($t))
              return !1;
            var ne = Lt($t);
            return ne == _ || ne == h || typeof $t.message == "string" && typeof $t.name == "string" && !qe($t);
          }
          function Xt($t) {
            if (!vt($t))
              return !1;
            var ne = Lt($t);
            return ne == g || ne == S || ne == f || ne == A;
          }
          function Jt($t) {
            return typeof $t == "number" && $t > -1 && $t % 1 == 0 && $t <= o;
          }
          function vt($t) {
            var ne = typeof $t;
            return $t != null && (ne == "object" || ne == "function");
          }
          function Me($t) {
            return $t != null && typeof $t == "object";
          }
          function qe($t) {
            if (!Me($t) || Lt($t) != O)
              return !1;
            var ne = Vt($t);
            if (ne === null)
              return !0;
            var ae = St.call(ne, "constructor") && ne.constructor;
            return typeof ae == "function" && ae instanceof ae && mt.call(ae) == it;
          }
          function Ke($t) {
            return typeof $t == "symbol" || Me($t) && Lt($t) == B;
          }
          var Ae = ce ? _e(ce) : ke;
          function le($t) {
            return $t == null ? "" : se($t);
          }
          var gn = rn(function($t, ne, ae, Be) {
            Ue(ne, bn(ne), $t, Be);
          });
          function pe($t) {
            return st($t) ? Zt($t) : Gt($t);
          }
          function bn($t) {
            return st($t) ? Zt($t, !0) : be($t);
          }
          function wn($t, ne, ae) {
            var Be = n.imports._.templateSettings || n;
            ae && ln($t, ne, ae) && (ne = void 0), $t = le($t), ne = gn({}, ne, Be, pn);
            var Fe, Ee, on = gn({}, ne.imports, Be.imports, pn), Ne = pe(on), _n = je(on, Ne), dn = 0, jn = ne.interpolate || G, un = "__p += '", Ve = RegExp((ne.escape || G).source + "|" + jn.source + "|" + (jn === v ? At : G).source + "|" + (ne.evaluate || G).source + "|$", "g"), Cn = St.call(ne, "sourceURL") ? "//# sourceURL=" + (ne.sourceURL + "").replace(/[\r\n]/g, " ") + `
` : "";
            $t.replace(Ve, function(Tt, Mt, re, fe, de, me) {
              return re || (re = fe), un += $t.slice(dn, me).replace(lt, Ie), Mt && (Fe = !0, un += `' +
__e(` + Mt + `) +
'`), de && (Ee = !0, un += `';
` + de + `;
__p += '`), re && (un += `' +
((__t = (` + re + `)) == null ? '' : __t) +
'`), dn = me + Tt.length, Tt;
            }), un += `';
`;
            var mn = St.call(ne, "variable") && ne.variable;
            mn || (un = `with (obj) {
` + un + `
}
`), un = (Ee ? un.replace(pt, "") : un).replace(at, "$1").replace(bt, "$1;"), un = "function(" + (mn || "obj") + `) {
` + (mn ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (Fe ? ", __e = _.escape" : "") + (Ee ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + un + `return __p
}`;
            var an = Mn(function() {
              return Function(Ne, Cn + "return " + un).apply(void 0, _n);
            });
            if (an.source = un, zt(an))
              throw an;
            return an;
          }
          var Mn = ve(function($t, ne) {
            try {
              return ye($t, void 0, ne);
            } catch (ae) {
              return zt(ae) ? ae : new Error(ae);
            }
          });
          function Pn($t) {
            return function() {
              return $t;
            };
          }
          function On($t) {
            return $t;
          }
          function Ln() {
            return !1;
          }
          C.exports = wn;
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "lodash._reinterpolate": 120, "lodash.templatesettings": 128 }], 128: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = x("lodash._reinterpolate"), n = 1 / 0, i = "[object Null]", s = "[object Symbol]", r = "[object Undefined]", o = /[&<>"']/g, u = RegExp(o.source), a = /<%-([\s\S]+?)%>/g, f = /<%([\s\S]+?)%>/g, y = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, T = typeof p == "object" && p && p.Object === Object && p, h = typeof self == "object" && self && self.Object === Object && self, _ = T || h || Function("return this")();
          function g(V, ot) {
            for (var xt = -1, Ut = V == null ? 0 : V.length, pt = Array(Ut); ++xt < Ut; )
              pt[xt] = ot(V[xt], xt, V);
            return pt;
          }
          function S(V) {
            return function(ot) {
              return V == null ? void 0 : V[ot];
            };
          }
          var d = S(y), b = Object.prototype, k = b.hasOwnProperty, O = b.toString, A = _.Symbol, l = A ? A.toStringTag : void 0, E = A ? A.prototype : void 0, M = E ? E.toString : void 0, B = { escape: a, evaluate: f, interpolate: v, variable: "", imports: { _: { escape: ut } } };
          function X(V) {
            return V == null ? V === void 0 ? r : i : l && l in Object(V) ? D(V) : j(V);
          }
          function K(V) {
            if (typeof V == "string")
              return V;
            if (Z(V))
              return g(V, K) + "";
            if (nt(V))
              return M ? M.call(V) : "";
            var ot = V + "";
            return ot == "0" && 1 / V == -n ? "-0" : ot;
          }
          function D(V) {
            var ot = k.call(V, l), xt = V[l];
            try {
              V[l] = void 0;
              var Ut = !0;
            } catch (at) {
            }
            var pt = O.call(V);
            return Ut && (ot ? V[l] = xt : delete V[l]), pt;
          }
          function j(V) {
            return O.call(V);
          }
          var Z = Array.isArray;
          function tt(V) {
            return V != null && typeof V == "object";
          }
          function nt(V) {
            return typeof V == "symbol" || tt(V) && X(V) == s;
          }
          function ct(V) {
            return V == null ? "" : K(V);
          }
          function ut(V) {
            return (V = ct(V)) && u.test(V) ? V.replace(o, d) : V;
          }
          C.exports = B;
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "lodash._reinterpolate": 120 }], 129: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = 200, n = "__lodash_hash_undefined__", i = 1 / 0, s = "[object Function]", r = "[object GeneratorFunction]", o = /[\\^$.*+?()[\]{}|]/g, u = /^\[object .+?Constructor\]$/, a = typeof p == "object" && p && p.Object === Object && p, f = typeof self == "object" && self && self.Object === Object && self, y = a || f || Function("return this")();
          function T(jt, mt) {
            return !!(jt && jt.length) && g(jt, mt, 0) > -1;
          }
          function h(jt, mt, St) {
            for (var kt = -1, Dt = jt ? jt.length : 0; ++kt < Dt; )
              if (St(mt, jt[kt]))
                return !0;
            return !1;
          }
          function _(jt, mt, St, kt) {
            for (var Dt = jt.length, it = St + (kt ? 1 : -1); kt ? it-- : ++it < Dt; )
              if (mt(jt[it], it, jt))
                return it;
            return -1;
          }
          function g(jt, mt, St) {
            if (mt != mt)
              return _(jt, S, St);
            for (var kt = St - 1, Dt = jt.length; ++kt < Dt; )
              if (jt[kt] === mt)
                return kt;
            return -1;
          }
          function S(jt) {
            return jt != jt;
          }
          function d(jt, mt) {
            return jt.has(mt);
          }
          function b(jt, mt) {
            return jt == null ? void 0 : jt[mt];
          }
          function k(jt) {
            var mt = !1;
            if (jt != null && typeof jt.toString != "function")
              try {
                mt = !!(jt + "");
              } catch (St) {
              }
            return mt;
          }
          function O(jt) {
            var mt = -1, St = Array(jt.size);
            return jt.forEach(function(kt) {
              St[++mt] = kt;
            }), St;
          }
          var A = Array.prototype, l = Function.prototype, E = Object.prototype, M = y["__core-js_shared__"], B = function() {
            var jt = /[^.]+$/.exec(M && M.keys && M.keys.IE_PROTO || "");
            return jt ? "Symbol(src)_1." + jt : "";
          }(), X = l.toString, K = E.hasOwnProperty, D = E.toString, j = RegExp("^" + X.call(K).replace(o, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Z = A.splice, tt = ge(y, "Map"), nt = ge(y, "Set"), ct = ge(Object, "create");
          function ut(jt) {
            var mt = -1, St = jt ? jt.length : 0;
            for (this.clear(); ++mt < St; ) {
              var kt = jt[mt];
              this.set(kt[0], kt[1]);
            }
          }
          function V() {
            this.__data__ = ct ? ct(null) : {};
          }
          function ot(jt) {
            return this.has(jt) && delete this.__data__[jt];
          }
          function xt(jt) {
            var mt = this.__data__;
            if (ct) {
              var St = mt[jt];
              return St === n ? void 0 : St;
            }
            return K.call(mt, jt) ? mt[jt] : void 0;
          }
          function Ut(jt) {
            var mt = this.__data__;
            return ct ? mt[jt] !== void 0 : K.call(mt, jt);
          }
          function pt(jt, mt) {
            return this.__data__[jt] = ct && mt === void 0 ? n : mt, this;
          }
          function at(jt) {
            var mt = -1, St = jt ? jt.length : 0;
            for (this.clear(); ++mt < St; ) {
              var kt = jt[mt];
              this.set(kt[0], kt[1]);
            }
          }
          function bt() {
            this.__data__ = [];
          }
          function Q(jt) {
            var mt = this.__data__, St = ft(mt, jt);
            return !(St < 0) && (St == mt.length - 1 ? mt.pop() : Z.call(mt, St, 1), !0);
          }
          function At(jt) {
            var mt = this.__data__, St = ft(mt, jt);
            return St < 0 ? void 0 : mt[St][1];
          }
          function Pt(jt) {
            return ft(this.__data__, jt) > -1;
          }
          function q(jt, mt) {
            var St = this.__data__, kt = ft(St, jt);
            return kt < 0 ? St.push([jt, mt]) : St[kt][1] = mt, this;
          }
          function G(jt) {
            var mt = -1, St = jt ? jt.length : 0;
            for (this.clear(); ++mt < St; ) {
              var kt = jt[mt];
              this.set(kt[0], kt[1]);
            }
          }
          function lt() {
            this.__data__ = { hash: new ut(), map: new (tt || at)(), string: new ut() };
          }
          function It(jt) {
            return ye(this, jt).delete(jt);
          }
          function Ft(jt) {
            return ye(this, jt).get(jt);
          }
          function H(jt) {
            return ye(this, jt).has(jt);
          }
          function F(jt, mt) {
            return ye(this, jt).set(jt, mt), this;
          }
          function P(jt) {
            var mt = -1, St = jt ? jt.length : 0;
            for (this.__data__ = new G(); ++mt < St; )
              this.add(jt[mt]);
          }
          function U(jt) {
            return this.__data__.set(jt, n), this;
          }
          function rt(jt) {
            return this.__data__.has(jt);
          }
          function ft(jt, mt) {
            for (var St = jt.length; St--; )
              if ($e(jt[St][0], mt))
                return St;
            return -1;
          }
          function Ot(jt) {
            return !(!De(jt) || _e(jt)) && (He(jt) || k(jt) ? j : u).test(je(jt));
          }
          function Wt(jt, mt, St) {
            var kt = -1, Dt = T, it = jt.length, qt = !0, he = [], $ = he;
            if (St)
              qt = !1, Dt = h;
            else if (it >= v) {
              var Vt = mt ? null : ce(jt);
              if (Vt)
                return O(Vt);
              qt = !1, Dt = d, $ = new P();
            } else
              $ = mt ? [] : he;
            t:
              for (; ++kt < it; ) {
                var W = jt[kt], N = mt ? mt(W) : W;
                if (W = St || W !== 0 ? W : 0, qt && N == N) {
                  for (var R = $.length; R--; )
                    if ($[R] === N)
                      continue t;
                  mt && $.push(N), he.push(W);
                } else
                  Dt($, N, St) || ($ !== he && $.push(N), he.push(W));
              }
            return he;
          }
          ut.prototype.clear = V, ut.prototype.delete = ot, ut.prototype.get = xt, ut.prototype.has = Ut, ut.prototype.set = pt, at.prototype.clear = bt, at.prototype.delete = Q, at.prototype.get = At, at.prototype.has = Pt, at.prototype.set = q, G.prototype.clear = lt, G.prototype.delete = It, G.prototype.get = Ft, G.prototype.has = H, G.prototype.set = F, P.prototype.add = P.prototype.push = U, P.prototype.has = rt;
          var ce = nt && 1 / O(new nt([, -0]))[1] == i ? function(jt) {
            return new nt(jt);
          } : _t;
          function ye(jt, mt) {
            var St = jt.__data__;
            return Ce(mt) ? St[typeof mt == "string" ? "string" : "hash"] : St.map;
          }
          function ge(jt, mt) {
            var St = b(jt, mt);
            return Ot(St) ? St : void 0;
          }
          function Ce(jt) {
            var mt = typeof jt;
            return mt == "string" || mt == "number" || mt == "symbol" || mt == "boolean" ? jt !== "__proto__" : jt === null;
          }
          function _e(jt) {
            return !!B && B in jt;
          }
          function je(jt) {
            if (jt != null) {
              try {
                return X.call(jt);
              } catch (mt) {
              }
              try {
                return jt + "";
              } catch (mt) {
              }
            }
            return "";
          }
          function Ie(jt) {
            return jt && jt.length ? Wt(jt) : [];
          }
          function $e(jt, mt) {
            return jt === mt || jt != jt && mt != mt;
          }
          function He(jt) {
            var mt = De(jt) ? D.call(jt) : "";
            return mt == s || mt == r;
          }
          function De(jt) {
            var mt = typeof jt;
            return !!jt && (mt == "object" || mt == "function");
          }
          function _t() {
          }
          C.exports = Ie;
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 130: [function(x, C, c) {
      function p(i, s) {
        var r = i;
        return s.slice(0, -1).forEach(function(o) {
          r = r[o] || {};
        }), s[s.length - 1] in r;
      }
      function v(i) {
        return typeof i == "number" || !!/^0x[0-9a-f]+$/i.test(i) || /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(i);
      }
      function n(i, s) {
        return s === "constructor" && typeof i[s] == "function" || s === "__proto__";
      }
      C.exports = function(i, s) {
        s || (s = {});
        var r = { bools: {}, strings: {}, unknownFn: null };
        typeof s.unknown == "function" && (r.unknownFn = s.unknown), typeof s.boolean == "boolean" && s.boolean ? r.allBools = !0 : [].concat(s.boolean).filter(Boolean).forEach(function(E) {
          r.bools[E] = !0;
        });
        var o = {};
        Object.keys(s.alias || {}).forEach(function(E) {
          o[E] = [].concat(s.alias[E]), o[E].forEach(function(M) {
            o[M] = [E].concat(o[E].filter(function(B) {
              return M !== B;
            }));
          });
        }), [].concat(s.string).filter(Boolean).forEach(function(E) {
          r.strings[E] = !0, o[E] && (r.strings[o[E]] = !0);
        });
        var u = s.default || {}, a = { _: [] };
        Object.keys(r.bools).forEach(function(E) {
          y(E, u[E] !== void 0 && u[E]);
        });
        var f = [];
        function y(E, M, B) {
          if (!B || !r.unknownFn || function(K, D) {
            return r.allBools && /^--[^=]+$/.test(D) || r.strings[K] || r.bools[K] || o[K];
          }(E, B) || r.unknownFn(B) !== !1) {
            var X = !r.strings[E] && v(M) ? Number(M) : M;
            T(a, E.split("."), X), (o[E] || []).forEach(function(K) {
              T(a, K.split("."), X);
            });
          }
        }
        function T(E, M, B) {
          for (var X = E, K = 0; K < M.length - 1; K++) {
            if (n(X, D = M[K]))
              return;
            X[D] === void 0 && (X[D] = {}), X[D] !== Object.prototype && X[D] !== Number.prototype && X[D] !== String.prototype || (X[D] = {}), X[D] === Array.prototype && (X[D] = []), X = X[D];
          }
          var D;
          n(X, D = M[M.length - 1]) || (X !== Object.prototype && X !== Number.prototype && X !== String.prototype || (X = {}), X === Array.prototype && (X = []), X[D] === void 0 || r.bools[D] || typeof X[D] == "boolean" ? X[D] = B : Array.isArray(X[D]) ? X[D].push(B) : X[D] = [X[D], B]);
        }
        function h(E) {
          return o[E].some(function(M) {
            return r.bools[M];
          });
        }
        i.indexOf("--") !== -1 && (f = i.slice(i.indexOf("--") + 1), i = i.slice(0, i.indexOf("--")));
        for (var _ = 0; _ < i.length; _++) {
          var g = i[_];
          if (/^--.+=/.test(g)) {
            var S = g.match(/^--([^=]+)=([\s\S]*)$/), d = S[1], b = S[2];
            r.bools[d] && (b = b !== "false"), y(d, b, g);
          } else if (/^--no-.+/.test(g))
            y(d = g.match(/^--no-(.+)/)[1], !1, g);
          else if (/^--.+/.test(g))
            d = g.match(/^--(.+)/)[1], (l = i[_ + 1]) === void 0 || /^-/.test(l) || r.bools[d] || r.allBools || o[d] && h(d) ? /^(true|false)$/.test(l) ? (y(d, l === "true", g), _++) : y(d, !r.strings[d] || "", g) : (y(d, l, g), _++);
          else if (/^-[^-]+/.test(g)) {
            for (var k = g.slice(1, -1).split(""), O = !1, A = 0; A < k.length; A++) {
              var l;
              if ((l = g.slice(A + 2)) !== "-") {
                if (/[A-Za-z]/.test(k[A]) && /=/.test(l)) {
                  y(k[A], l.split("=")[1], g), O = !0;
                  break;
                }
                if (/[A-Za-z]/.test(k[A]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(l)) {
                  y(k[A], l, g), O = !0;
                  break;
                }
                if (k[A + 1] && k[A + 1].match(/\W/)) {
                  y(k[A], g.slice(A + 2), g), O = !0;
                  break;
                }
                y(k[A], !r.strings[k[A]] || "", g);
              } else
                y(k[A], l, g);
            }
            d = g.slice(-1)[0], O || d === "-" || (!i[_ + 1] || /^(-|--)[^-]/.test(i[_ + 1]) || r.bools[d] || o[d] && h(d) ? i[_ + 1] && /^(true|false)$/.test(i[_ + 1]) ? (y(d, i[_ + 1] === "true", g), _++) : y(d, !r.strings[d] || "", g) : (y(d, i[_ + 1], g), _++));
          } else if (r.unknownFn && r.unknownFn(g) === !1 || a._.push(r.strings._ || !v(g) ? g : Number(g)), s.stopEarly) {
            a._.push.apply(a._, i.slice(_ + 1));
            break;
          }
        }
        return Object.keys(u).forEach(function(E) {
          p(a, E.split(".")) || (T(a, E.split("."), u[E]), (o[E] || []).forEach(function(M) {
            T(a, M.split("."), u[E]);
          }));
        }), s["--"] ? (a["--"] = new Array(), f.forEach(function(E) {
          a["--"].push(E);
        })) : f.forEach(function(E) {
          a._.push(E);
        }), a;
      };
    }, {}], 131: [function(x, C, c) {
      (function(p) {
        (function() {
          (function(v) {
            typeof c == "object" && typeof C != "undefined" ? C.exports = v() : (typeof window != "undefined" ? window : typeof p != "undefined" ? p : typeof self != "undefined" ? self : this).Nid = v();
          })(function() {
            var v = {};
            Object.defineProperty(v, "__esModule", { value: !0 });
            const n = [[102, 117, 99, 107], [115, 104, 105, 116], [99, 117, 110, 116], [110, 105, 103, 103], [99, 111, 99, 107], [115, 117, 99, 107], [98, 105, 116, 99, 104], [97, 115, 115], [104, 111, 108, 101], [119, 104, 111, 114, 101], [119, 97, 110, 107], [115, 108, 117, 116], [112, 117, 115, 115], [101, 114, 114, 111, 114]], i = { len: 6, alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" };
            let s, r;
            function o(f) {
              return typeof f == "string" && (f = f.split(/\s*,\s*/)), Array.isArray(f) ? function(y) {
                const T = y.toLowerCase();
                for (let h = 0; h < f.length; h++)
                  if (T.indexOf(f[h]) != -1)
                    return !0;
              } : typeof f == "function" ? f : f instanceof RegExp ? (y) => !!y.match(f) : () => !1;
            }
            function u(f) {
              let y = i.len, T = i.alphabet;
              s == null && (r = n.map((S) => S.map((d) => String.fromCharCode(d)).join("")), s = o(r));
              let h = s;
              f && (y = f.length || f.len || y || 0, T = f.alphabet || T, h = f.curses ? o(f.curses) : h);
              let _ = null;
              const g = (T = T == null ? "" : T).length || 0;
              do {
                const S = (/* @__PURE__ */ new Date()).getTime(), d = [];
                for (let b = 0; b < y; b++) {
                  const k = Math.floor(S * Math.random() % g);
                  d.push(T[k]);
                }
                _ = d.join("");
              } while (h(_));
              return _;
            }
            function a(f) {
              return f ? typeof f == "number" ? u({ len: f }) : typeof f == "object" ? function(y) {
                y.len = y.len || y.length, ["len", "alphabet", "curses"].forEach(function(_) {
                  y[_] = y[_] === void 0 ? i[_] : y[_];
                }), y.hex ? y.alphabet = "0123456789abcdef" : y.HEX && (y.alphabet = "0123456789ABCDEF"), y.curses = y.exclude || y.curses;
                let T = function() {
                  return u(y);
                };
                const h = y.curses;
                return T.curses = () => h || s, T.len = y.len, T.alphabet = y.alphabet, T;
              }(f) : u() : u();
            }
            return a(), a.curses = () => r, a.len = i.len, a.alphabet = i.alphabet, v.default = a, a;
          });
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 132: [function(x, C, c) {
      function p(i, s) {
        function r() {
          this.constructor = i;
        }
        r.prototype = s.prototype, i.prototype = new r();
      }
      function v(i, s, r, o) {
        this.message = i, this.expected = s, this.found = r, this.location = o, this.name = "SyntaxError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, v);
      }
      function n(i, s) {
        s = s !== void 0 ? s : {};
        var r, o = {}, u = { start: rn }, a = rn, f = "{", y = Gt("{", !1), T = "}", h = Gt("}", !1), _ = function(Yt) {
          return ln.object = !!Yt, ln;
        }, g = /^[ \t\r\n]/, S = be([" ", "	", "\r", `
`], !1, !1), d = ",", b = Gt(",", !1), k = function(Yt, oe, ie) {
          ln.push({ name: Yt, type: oe, mod: ie });
        }, O = /^[a-zA-Z]/, A = be([["a", "z"], ["A", "Z"]], !1, !1), l = /^[a-zA-Z0-9]/, E = be([["a", "z"], ["A", "Z"], ["0", "9"]], !1, !1), M = ":", B = Gt(":", !1), X = function(Yt, oe) {
          return Yt + oe.join("");
        }, K = "?", D = Gt("?", !1), j = function() {
          return "?";
        }, Z = "*", tt = Gt("*", !1), nt = function() {
          return "*";
        }, ct = "+", ut = Gt("+", !1), V = function() {
          return "+";
        }, ot = "|", xt = Gt("|", !1), Ut = function(Yt) {
          return { mark: Yt[0], or: Yt[1] };
        }, pt = function() {
          return ".";
        }, at = function() {
          return "s";
        }, bt = function() {
          return "i";
        }, Q = function() {
          return "A";
        }, At = function() {
          return "Y";
        }, Pt = function() {
          return "n";
        }, q = function() {
          return "b";
        }, G = function() {
          return "f";
        }, lt = function() {
          return "a";
        }, It = function() {
          return "r";
        }, Ft = function() {
          return "d";
        }, H = function() {
          return "g";
        }, F = function() {
          return "e";
        }, P = function() {
          return "N";
        }, U = function() {
          return "U";
        }, rt = function() {
          return "o";
        }, ft = ".", Ot = Gt(".", !1), Wt = "s", ce = Gt("s", !1), ye = "i", ge = Gt("i", !1), Ce = "A", _e = Gt("A", !1), je = "Y", Ie = Gt("Y", !1), $e = "n", He = Gt("n", !1), De = "b", _t = Gt("b", !1), jt = "f", mt = Gt("f", !1), St = "a", kt = Gt("a", !1), Dt = "r", it = Gt("r", !1), qt = "d", he = Gt("d", !1), $ = "g", Vt = Gt("g", !1), W = "e", N = Gt("e", !1), R = "N", z = Gt("N", !1), et = "U", ht = Gt("U", !1), yt = "o", Ct = Gt("o", !1), Et = /^[^}]/, Zt = be(["}"], !0, !1), Qt = function(Yt) {
          (function(oe, ie) {
            throw ie = ie !== void 0 ? ie : we(Lt, Rt), function(Ye, We) {
              return new v(Ye, null, null, We);
            }(oe, ie);
          })('not a type character: "' + Yt + '"');
        }, Rt = 0, Lt = 0, te = [{ line: 1, column: 1 }], Oe = 0, ke = [];
        if ("startRule" in s) {
          if (!(s.startRule in u))
            throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
          a = u[s.startRule];
        }
        function Gt(Yt, oe) {
          return { type: "literal", text: Yt, ignoreCase: oe };
        }
        function be(Yt, oe, ie) {
          return { type: "class", parts: Yt, inverted: oe, ignoreCase: ie };
        }
        function ve(Yt) {
          var oe, ie = te[Yt];
          if (ie)
            return ie;
          for (oe = Yt - 1; !te[oe]; )
            oe--;
          for (ie = { line: (ie = te[oe]).line, column: ie.column }; oe < Yt; )
            i.charCodeAt(oe) === 10 ? (ie.line++, ie.column = 1) : ie.column++, oe++;
          return te[Yt] = ie, ie;
        }
        function we(Yt, oe) {
          var ie = ve(Yt), Ye = ve(oe);
          return { start: { offset: Yt, line: ie.line, column: ie.column }, end: { offset: oe, line: Ye.line, column: Ye.column } };
        }
        function se(Yt) {
          Rt < Oe || (Rt > Oe && (Oe = Rt, ke = []), ke.push(Yt));
        }
        function Ue(Yt, oe, ie) {
          return new v(v.buildMessage(Yt, oe), Yt, oe, ie);
        }
        function rn() {
          var Yt, oe, ie, Ye, We, Le, Te, Re;
          if (Yt = Rt, (oe = pn()) === o && (oe = null), oe !== o)
            if (i.charCodeAt(Rt) === 123 ? (ie = f, Rt++) : (ie = o, se(y)), ie === o && (ie = null), ie !== o)
              if ((Ye = pn()) === o && (Ye = null), Ye !== o)
                if (An() !== o) {
                  for (We = [], Le = Rt, (Te = Tn()) === o && (Te = null), Te !== o && (Re = An()) !== o ? Le = Te = [Te, Re] : (Rt = Le, Le = o); Le !== o; )
                    We.push(Le), Le = Rt, (Te = Tn()) === o && (Te = null), Te !== o && (Re = An()) !== o ? Le = Te = [Te, Re] : (Rt = Le, Le = o);
                  We !== o ? ((Le = Tn()) === o && (Le = null), Le !== o ? (i.charCodeAt(Rt) === 125 ? (Te = T, Rt++) : (Te = o, se(h)), Te === o && (Te = null), Te !== o ? ((Re = pn()) === o && (Re = null), Re !== o ? (Lt = Yt, Yt = oe = _(ie)) : (Rt = Yt, Yt = o)) : (Rt = Yt, Yt = o)) : (Rt = Yt, Yt = o)) : (Rt = Yt, Yt = o);
                } else
                  Rt = Yt, Yt = o;
              else
                Rt = Yt, Yt = o;
            else
              Rt = Yt, Yt = o;
          else
            Rt = Yt, Yt = o;
          return Yt;
        }
        function pn() {
          var Yt;
          return g.test(i.charAt(Rt)) ? (Yt = i.charAt(Rt), Rt++) : (Yt = o, se(S)), Yt;
        }
        function Tn() {
          var Yt, oe, ie, Ye;
          return Yt = Rt, (oe = pn()) === o && (oe = null), oe !== o ? (i.charCodeAt(Rt) === 44 ? (ie = d, Rt++) : (ie = o, se(b)), ie === o && (ie = null), ie !== o ? ((Ye = pn()) === o && (Ye = null), Ye !== o ? Yt = oe = [oe, ie, Ye] : (Rt = Yt, Yt = o)) : (Rt = Yt, Yt = o)) : (Rt = Yt, Yt = o), Yt;
        }
        function An() {
          var Yt, oe, ie, Ye;
          return Yt = Rt, (oe = function() {
            var We, Le, Te, Re;
            if (We = Rt, O.test(i.charAt(Rt)) ? (Le = i.charAt(Rt), Rt++) : (Le = o, se(A)), Le !== o) {
              for (Te = [], l.test(i.charAt(Rt)) ? (Re = i.charAt(Rt), Rt++) : (Re = o, se(E)); Re !== o; )
                Te.push(Re), l.test(i.charAt(Rt)) ? (Re = i.charAt(Rt), Rt++) : (Re = o, se(E));
              Te !== o ? (i.charCodeAt(Rt) === 58 ? (Re = M, Rt++) : (Re = o, se(B)), Re !== o ? (Lt = We, Le = X(Le, Te), We = Le) : (Rt = We, We = o)) : (Rt = We, We = o);
            } else
              Rt = We, We = o;
            return We;
          }()) === o && (oe = null), oe !== o && (ie = function() {
            var We, Le, Te, Re, en, cn, J;
            if (We = Rt, Le = Rt, (Te = vn()) !== o) {
              for (Re = [], en = Rt, i.charCodeAt(Rt) === 124 ? (cn = ot, Rt++) : (cn = o, se(xt)), cn !== o && (J = vn()) !== o ? en = cn = [cn, J] : (Rt = en, en = o); en !== o; )
                Re.push(en), en = Rt, i.charCodeAt(Rt) === 124 ? (cn = ot, Rt++) : (cn = o, se(xt)), cn !== o && (J = vn()) !== o ? en = cn = [cn, J] : (Rt = en, en = o);
              Re !== o ? Le = Te = [Te, Re] : (Rt = Le, Le = o);
            } else
              Rt = Le, Le = o;
            return Le !== o && (Lt = We, Le = Ut(Le)), We = Le;
          }()) !== o ? ((Ye = function() {
            var We, Le;
            return We = Rt, i.charCodeAt(Rt) === 63 ? (Le = K, Rt++) : (Le = o, se(D)), Le !== o && (Lt = We, Le = j()), (We = Le) === o && (We = Rt, i.charCodeAt(Rt) === 42 ? (Le = Z, Rt++) : (Le = o, se(tt)), Le !== o && (Lt = We, Le = nt()), (We = Le) === o && (We = Rt, i.charCodeAt(Rt) === 43 ? (Le = ct, Rt++) : (Le = o, se(ut)), Le !== o && (Lt = We, Le = V()), We = Le)), We;
          }()) === o && (Ye = null), Ye !== o ? (Lt = Yt, Yt = oe = k(oe, ie, Ye)) : (Rt = Yt, Yt = o)) : (Rt = Yt, Yt = o), Yt;
        }
        function vn() {
          var Yt, oe;
          return Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 46 ? (ie = ft, Rt++) : (ie = o, se(Ot)), ie;
          }()) !== o && (Lt = Yt, oe = pt()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 115 ? (ie = Wt, Rt++) : (ie = o, se(ce)), ie;
          }()) !== o && (Lt = Yt, oe = at()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 105 ? (ie = ye, Rt++) : (ie = o, se(ge)), ie;
          }()) !== o && (Lt = Yt, oe = bt()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 65 ? (ie = Ce, Rt++) : (ie = o, se(_e)), ie;
          }()) !== o && (Lt = Yt, oe = Q()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 89 ? (ie = je, Rt++) : (ie = o, se(Ie)), ie;
          }()) !== o && (Lt = Yt, oe = At()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 110 ? (ie = $e, Rt++) : (ie = o, se(He)), ie;
          }()) !== o && (Lt = Yt, oe = Pt()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 98 ? (ie = De, Rt++) : (ie = o, se(_t)), ie;
          }()) !== o && (Lt = Yt, oe = q()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 102 ? (ie = jt, Rt++) : (ie = o, se(mt)), ie;
          }()) !== o && (Lt = Yt, oe = G()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 97 ? (ie = St, Rt++) : (ie = o, se(kt)), ie;
          }()) !== o && (Lt = Yt, oe = lt()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 114 ? (ie = Dt, Rt++) : (ie = o, se(it)), ie;
          }()) !== o && (Lt = Yt, oe = It()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 100 ? (ie = qt, Rt++) : (ie = o, se(he)), ie;
          }()) !== o && (Lt = Yt, oe = Ft()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 103 ? (ie = $, Rt++) : (ie = o, se(Vt)), ie;
          }()) !== o && (Lt = Yt, oe = H()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 101 ? (ie = W, Rt++) : (ie = o, se(N)), ie;
          }()) !== o && (Lt = Yt, oe = F()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 78 ? (ie = R, Rt++) : (ie = o, se(z)), ie;
          }()) !== o && (Lt = Yt, oe = P()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 85 ? (ie = et, Rt++) : (ie = o, se(ht)), ie;
          }()) !== o && (Lt = Yt, oe = U()), (Yt = oe) === o && (Yt = Rt, (oe = function() {
            var ie;
            return i.charCodeAt(Rt) === 111 ? (ie = yt, Rt++) : (ie = o, se(Ct)), ie;
          }()) !== o && (Lt = Yt, oe = rt()), (Yt = oe) === o && (Yt = function() {
            var ie, Ye;
            return ie = Rt, Et.test(i.charAt(Rt)) ? (Ye = i.charAt(Rt), Rt++) : (Ye = o, se(Zt)), Ye !== o && (Lt = ie, Ye = Qt(Ye)), ie = Ye;
          }())))))))))))))))), Yt;
        }
        var ln = [];
        if ((r = a()) !== o && Rt === i.length)
          return r;
        throw r !== o && Rt < i.length && se({ type: "end" }), Ue(ke, Oe < i.length ? i.charAt(Oe) : null, Oe < i.length ? we(Oe, Oe + 1) : we(Oe, Oe));
      }
      p(v, Error), v.buildMessage = function(i, s) {
        var r = { literal: function(f) {
          return '"' + u(f.text) + '"';
        }, class: function(f) {
          var y, T = "";
          for (y = 0; y < f.parts.length; y++)
            T += f.parts[y] instanceof Array ? a(f.parts[y][0]) + "-" + a(f.parts[y][1]) : a(f.parts[y]);
          return "[" + (f.inverted ? "^" : "") + T + "]";
        }, any: function(f) {
          return "any character";
        }, end: function(f) {
          return "end of input";
        }, other: function(f) {
          return f.description;
        } };
        function o(f) {
          return f.charCodeAt(0).toString(16).toUpperCase();
        }
        function u(f) {
          return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(y) {
            return "\\x0" + o(y);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(y) {
            return "\\x" + o(y);
          });
        }
        function a(f) {
          return f.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(y) {
            return "\\x0" + o(y);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(y) {
            return "\\x" + o(y);
          });
        }
        return "Expected " + function(f) {
          var y, T, h, _ = new Array(f.length);
          for (y = 0; y < f.length; y++)
            _[y] = (h = f[y], r[h.type](h));
          if (_.sort(), _.length > 0) {
            for (y = 1, T = 1; y < _.length; y++)
              _[y - 1] !== _[y] && (_[T] = _[y], T++);
            _.length = T;
          }
          switch (_.length) {
            case 1:
              return _[0];
            case 2:
              return _[0] + " or " + _[1];
            default:
              return _.slice(0, -1).join(", ") + ", or " + _[_.length - 1];
          }
        }(i) + " but " + function(f) {
          return f ? '"' + u(f) + '"' : "end of input";
        }(s) + " found.";
      }, C.exports = { SyntaxError: v, parse: n };
    }, {}], 133: [function(x, C, c) {
      var p = x("util"), v = {};
      v.isNaN = x("lodash.isnan"), v.isRegExp = x("lodash.isregexp"), v.isDate = x("lodash.isdate"), v.isArguments = x("lodash.isarguments");
      var n = x("eraro")({ package: "norma" }), i = x("./norma-parser"), s = { onfail: "throw", desclen: 33 }, r = {};
      function o(h) {
        if (h == null)
          throw n("no_spec", "no argument specification");
        var _ = r[h];
        if (_ != null)
          return _;
        var g = u(h), S = [], d = 1, b = ["^"], k = 0;
        g.forEach(function(A) {
          if (b.push("("), A.type.or && 0 < A.type.or.length) {
            var l = 1;
            b.push("("), b.push(A.type.mark), b.push(")"), A.type.or.forEach(function(E) {
              b.push("|"), b.push("("), b.push(E[1]), l++, b.push(")");
            }), A.mod == "?" && b.push("|[UNA]?"), S[k] = { index: d }, d += l;
          } else
            A.mod == "?" ? b.push("[UNA" + A.type.mark + "]?") : (b.push(A.type.mark), b.push(A.mod || "")), S[k] = { index: d };
          S[k].mod = A.mod, b.push(")"), d++, k++;
        }), b.push("$");
        var O = new RegExp(b.join(""));
        return _ = r[h] = { re: O, spec: h, respec: g, reindex: S };
      }
      function u(h) {
        try {
          return i.parse(h);
        } catch (_) {
          throw n("parse", _.message + '; spec:"' + h + '", col:' + _.location.start.column + ", line:" + _.location.start.line);
        }
      }
      function a(h, _, g) {
        var S = Array.prototype.slice.call(g || []), d = f(S), b = h.re.exec(d);
        if (!b) {
          if (_.onfail == "throw")
            throw n("invalid_arguments", 'invalid arguments; expected: "' + h.spec + '", was: [' + d + "]; values: " + y(S, _), { args: S, specdef: h, options: _ });
          return null;
        }
        for (var k = h.respec.object ? {} : [], O = 0, A = 0, l = 0; O < h.reindex.length; O++) {
          var E = h.reindex[O], M = void 0;
          if (h.respec.object || (k[l] = M), E.index != null) {
            var B = b[E.index];
            if (B !== "") {
              var X = h.respec[O].name, K = h.respec[O].mod === "*", D = h.respec[O].mod === "+";
              if (B.length === 0 && D)
                throw n("invalid_arguments", 'invalid arguments; expected: "' + h.spec + '", was: [' + d + "]; values: " + y(S, _), { args: S, specdef: h, options: _ });
              if (B.length == 1)
                M = S[A], A++, h.respec.object || (k[l] = M), X != null && (K || D ? (k[X] = k[X] || []).push(M) : k[h.respec[O].name] = M), l++;
              else if (1 < B.length)
                for (var j = 0; j < B.length; j++)
                  M = S[A], A++, h.respec.object || (k[l] = M), X != null && (k[X] = k[X] || []).push(M), l++;
            } else
              h.respec.object || (k[l] = void 0), l++;
          }
        }
        return k;
      }
      function f(h) {
        var _ = [];
        return h.forEach(function(g) {
          typeof g == "string" ? _.push("s") : isNaN(g) || (0 | g) !== parseFloat(g) ? v.isNaN(g) ? _.push("A") : 1 / 0 === g ? _.push("Y") : typeof g == "number" ? _.push("n") : typeof g == "boolean" ? _.push("b") : typeof g == "function" ? _.push("f") : Array.isArray(g) ? _.push("a") : v.isRegExp(g) ? _.push("r") : v.isDate(g) ? _.push("d") : v.isArguments(g) ? _.push("g") : p.isError(g) ? _.push("e") : g === null ? _.push("N") : g === void 0 ? _.push("U") : typeof g == "object" ? _.push("o") : _.push("q") : _.push("i");
        }), _.join("");
      }
      function y(h, _) {
        var g = [];
        return h.forEach(function(S) {
          var d = p.inspect(S).substring(0, _.desclen);
          g.push(d);
        }), g;
      }
      function T(h, _, g) {
        if ((v.isArguments(_) || Array.isArray(_)) && (g = _, _ = null), _ = _ == null ? s : Object.assign({}, s, _), g == null)
          throw n("init", 'no arguments variable; expected norma( "...", arguments ), or <compiled>( arguments )', { arguments });
        return a(h, _, g);
      }
      C.exports = function(h, _, g) {
        return T(o(h), _, g);
      }, C.exports.compile = function(h) {
        var _ = o(h), g = function(S, d) {
          return T(_, S, d);
        };
        return g.toString = function() {
          return p.inspect({ spec: _.spec, re: "" + _.re });
        }, g;
      };
    }, { "./norma-parser": 132, eraro: 51, "lodash.isarguments": 123, "lodash.isdate": 124, "lodash.isnan": 125, "lodash.isregexp": 126, util: 238 }], 134: [function(x, C, c) {
      (function(p) {
        (function() {
          (function(v) {
            typeof c == "object" && typeof C != "undefined" ? C.exports = v() : (typeof window != "undefined" ? window : typeof p != "undefined" ? p : typeof self != "undefined" ? self : this).Nua = v();
          })(function() {
            return function(v, n, i) {
              var s = (i = i || {}).depth || Number.MAX_VALUE, r = i.setter, o = !!i.preserve;
              typeof v == "object" && typeof n == "object" && function u(a, f, y) {
                if (!(a == null || f == null || s <= y)) {
                  var T = y + 1;
                  if (Array.isArray(a) && Array.isArray(f)) {
                    for (var h = 0; h < a.length; h++)
                      typeof a[h] == "object" ? u(a[h], f[h], T) : r ? r(a, h, f[h]) : a[h] = f[h];
                    for (; h < f.length; h++)
                      r ? r(a, h, f[h]) : a[h] = f[h];
                    a.splice(f.length);
                  } else {
                    for (var _ = Object.keys(a), g = 0; g < _.length; g++) {
                      var S = a[_[g]], d = f[_[g]];
                      (S === null ? "null" : typeof S) == "object" && (d === null ? "null" : typeof d) == "object" ? u(S, d, T) : d === void 0 ? o || delete a[_[g]] : r ? r(a, _[g], d) : a[_[g]] = d;
                    }
                    for (var b = Object.keys(f), k = 0; k < b.length; k++)
                      a[b[k]] === void 0 && (r ? (r(a, b[k], f[b[k]]), f[b[k]] == null || !Array.isArray(f[b[k]]) && typeof f[b[k]] != "object" || u(a[b[k]], f[b[k]], T)) : a[b[k]] = f[b[k]]);
                  }
                }
              }(v, n, 0);
            };
          });
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 135: [function(x, C, c) {
      var p = Object.getOwnPropertySymbols, v = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
      function i(r) {
        if (r == null)
          throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(r);
      }
      function s() {
        try {
          if (!Object.assign)
            return !1;
          var r = new String("abc");
          if (r[5] = "de", Object.getOwnPropertyNames(r)[0] === "5")
            return !1;
          for (var o = {}, u = 0; u < 10; u++)
            o["_" + String.fromCharCode(u)] = u;
          if (Object.getOwnPropertyNames(o).map(function(f) {
            return o[f];
          }).join("") !== "0123456789")
            return !1;
          var a = {};
          return "abcdefghijklmnopqrst".split("").forEach(function(f) {
            a[f] = f;
          }), Object.keys(Object.assign({}, a)).join("") === "abcdefghijklmnopqrst";
        } catch (f) {
          return !1;
        }
      }
      C.exports = s() ? Object.assign : function(r, o) {
        for (var u, a, f = i(r), y = 1; y < arguments.length; y++) {
          for (var T in u = Object(arguments[y]))
            v.call(u, T) && (f[T] = u[T]);
          if (p) {
            a = p(u);
            for (var h = 0; h < a.length; h++)
              n.call(u, a[h]) && (f[a[h]] = u[a[h]]);
          }
        }
        return f;
      };
    }, {}], 136: [function(x, C, c) {
      var p = typeof Map == "function" && Map.prototype, v = Object.getOwnPropertyDescriptor && p ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, n = p && v && typeof v.get == "function" ? v.get : null, i = p && Map.prototype.forEach, s = typeof Set == "function" && Set.prototype, r = Object.getOwnPropertyDescriptor && s ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, o = s && r && typeof r.get == "function" ? r.get : null, u = s && Set.prototype.forEach, a = typeof WeakMap == "function" && WeakMap.prototype, f = a ? WeakMap.prototype.has : null, y = typeof WeakSet == "function" && WeakSet.prototype, T = y ? WeakSet.prototype.has : null, h = typeof WeakRef == "function" && WeakRef.prototype, _ = h ? WeakRef.prototype.deref : null, g = Boolean.prototype.valueOf, S = Object.prototype.toString, d = Function.prototype.toString, b = String.prototype.match, k = String.prototype.slice, O = String.prototype.replace, A = String.prototype.toUpperCase, l = String.prototype.toLowerCase, E = RegExp.prototype.test, M = Array.prototype.concat, B = Array.prototype.join, X = Array.prototype.slice, K = Math.floor, D = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, j = Object.getOwnPropertySymbols, Z = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, tt = typeof Symbol == "function" && typeof Symbol.iterator == "object", nt = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === tt || "symbol") ? Symbol.toStringTag : null, ct = Object.prototype.propertyIsEnumerable, ut = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(mt) {
        return mt.__proto__;
      } : null);
      function V(mt, St) {
        if (mt === 1 / 0 || mt === -1 / 0 || mt != mt || mt && mt > -1e3 && mt < 1e3 || E.call(/e/, St))
          return St;
        var kt = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof mt == "number") {
          var Dt = mt < 0 ? -K(-mt) : K(mt);
          if (Dt !== mt) {
            var it = String(Dt), qt = k.call(St, it.length + 1);
            return O.call(it, kt, "$&_") + "." + O.call(O.call(qt, /([0-9]{3})/g, "$&_"), /_$/, "");
          }
        }
        return O.call(St, kt, "$&_");
      }
      var ot = x("./util.inspect"), xt = ot.custom, Ut = It(xt) ? xt : null;
      function pt(mt, St, kt) {
        var Dt = (kt.quoteStyle || St) === "double" ? '"' : "'";
        return Dt + mt + Dt;
      }
      function at(mt) {
        return O.call(String(mt), /"/g, "&quot;");
      }
      function bt(mt) {
        return !(P(mt) !== "[object Array]" || nt && typeof mt == "object" && nt in mt);
      }
      function Q(mt) {
        return !(P(mt) !== "[object Date]" || nt && typeof mt == "object" && nt in mt);
      }
      function At(mt) {
        return !(P(mt) !== "[object RegExp]" || nt && typeof mt == "object" && nt in mt);
      }
      function Pt(mt) {
        return !(P(mt) !== "[object Error]" || nt && typeof mt == "object" && nt in mt);
      }
      function q(mt) {
        return !(P(mt) !== "[object String]" || nt && typeof mt == "object" && nt in mt);
      }
      function G(mt) {
        return !(P(mt) !== "[object Number]" || nt && typeof mt == "object" && nt in mt);
      }
      function lt(mt) {
        return !(P(mt) !== "[object Boolean]" || nt && typeof mt == "object" && nt in mt);
      }
      function It(mt) {
        if (tt)
          return mt && typeof mt == "object" && mt instanceof Symbol;
        if (typeof mt == "symbol")
          return !0;
        if (!mt || typeof mt != "object" || !Z)
          return !1;
        try {
          return Z.call(mt), !0;
        } catch (St) {
        }
        return !1;
      }
      function Ft(mt) {
        if (!mt || typeof mt != "object" || !D)
          return !1;
        try {
          return D.call(mt), !0;
        } catch (St) {
        }
        return !1;
      }
      C.exports = function mt(St, kt, Dt, it) {
        var qt = kt || {};
        if (F(qt, "quoteStyle") && qt.quoteStyle !== "single" && qt.quoteStyle !== "double")
          throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (F(qt, "maxStringLength") && (typeof qt.maxStringLength == "number" ? qt.maxStringLength < 0 && qt.maxStringLength !== 1 / 0 : qt.maxStringLength !== null))
          throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var he = !F(qt, "customInspect") || qt.customInspect;
        if (typeof he != "boolean" && he !== "symbol")
          throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (F(qt, "indent") && qt.indent !== null && qt.indent !== "	" && !(parseInt(qt.indent, 10) === qt.indent && qt.indent > 0))
          throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (F(qt, "numericSeparator") && typeof qt.numericSeparator != "boolean")
          throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var $ = qt.numericSeparator;
        if (St === void 0)
          return "undefined";
        if (St === null)
          return "null";
        if (typeof St == "boolean")
          return St ? "true" : "false";
        if (typeof St == "string")
          return Ce(St, qt);
        if (typeof St == "number") {
          if (St === 0)
            return 1 / 0 / St > 0 ? "0" : "-0";
          var Vt = String(St);
          return $ ? V(St, Vt) : Vt;
        }
        if (typeof St == "bigint") {
          var W = String(St) + "n";
          return $ ? V(St, W) : W;
        }
        var N = qt.depth === void 0 ? 5 : qt.depth;
        if (Dt === void 0 && (Dt = 0), Dt >= N && N > 0 && typeof St == "object")
          return bt(St) ? "[Array]" : "[Object]";
        var R = De(qt, Dt);
        if (it === void 0)
          it = [];
        else if (rt(it, St) >= 0)
          return "[Circular]";
        function z(we, se, Ue) {
          if (se && (it = X.call(it)).push(se), Ue) {
            var rn = { depth: qt.depth };
            return F(qt, "quoteStyle") && (rn.quoteStyle = qt.quoteStyle), mt(we, rn, Dt + 1, it);
          }
          return mt(we, qt, Dt + 1, it);
        }
        if (typeof St == "function" && !At(St)) {
          var et = U(St), ht = jt(St, z);
          return "[Function" + (et ? ": " + et : " (anonymous)") + "]" + (ht.length > 0 ? " { " + B.call(ht, ", ") + " }" : "");
        }
        if (It(St)) {
          var yt = tt ? O.call(String(St), /^(Symbol\(.*\))_[^)]*$/, "$1") : Z.call(St);
          return typeof St != "object" || tt ? yt : je(yt);
        }
        if (ge(St)) {
          for (var Ct = "<" + l.call(String(St.nodeName)), Et = St.attributes || [], Zt = 0; Zt < Et.length; Zt++)
            Ct += " " + Et[Zt].name + "=" + pt(at(Et[Zt].value), "double", qt);
          return Ct += ">", St.childNodes && St.childNodes.length && (Ct += "..."), Ct += "</" + l.call(String(St.nodeName)) + ">";
        }
        if (bt(St)) {
          if (St.length === 0)
            return "[]";
          var Qt = jt(St, z);
          return R && !He(Qt) ? "[" + _t(Qt, R) + "]" : "[ " + B.call(Qt, ", ") + " ]";
        }
        if (Pt(St)) {
          var Rt = jt(St, z);
          return "cause" in Error.prototype || !("cause" in St) || ct.call(St, "cause") ? Rt.length === 0 ? "[" + String(St) + "]" : "{ [" + String(St) + "] " + B.call(Rt, ", ") + " }" : "{ [" + String(St) + "] " + B.call(M.call("[cause]: " + z(St.cause), Rt), ", ") + " }";
        }
        if (typeof St == "object" && he) {
          if (Ut && typeof St[Ut] == "function" && ot)
            return ot(St, { depth: N - Dt });
          if (he !== "symbol" && typeof St.inspect == "function")
            return St.inspect();
        }
        if (ft(St)) {
          var Lt = [];
          return i.call(St, function(we, se) {
            Lt.push(z(se, St, !0) + " => " + z(we, St));
          }), $e("Map", n.call(St), Lt, R);
        }
        if (ce(St)) {
          var te = [];
          return u.call(St, function(we) {
            te.push(z(we, St));
          }), $e("Set", o.call(St), te, R);
        }
        if (Ot(St))
          return Ie("WeakMap");
        if (ye(St))
          return Ie("WeakSet");
        if (Wt(St))
          return Ie("WeakRef");
        if (G(St))
          return je(z(Number(St)));
        if (Ft(St))
          return je(z(D.call(St)));
        if (lt(St))
          return je(g.call(St));
        if (q(St))
          return je(z(String(St)));
        if (!Q(St) && !At(St)) {
          var Oe = jt(St, z), ke = ut ? ut(St) === Object.prototype : St instanceof Object || St.constructor === Object, Gt = St instanceof Object ? "" : "null prototype", be = !ke && nt && Object(St) === St && nt in St ? k.call(P(St), 8, -1) : Gt ? "Object" : "", ve = (ke || typeof St.constructor != "function" ? "" : St.constructor.name ? St.constructor.name + " " : "") + (be || Gt ? "[" + B.call(M.call([], be || [], Gt || []), ": ") + "] " : "");
          return Oe.length === 0 ? ve + "{}" : R ? ve + "{" + _t(Oe, R) + "}" : ve + "{ " + B.call(Oe, ", ") + " }";
        }
        return String(St);
      };
      var H = Object.prototype.hasOwnProperty || function(mt) {
        return mt in this;
      };
      function F(mt, St) {
        return H.call(mt, St);
      }
      function P(mt) {
        return S.call(mt);
      }
      function U(mt) {
        if (mt.name)
          return mt.name;
        var St = b.call(d.call(mt), /^function\s*([\w$]+)/);
        return St ? St[1] : null;
      }
      function rt(mt, St) {
        if (mt.indexOf)
          return mt.indexOf(St);
        for (var kt = 0, Dt = mt.length; kt < Dt; kt++)
          if (mt[kt] === St)
            return kt;
        return -1;
      }
      function ft(mt) {
        if (!n || !mt || typeof mt != "object")
          return !1;
        try {
          n.call(mt);
          try {
            o.call(mt);
          } catch (St) {
            return !0;
          }
          return mt instanceof Map;
        } catch (St) {
        }
        return !1;
      }
      function Ot(mt) {
        if (!f || !mt || typeof mt != "object")
          return !1;
        try {
          f.call(mt, f);
          try {
            T.call(mt, T);
          } catch (St) {
            return !0;
          }
          return mt instanceof WeakMap;
        } catch (St) {
        }
        return !1;
      }
      function Wt(mt) {
        if (!_ || !mt || typeof mt != "object")
          return !1;
        try {
          return _.call(mt), !0;
        } catch (St) {
        }
        return !1;
      }
      function ce(mt) {
        if (!o || !mt || typeof mt != "object")
          return !1;
        try {
          o.call(mt);
          try {
            n.call(mt);
          } catch (St) {
            return !0;
          }
          return mt instanceof Set;
        } catch (St) {
        }
        return !1;
      }
      function ye(mt) {
        if (!T || !mt || typeof mt != "object")
          return !1;
        try {
          T.call(mt, T);
          try {
            f.call(mt, f);
          } catch (St) {
            return !0;
          }
          return mt instanceof WeakSet;
        } catch (St) {
        }
        return !1;
      }
      function ge(mt) {
        return !(!mt || typeof mt != "object") && (typeof HTMLElement != "undefined" && mt instanceof HTMLElement || typeof mt.nodeName == "string" && typeof mt.getAttribute == "function");
      }
      function Ce(mt, St) {
        if (mt.length > St.maxStringLength) {
          var kt = mt.length - St.maxStringLength, Dt = "... " + kt + " more character" + (kt > 1 ? "s" : "");
          return Ce(k.call(mt, 0, St.maxStringLength), St) + Dt;
        }
        return pt(O.call(O.call(mt, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, _e), "single", St);
      }
      function _e(mt) {
        var St = mt.charCodeAt(0), kt = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[St];
        return kt ? "\\" + kt : "\\x" + (St < 16 ? "0" : "") + A.call(St.toString(16));
      }
      function je(mt) {
        return "Object(" + mt + ")";
      }
      function Ie(mt) {
        return mt + " { ? }";
      }
      function $e(mt, St, kt, Dt) {
        return mt + " (" + St + ") {" + (Dt ? _t(kt, Dt) : B.call(kt, ", ")) + "}";
      }
      function He(mt) {
        for (var St = 0; St < mt.length; St++)
          if (rt(mt[St], `
`) >= 0)
            return !1;
        return !0;
      }
      function De(mt, St) {
        var kt;
        if (mt.indent === "	")
          kt = "	";
        else {
          if (!(typeof mt.indent == "number" && mt.indent > 0))
            return null;
          kt = B.call(Array(mt.indent + 1), " ");
        }
        return { base: kt, prev: B.call(Array(St + 1), kt) };
      }
      function _t(mt, St) {
        if (mt.length === 0)
          return "";
        var kt = `
` + St.prev + St.base;
        return kt + B.call(mt, "," + kt) + `
` + St.prev;
      }
      function jt(mt, St) {
        var kt = bt(mt), Dt = [];
        if (kt) {
          Dt.length = mt.length;
          for (var it = 0; it < mt.length; it++)
            Dt[it] = F(mt, it) ? St(mt[it], mt) : "";
        }
        var qt, he = typeof j == "function" ? j(mt) : [];
        if (tt) {
          qt = {};
          for (var $ = 0; $ < he.length; $++)
            qt["$" + he[$]] = he[$];
        }
        for (var Vt in mt)
          F(mt, Vt) && (kt && String(Number(Vt)) === Vt && Vt < mt.length || tt && qt["$" + Vt] instanceof Symbol || (E.call(/[^\w$]/, Vt) ? Dt.push(St(Vt, mt) + ": " + St(mt[Vt], mt)) : Dt.push(Vt + ": " + St(mt[Vt], mt))));
        if (typeof j == "function")
          for (var W = 0; W < he.length; W++)
            ct.call(mt, he[W]) && Dt.push("[" + St(he[W]) + "]: " + St(mt[he[W]], mt));
        return Dt;
      }
    }, { "./util.inspect": 42 }], 137: [function(x, C, c) {
      var p;
      if (!Object.keys) {
        var v = Object.prototype.hasOwnProperty, n = Object.prototype.toString, i = x("./isArguments"), s = Object.prototype.propertyIsEnumerable, r = !s.call({ toString: null }, "toString"), o = s.call(function() {
        }, "prototype"), u = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], a = function(h) {
          var _ = h.constructor;
          return _ && _.prototype === h;
        }, f = { $applicationCache: !0, $console: !0, $external: !0, $frame: !0, $frameElement: !0, $frames: !0, $innerHeight: !0, $innerWidth: !0, $onmozfullscreenchange: !0, $onmozfullscreenerror: !0, $outerHeight: !0, $outerWidth: !0, $pageXOffset: !0, $pageYOffset: !0, $parent: !0, $scrollLeft: !0, $scrollTop: !0, $scrollX: !0, $scrollY: !0, $self: !0, $webkitIndexedDB: !0, $webkitStorageInfo: !0, $window: !0 }, y = function() {
          if (typeof window == "undefined")
            return !1;
          for (var h in window)
            try {
              if (!f["$" + h] && v.call(window, h) && window[h] !== null && typeof window[h] == "object")
                try {
                  a(window[h]);
                } catch (_) {
                  return !0;
                }
            } catch (_) {
              return !0;
            }
          return !1;
        }(), T = function(h) {
          if (typeof window == "undefined" || !y)
            return a(h);
          try {
            return a(h);
          } catch (_) {
            return !1;
          }
        };
        p = function(h) {
          var _ = h !== null && typeof h == "object", g = n.call(h) === "[object Function]", S = i(h), d = _ && n.call(h) === "[object String]", b = [];
          if (!_ && !g && !S)
            throw new TypeError("Object.keys called on a non-object");
          var k = o && g;
          if (d && h.length > 0 && !v.call(h, 0))
            for (var O = 0; O < h.length; ++O)
              b.push(String(O));
          if (S && h.length > 0)
            for (var A = 0; A < h.length; ++A)
              b.push(String(A));
          else
            for (var l in h)
              k && l === "prototype" || !v.call(h, l) || b.push(String(l));
          if (r)
            for (var E = T(h), M = 0; M < u.length; ++M)
              E && u[M] === "constructor" || !v.call(h, u[M]) || b.push(u[M]);
          return b;
        };
      }
      C.exports = p;
    }, { "./isArguments": 139 }], 138: [function(x, C, c) {
      var p = Array.prototype.slice, v = x("./isArguments"), n = Object.keys, i = n ? function(r) {
        return n(r);
      } : x("./implementation"), s = Object.keys;
      i.shim = function() {
        return Object.keys ? function() {
          var r = Object.keys(arguments);
          return r && r.length === arguments.length;
        }(1, 2) || (Object.keys = function(r) {
          return v(r) ? s(p.call(r)) : s(r);
        }) : Object.keys = i, Object.keys || i;
      }, C.exports = i;
    }, { "./implementation": 137, "./isArguments": 139 }], 139: [function(x, C, c) {
      var p = Object.prototype.toString;
      C.exports = function(v) {
        var n = p.call(v), i = n === "[object Arguments]";
        return i || (i = n !== "[object Array]" && v !== null && typeof v == "object" && typeof v.length == "number" && v.length >= 0 && p.call(v.callee) === "[object Function]"), i;
      };
    }, {}], 140: [function(x, C, c) {
      var p = x("es-abstract/2021/CreateDataProperty"), v = x("es-abstract/2021/IsCallable"), n = x("es-abstract/2021/RequireObjectCoercible"), i = x("es-abstract/2021/ToObject"), s = x("call-bind/callBound"), r = x("array.prototype.reduce"), o = Object.getOwnPropertyDescriptor, u = Object.getOwnPropertyNames, a = Object.getOwnPropertySymbols, f = s("Array.prototype.concat"), y = a ? function(h) {
        return f(u(h), a(h));
      } : u, T = v(o) && v(u);
      C.exports = function(h) {
        if (n(h), !T)
          throw new TypeError("getOwnPropertyDescriptors requires Object.getOwnPropertyDescriptor");
        var _ = i(h);
        return r(y(_), function(g, S) {
          var d = o(_, S);
          return d !== void 0 && p(g, S, d), g;
        }, {});
      };
    }, { "array.prototype.reduce": 33, "call-bind/callBound": 48, "es-abstract/2021/CreateDataProperty": 53, "es-abstract/2021/IsCallable": 58, "es-abstract/2021/RequireObjectCoercible": 65, "es-abstract/2021/ToObject": 71 }], 141: [function(x, C, c) {
      var p = x("define-properties"), v = x("call-bind"), n = x("./implementation"), i = x("./polyfill"), s = x("./shim"), r = v(i(), Object);
      p(r, { getPolyfill: i, implementation: n, shim: s }), C.exports = r;
    }, { "./implementation": 140, "./polyfill": 142, "./shim": 143, "call-bind": 49, "define-properties": 50 }], 142: [function(x, C, c) {
      var p = x("./implementation");
      C.exports = function() {
        return typeof Object.getOwnPropertyDescriptors == "function" ? Object.getOwnPropertyDescriptors : p;
      };
    }, { "./implementation": 140 }], 143: [function(x, C, c) {
      var p = x("./polyfill"), v = x("define-properties");
      C.exports = function() {
        var n = p();
        return v(Object, { getOwnPropertyDescriptors: n }, { getOwnPropertyDescriptors: function() {
          return Object.getOwnPropertyDescriptors !== n;
        } }), n;
      };
    }, { "./polyfill": 142, "define-properties": 50 }], 144: [function(x, C, c) {
      (function(p) {
        (function() {
          (function(v) {
            typeof c == "object" && typeof C != "undefined" ? C.exports = v() : (typeof window != "undefined" ? window : typeof p != "undefined" ? p : typeof self != "undefined" ? self : this).Ordu = v();
          })(function() {
            var v, n, i, s = (v = function(W, N) {
              (function(R) {
                (function() {
                  function z(J) {
                    if (J > 2147483647)
                      throw new RangeError('The value "' + J + '" is invalid for option "size"');
                    var st = new Uint8Array(J);
                    return st.__proto__ = et.prototype, st;
                  }
                  function et(J, st, gt) {
                    if (typeof J == "number") {
                      if (typeof st == "string")
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                      return Ct(J);
                    }
                    return ht(J, st, gt);
                  }
                  function ht(J, st, gt) {
                    if (typeof J == "string")
                      return function(Jt, vt) {
                        if (typeof vt == "string" && vt !== "" || (vt = "utf8"), !et.isEncoding(vt))
                          throw new TypeError("Unknown encoding: " + vt);
                        var Me = 0 | Qt(Jt, vt), qe = z(Me), Ke = qe.write(Jt, vt);
                        return Ke !== Me && (qe = qe.slice(0, Ke)), qe;
                      }(J, st);
                    if (ArrayBuffer.isView(J))
                      return Et(J);
                    if (J == null)
                      throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof J);
                    if (en(J, ArrayBuffer) || J && en(J.buffer, ArrayBuffer))
                      return function(Jt, vt, Me) {
                        if (vt < 0 || Jt.byteLength < vt)
                          throw new RangeError('"offset" is outside of buffer bounds');
                        if (Jt.byteLength < vt + (Me || 0))
                          throw new RangeError('"length" is outside of buffer bounds');
                        var qe;
                        return (qe = vt === void 0 && Me === void 0 ? new Uint8Array(Jt) : Me === void 0 ? new Uint8Array(Jt, vt) : new Uint8Array(Jt, vt, Me)).__proto__ = et.prototype, qe;
                      }(J, st, gt);
                    if (typeof J == "number")
                      throw new TypeError('The "value" argument must not be of type number. Received type number');
                    var zt = J.valueOf && J.valueOf();
                    if (zt != null && zt !== J)
                      return et.from(zt, st, gt);
                    var Xt = function(Jt) {
                      if (et.isBuffer(Jt)) {
                        var vt = 0 | Zt(Jt.length), Me = z(vt);
                        return Me.length === 0 || Jt.copy(Me, 0, 0, vt), Me;
                      }
                      return Jt.length !== void 0 ? typeof Jt.length != "number" || cn(Jt.length) ? z(0) : Et(Jt) : Jt.type === "Buffer" && Array.isArray(Jt.data) ? Et(Jt.data) : void 0;
                    }(J);
                    if (Xt)
                      return Xt;
                    if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof J[Symbol.toPrimitive] == "function")
                      return et.from(J[Symbol.toPrimitive]("string"), st, gt);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof J);
                  }
                  function yt(J) {
                    if (typeof J != "number")
                      throw new TypeError('"size" argument must be of type number');
                    if (J < 0)
                      throw new RangeError('The value "' + J + '" is invalid for option "size"');
                  }
                  function Ct(J) {
                    return yt(J), z(J < 0 ? 0 : 0 | Zt(J));
                  }
                  function Et(J) {
                    for (var st = J.length < 0 ? 0 : 0 | Zt(J.length), gt = z(st), zt = 0; zt < st; zt += 1)
                      gt[zt] = 255 & J[zt];
                    return gt;
                  }
                  function Zt(J) {
                    if (J >= 2147483647)
                      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
                    return 0 | J;
                  }
                  function Qt(J, st) {
                    if (et.isBuffer(J))
                      return J.length;
                    if (ArrayBuffer.isView(J) || en(J, ArrayBuffer))
                      return J.byteLength;
                    if (typeof J != "string")
                      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof J);
                    var gt = J.length, zt = arguments.length > 2 && arguments[2] === !0;
                    if (!zt && gt === 0)
                      return 0;
                    for (var Xt = !1; ; )
                      switch (st) {
                        case "ascii":
                        case "latin1":
                        case "binary":
                          return gt;
                        case "utf8":
                        case "utf-8":
                          return Le(J).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                          return 2 * gt;
                        case "hex":
                          return gt >>> 1;
                        case "base64":
                          return Te(J).length;
                        default:
                          if (Xt)
                            return zt ? -1 : Le(J).length;
                          st = ("" + st).toLowerCase(), Xt = !0;
                      }
                  }
                  function Rt(J, st, gt) {
                    var zt = J[st];
                    J[st] = J[gt], J[gt] = zt;
                  }
                  function Lt(J, st, gt, zt, Xt) {
                    if (J.length === 0)
                      return -1;
                    if (typeof gt == "string" ? (zt = gt, gt = 0) : gt > 2147483647 ? gt = 2147483647 : gt < -2147483648 && (gt = -2147483648), cn(gt = +gt) && (gt = Xt ? 0 : J.length - 1), gt < 0 && (gt = J.length + gt), gt >= J.length) {
                      if (Xt)
                        return -1;
                      gt = J.length - 1;
                    } else if (gt < 0) {
                      if (!Xt)
                        return -1;
                      gt = 0;
                    }
                    if (typeof st == "string" && (st = et.from(st, zt)), et.isBuffer(st))
                      return st.length === 0 ? -1 : te(J, st, gt, zt, Xt);
                    if (typeof st == "number")
                      return st &= 255, typeof Uint8Array.prototype.indexOf == "function" ? Xt ? Uint8Array.prototype.indexOf.call(J, st, gt) : Uint8Array.prototype.lastIndexOf.call(J, st, gt) : te(J, [st], gt, zt, Xt);
                    throw new TypeError("val must be string, number or Buffer");
                  }
                  function te(J, st, gt, zt, Xt) {
                    var Jt, vt = 1, Me = J.length, qe = st.length;
                    if (zt !== void 0 && ((zt = String(zt).toLowerCase()) === "ucs2" || zt === "ucs-2" || zt === "utf16le" || zt === "utf-16le")) {
                      if (J.length < 2 || st.length < 2)
                        return -1;
                      vt = 2, Me /= 2, qe /= 2, gt /= 2;
                    }
                    function Ke(pe, bn) {
                      return vt === 1 ? pe[bn] : pe.readUInt16BE(bn * vt);
                    }
                    if (Xt) {
                      var Ae = -1;
                      for (Jt = gt; Jt < Me; Jt++)
                        if (Ke(J, Jt) === Ke(st, Ae === -1 ? 0 : Jt - Ae)) {
                          if (Ae === -1 && (Ae = Jt), Jt - Ae + 1 === qe)
                            return Ae * vt;
                        } else
                          Ae !== -1 && (Jt -= Jt - Ae), Ae = -1;
                    } else
                      for (gt + qe > Me && (gt = Me - qe), Jt = gt; Jt >= 0; Jt--) {
                        for (var le = !0, gn = 0; gn < qe; gn++)
                          if (Ke(J, Jt + gn) !== Ke(st, gn)) {
                            le = !1;
                            break;
                          }
                        if (le)
                          return Jt;
                      }
                    return -1;
                  }
                  function Oe(J, st, gt, zt) {
                    gt = Number(gt) || 0;
                    var Xt = J.length - gt;
                    zt ? (zt = Number(zt)) > Xt && (zt = Xt) : zt = Xt;
                    var Jt = st.length;
                    zt > Jt / 2 && (zt = Jt / 2);
                    for (var vt = 0; vt < zt; ++vt) {
                      var Me = parseInt(st.substr(2 * vt, 2), 16);
                      if (cn(Me))
                        return vt;
                      J[gt + vt] = Me;
                    }
                    return vt;
                  }
                  function ke(J, st, gt, zt) {
                    return Re(Le(st, J.length - gt), J, gt, zt);
                  }
                  function Gt(J, st, gt, zt) {
                    return Re(function(Xt) {
                      for (var Jt = [], vt = 0; vt < Xt.length; ++vt)
                        Jt.push(255 & Xt.charCodeAt(vt));
                      return Jt;
                    }(st), J, gt, zt);
                  }
                  function be(J, st, gt, zt) {
                    return Gt(J, st, gt, zt);
                  }
                  function ve(J, st, gt, zt) {
                    return Re(Te(st), J, gt, zt);
                  }
                  function we(J, st, gt, zt) {
                    return Re(function(Xt, Jt) {
                      for (var vt, Me, qe, Ke = [], Ae = 0; Ae < Xt.length && !((Jt -= 2) < 0); ++Ae)
                        Me = (vt = Xt.charCodeAt(Ae)) >> 8, qe = vt % 256, Ke.push(qe), Ke.push(Me);
                      return Ke;
                    }(st, J.length - gt), J, gt, zt);
                  }
                  function se(J, st, gt) {
                    return st === 0 && gt === J.length ? B.fromByteArray(J) : B.fromByteArray(J.slice(st, gt));
                  }
                  function Ue(J, st, gt) {
                    gt = Math.min(J.length, gt);
                    for (var zt = [], Xt = st; Xt < gt; ) {
                      var Jt, vt, Me, qe, Ke = J[Xt], Ae = null, le = Ke > 239 ? 4 : Ke > 223 ? 3 : Ke > 191 ? 2 : 1;
                      if (Xt + le <= gt)
                        switch (le) {
                          case 1:
                            Ke < 128 && (Ae = Ke);
                            break;
                          case 2:
                            (192 & (Jt = J[Xt + 1])) == 128 && (qe = (31 & Ke) << 6 | 63 & Jt) > 127 && (Ae = qe);
                            break;
                          case 3:
                            Jt = J[Xt + 1], vt = J[Xt + 2], (192 & Jt) == 128 && (192 & vt) == 128 && (qe = (15 & Ke) << 12 | (63 & Jt) << 6 | 63 & vt) > 2047 && (qe < 55296 || qe > 57343) && (Ae = qe);
                            break;
                          case 4:
                            Jt = J[Xt + 1], vt = J[Xt + 2], Me = J[Xt + 3], (192 & Jt) == 128 && (192 & vt) == 128 && (192 & Me) == 128 && (qe = (15 & Ke) << 18 | (63 & Jt) << 12 | (63 & vt) << 6 | 63 & Me) > 65535 && qe < 1114112 && (Ae = qe);
                        }
                      Ae === null ? (Ae = 65533, le = 1) : Ae > 65535 && (Ae -= 65536, zt.push(Ae >>> 10 & 1023 | 55296), Ae = 56320 | 1023 & Ae), zt.push(Ae), Xt += le;
                    }
                    return function(gn) {
                      var pe = gn.length;
                      if (pe <= rn)
                        return String.fromCharCode.apply(String, gn);
                      for (var bn = "", wn = 0; wn < pe; )
                        bn += String.fromCharCode.apply(String, gn.slice(wn, wn += rn));
                      return bn;
                    }(zt);
                  }
                  N.Buffer = et, N.INSPECT_MAX_BYTES = 50, et.TYPED_ARRAY_SUPPORT = function() {
                    try {
                      var J = new Uint8Array(1);
                      return J.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                        return 42;
                      } }, J.foo() === 42;
                    } catch (st) {
                      return !1;
                    }
                  }(), et.TYPED_ARRAY_SUPPORT || typeof console == "undefined" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(et.prototype, "parent", { enumerable: !0, get: function() {
                    if (et.isBuffer(this))
                      return this.buffer;
                  } }), Object.defineProperty(et.prototype, "offset", { enumerable: !0, get: function() {
                    if (et.isBuffer(this))
                      return this.byteOffset;
                  } }), typeof Symbol != "undefined" && Symbol.species != null && et[Symbol.species] === et && Object.defineProperty(et, Symbol.species, { value: null, configurable: !0, enumerable: !1, writable: !1 }), et.poolSize = 8192, et.from = function(J, st, gt) {
                    return ht(J, st, gt);
                  }, et.prototype.__proto__ = Uint8Array.prototype, et.__proto__ = Uint8Array, et.alloc = function(J, st, gt) {
                    return function(zt, Xt, Jt) {
                      return yt(zt), zt <= 0 ? z(zt) : Xt !== void 0 ? typeof Jt == "string" ? z(zt).fill(Xt, Jt) : z(zt).fill(Xt) : z(zt);
                    }(J, st, gt);
                  }, et.allocUnsafe = function(J) {
                    return Ct(J);
                  }, et.allocUnsafeSlow = function(J) {
                    return Ct(J);
                  }, et.isBuffer = function(J) {
                    return J != null && J._isBuffer === !0 && J !== et.prototype;
                  }, et.compare = function(J, st) {
                    if (en(J, Uint8Array) && (J = et.from(J, J.offset, J.byteLength)), en(st, Uint8Array) && (st = et.from(st, st.offset, st.byteLength)), !et.isBuffer(J) || !et.isBuffer(st))
                      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (J === st)
                      return 0;
                    for (var gt = J.length, zt = st.length, Xt = 0, Jt = Math.min(gt, zt); Xt < Jt; ++Xt)
                      if (J[Xt] !== st[Xt]) {
                        gt = J[Xt], zt = st[Xt];
                        break;
                      }
                    return gt < zt ? -1 : zt < gt ? 1 : 0;
                  }, et.isEncoding = function(J) {
                    switch (String(J).toLowerCase()) {
                      case "hex":
                      case "utf8":
                      case "utf-8":
                      case "ascii":
                      case "latin1":
                      case "binary":
                      case "base64":
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return !0;
                      default:
                        return !1;
                    }
                  }, et.concat = function(J, st) {
                    if (!Array.isArray(J))
                      throw new TypeError('"list" argument must be an Array of Buffers');
                    if (J.length === 0)
                      return et.alloc(0);
                    var gt;
                    if (st === void 0)
                      for (st = 0, gt = 0; gt < J.length; ++gt)
                        st += J[gt].length;
                    var zt = et.allocUnsafe(st), Xt = 0;
                    for (gt = 0; gt < J.length; ++gt) {
                      var Jt = J[gt];
                      if (en(Jt, Uint8Array) && (Jt = et.from(Jt)), !et.isBuffer(Jt))
                        throw new TypeError('"list" argument must be an Array of Buffers');
                      Jt.copy(zt, Xt), Xt += Jt.length;
                    }
                    return zt;
                  }, et.byteLength = Qt, et.prototype._isBuffer = !0, et.prototype.swap16 = function() {
                    var J = this.length;
                    if (J % 2 != 0)
                      throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (var st = 0; st < J; st += 2)
                      Rt(this, st, st + 1);
                    return this;
                  }, et.prototype.swap32 = function() {
                    var J = this.length;
                    if (J % 4 != 0)
                      throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (var st = 0; st < J; st += 4)
                      Rt(this, st, st + 3), Rt(this, st + 1, st + 2);
                    return this;
                  }, et.prototype.swap64 = function() {
                    var J = this.length;
                    if (J % 8 != 0)
                      throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for (var st = 0; st < J; st += 8)
                      Rt(this, st, st + 7), Rt(this, st + 1, st + 6), Rt(this, st + 2, st + 5), Rt(this, st + 3, st + 4);
                    return this;
                  }, et.prototype.toString = function() {
                    var J = this.length;
                    return J === 0 ? "" : arguments.length === 0 ? Ue(this, 0, J) : function(st, gt, zt) {
                      var Xt = !1;
                      if ((gt === void 0 || gt < 0) && (gt = 0), gt > this.length || ((zt === void 0 || zt > this.length) && (zt = this.length), zt <= 0) || (zt >>>= 0) <= (gt >>>= 0))
                        return "";
                      for (st || (st = "utf8"); ; )
                        switch (st) {
                          case "hex":
                            return An(this, gt, zt);
                          case "utf8":
                          case "utf-8":
                            return Ue(this, gt, zt);
                          case "ascii":
                            return pn(this, gt, zt);
                          case "latin1":
                          case "binary":
                            return Tn(this, gt, zt);
                          case "base64":
                            return se(this, gt, zt);
                          case "ucs2":
                          case "ucs-2":
                          case "utf16le":
                          case "utf-16le":
                            return vn(this, gt, zt);
                          default:
                            if (Xt)
                              throw new TypeError("Unknown encoding: " + st);
                            st = (st + "").toLowerCase(), Xt = !0;
                        }
                    }.apply(this, arguments);
                  }, et.prototype.toLocaleString = et.prototype.toString, et.prototype.equals = function(J) {
                    if (!et.isBuffer(J))
                      throw new TypeError("Argument must be a Buffer");
                    return this === J || et.compare(this, J) === 0;
                  }, et.prototype.inspect = function() {
                    var J = "", st = N.INSPECT_MAX_BYTES;
                    return J = this.toString("hex", 0, st).replace(/(.{2})/g, "$1 ").trim(), this.length > st && (J += " ... "), "<Buffer " + J + ">";
                  }, et.prototype.compare = function(J, st, gt, zt, Xt) {
                    if (en(J, Uint8Array) && (J = et.from(J, J.offset, J.byteLength)), !et.isBuffer(J))
                      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof J);
                    if (st === void 0 && (st = 0), gt === void 0 && (gt = J ? J.length : 0), zt === void 0 && (zt = 0), Xt === void 0 && (Xt = this.length), st < 0 || gt > J.length || zt < 0 || Xt > this.length)
                      throw new RangeError("out of range index");
                    if (zt >= Xt && st >= gt)
                      return 0;
                    if (zt >= Xt)
                      return -1;
                    if (st >= gt)
                      return 1;
                    if (this === J)
                      return 0;
                    for (var Jt = (Xt >>>= 0) - (zt >>>= 0), vt = (gt >>>= 0) - (st >>>= 0), Me = Math.min(Jt, vt), qe = this.slice(zt, Xt), Ke = J.slice(st, gt), Ae = 0; Ae < Me; ++Ae)
                      if (qe[Ae] !== Ke[Ae]) {
                        Jt = qe[Ae], vt = Ke[Ae];
                        break;
                      }
                    return Jt < vt ? -1 : vt < Jt ? 1 : 0;
                  }, et.prototype.includes = function(J, st, gt) {
                    return this.indexOf(J, st, gt) !== -1;
                  }, et.prototype.indexOf = function(J, st, gt) {
                    return Lt(this, J, st, gt, !0);
                  }, et.prototype.lastIndexOf = function(J, st, gt) {
                    return Lt(this, J, st, gt, !1);
                  }, et.prototype.write = function(J, st, gt, zt) {
                    if (st === void 0)
                      zt = "utf8", gt = this.length, st = 0;
                    else if (gt === void 0 && typeof st == "string")
                      zt = st, gt = this.length, st = 0;
                    else {
                      if (!isFinite(st))
                        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                      st >>>= 0, isFinite(gt) ? (gt >>>= 0, zt === void 0 && (zt = "utf8")) : (zt = gt, gt = void 0);
                    }
                    var Xt = this.length - st;
                    if ((gt === void 0 || gt > Xt) && (gt = Xt), J.length > 0 && (gt < 0 || st < 0) || st > this.length)
                      throw new RangeError("Attempt to write outside buffer bounds");
                    zt || (zt = "utf8");
                    for (var Jt = !1; ; )
                      switch (zt) {
                        case "hex":
                          return Oe(this, J, st, gt);
                        case "utf8":
                        case "utf-8":
                          return ke(this, J, st, gt);
                        case "ascii":
                          return Gt(this, J, st, gt);
                        case "latin1":
                        case "binary":
                          return be(this, J, st, gt);
                        case "base64":
                          return ve(this, J, st, gt);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                          return we(this, J, st, gt);
                        default:
                          if (Jt)
                            throw new TypeError("Unknown encoding: " + zt);
                          zt = ("" + zt).toLowerCase(), Jt = !0;
                      }
                  }, et.prototype.toJSON = function() {
                    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
                  };
                  var rn = 4096;
                  function pn(J, st, gt) {
                    var zt = "";
                    gt = Math.min(J.length, gt);
                    for (var Xt = st; Xt < gt; ++Xt)
                      zt += String.fromCharCode(127 & J[Xt]);
                    return zt;
                  }
                  function Tn(J, st, gt) {
                    var zt = "";
                    gt = Math.min(J.length, gt);
                    for (var Xt = st; Xt < gt; ++Xt)
                      zt += String.fromCharCode(J[Xt]);
                    return zt;
                  }
                  function An(J, st, gt) {
                    var zt, Xt = J.length;
                    (!st || st < 0) && (st = 0), (!gt || gt < 0 || gt > Xt) && (gt = Xt);
                    for (var Jt = "", vt = st; vt < gt; ++vt)
                      Jt += (zt = J[vt]) < 16 ? "0" + zt.toString(16) : zt.toString(16);
                    return Jt;
                  }
                  function vn(J, st, gt) {
                    for (var zt = J.slice(st, gt), Xt = "", Jt = 0; Jt < zt.length; Jt += 2)
                      Xt += String.fromCharCode(zt[Jt] + 256 * zt[Jt + 1]);
                    return Xt;
                  }
                  function ln(J, st, gt) {
                    if (J % 1 != 0 || J < 0)
                      throw new RangeError("offset is not uint");
                    if (J + st > gt)
                      throw new RangeError("Trying to access beyond buffer length");
                  }
                  function Yt(J, st, gt, zt, Xt, Jt) {
                    if (!et.isBuffer(J))
                      throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (st > Xt || st < Jt)
                      throw new RangeError('"value" argument is out of bounds');
                    if (gt + zt > J.length)
                      throw new RangeError("Index out of range");
                  }
                  function oe(J, st, gt, zt, Xt, Jt) {
                    if (gt + zt > J.length)
                      throw new RangeError("Index out of range");
                    if (gt < 0)
                      throw new RangeError("Index out of range");
                  }
                  function ie(J, st, gt, zt, Xt) {
                    return st = +st, gt >>>= 0, Xt || oe(J, 0, gt, 4), ct.write(J, st, gt, zt, 23, 4), gt + 4;
                  }
                  function Ye(J, st, gt, zt, Xt) {
                    return st = +st, gt >>>= 0, Xt || oe(J, 0, gt, 8), ct.write(J, st, gt, zt, 52, 8), gt + 8;
                  }
                  et.prototype.slice = function(J, st) {
                    var gt = this.length;
                    (J = ~~J) < 0 ? (J += gt) < 0 && (J = 0) : J > gt && (J = gt), (st = st === void 0 ? gt : ~~st) < 0 ? (st += gt) < 0 && (st = 0) : st > gt && (st = gt), st < J && (st = J);
                    var zt = this.subarray(J, st);
                    return zt.__proto__ = et.prototype, zt;
                  }, et.prototype.readUIntLE = function(J, st, gt) {
                    J >>>= 0, st >>>= 0, gt || ln(J, st, this.length);
                    for (var zt = this[J], Xt = 1, Jt = 0; ++Jt < st && (Xt *= 256); )
                      zt += this[J + Jt] * Xt;
                    return zt;
                  }, et.prototype.readUIntBE = function(J, st, gt) {
                    J >>>= 0, st >>>= 0, gt || ln(J, st, this.length);
                    for (var zt = this[J + --st], Xt = 1; st > 0 && (Xt *= 256); )
                      zt += this[J + --st] * Xt;
                    return zt;
                  }, et.prototype.readUInt8 = function(J, st) {
                    return J >>>= 0, st || ln(J, 1, this.length), this[J];
                  }, et.prototype.readUInt16LE = function(J, st) {
                    return J >>>= 0, st || ln(J, 2, this.length), this[J] | this[J + 1] << 8;
                  }, et.prototype.readUInt16BE = function(J, st) {
                    return J >>>= 0, st || ln(J, 2, this.length), this[J] << 8 | this[J + 1];
                  }, et.prototype.readUInt32LE = function(J, st) {
                    return J >>>= 0, st || ln(J, 4, this.length), (this[J] | this[J + 1] << 8 | this[J + 2] << 16) + 16777216 * this[J + 3];
                  }, et.prototype.readUInt32BE = function(J, st) {
                    return J >>>= 0, st || ln(J, 4, this.length), 16777216 * this[J] + (this[J + 1] << 16 | this[J + 2] << 8 | this[J + 3]);
                  }, et.prototype.readIntLE = function(J, st, gt) {
                    J >>>= 0, st >>>= 0, gt || ln(J, st, this.length);
                    for (var zt = this[J], Xt = 1, Jt = 0; ++Jt < st && (Xt *= 256); )
                      zt += this[J + Jt] * Xt;
                    return zt >= (Xt *= 128) && (zt -= Math.pow(2, 8 * st)), zt;
                  }, et.prototype.readIntBE = function(J, st, gt) {
                    J >>>= 0, st >>>= 0, gt || ln(J, st, this.length);
                    for (var zt = st, Xt = 1, Jt = this[J + --zt]; zt > 0 && (Xt *= 256); )
                      Jt += this[J + --zt] * Xt;
                    return Jt >= (Xt *= 128) && (Jt -= Math.pow(2, 8 * st)), Jt;
                  }, et.prototype.readInt8 = function(J, st) {
                    return J >>>= 0, st || ln(J, 1, this.length), 128 & this[J] ? -1 * (255 - this[J] + 1) : this[J];
                  }, et.prototype.readInt16LE = function(J, st) {
                    J >>>= 0, st || ln(J, 2, this.length);
                    var gt = this[J] | this[J + 1] << 8;
                    return 32768 & gt ? 4294901760 | gt : gt;
                  }, et.prototype.readInt16BE = function(J, st) {
                    J >>>= 0, st || ln(J, 2, this.length);
                    var gt = this[J + 1] | this[J] << 8;
                    return 32768 & gt ? 4294901760 | gt : gt;
                  }, et.prototype.readInt32LE = function(J, st) {
                    return J >>>= 0, st || ln(J, 4, this.length), this[J] | this[J + 1] << 8 | this[J + 2] << 16 | this[J + 3] << 24;
                  }, et.prototype.readInt32BE = function(J, st) {
                    return J >>>= 0, st || ln(J, 4, this.length), this[J] << 24 | this[J + 1] << 16 | this[J + 2] << 8 | this[J + 3];
                  }, et.prototype.readFloatLE = function(J, st) {
                    return J >>>= 0, st || ln(J, 4, this.length), ct.read(this, J, !0, 23, 4);
                  }, et.prototype.readFloatBE = function(J, st) {
                    return J >>>= 0, st || ln(J, 4, this.length), ct.read(this, J, !1, 23, 4);
                  }, et.prototype.readDoubleLE = function(J, st) {
                    return J >>>= 0, st || ln(J, 8, this.length), ct.read(this, J, !0, 52, 8);
                  }, et.prototype.readDoubleBE = function(J, st) {
                    return J >>>= 0, st || ln(J, 8, this.length), ct.read(this, J, !1, 52, 8);
                  }, et.prototype.writeUIntLE = function(J, st, gt, zt) {
                    J = +J, st >>>= 0, gt >>>= 0, zt || Yt(this, J, st, gt, Math.pow(2, 8 * gt) - 1, 0);
                    var Xt = 1, Jt = 0;
                    for (this[st] = 255 & J; ++Jt < gt && (Xt *= 256); )
                      this[st + Jt] = J / Xt & 255;
                    return st + gt;
                  }, et.prototype.writeUIntBE = function(J, st, gt, zt) {
                    J = +J, st >>>= 0, gt >>>= 0, zt || Yt(this, J, st, gt, Math.pow(2, 8 * gt) - 1, 0);
                    var Xt = gt - 1, Jt = 1;
                    for (this[st + Xt] = 255 & J; --Xt >= 0 && (Jt *= 256); )
                      this[st + Xt] = J / Jt & 255;
                    return st + gt;
                  }, et.prototype.writeUInt8 = function(J, st, gt) {
                    return J = +J, st >>>= 0, gt || Yt(this, J, st, 1, 255, 0), this[st] = 255 & J, st + 1;
                  }, et.prototype.writeUInt16LE = function(J, st, gt) {
                    return J = +J, st >>>= 0, gt || Yt(this, J, st, 2, 65535, 0), this[st] = 255 & J, this[st + 1] = J >>> 8, st + 2;
                  }, et.prototype.writeUInt16BE = function(J, st, gt) {
                    return J = +J, st >>>= 0, gt || Yt(this, J, st, 2, 65535, 0), this[st] = J >>> 8, this[st + 1] = 255 & J, st + 2;
                  }, et.prototype.writeUInt32LE = function(J, st, gt) {
                    return J = +J, st >>>= 0, gt || Yt(this, J, st, 4, 4294967295, 0), this[st + 3] = J >>> 24, this[st + 2] = J >>> 16, this[st + 1] = J >>> 8, this[st] = 255 & J, st + 4;
                  }, et.prototype.writeUInt32BE = function(J, st, gt) {
                    return J = +J, st >>>= 0, gt || Yt(this, J, st, 4, 4294967295, 0), this[st] = J >>> 24, this[st + 1] = J >>> 16, this[st + 2] = J >>> 8, this[st + 3] = 255 & J, st + 4;
                  }, et.prototype.writeIntLE = function(J, st, gt, zt) {
                    if (J = +J, st >>>= 0, !zt) {
                      var Xt = Math.pow(2, 8 * gt - 1);
                      Yt(this, J, st, gt, Xt - 1, -Xt);
                    }
                    var Jt = 0, vt = 1, Me = 0;
                    for (this[st] = 255 & J; ++Jt < gt && (vt *= 256); )
                      J < 0 && Me === 0 && this[st + Jt - 1] !== 0 && (Me = 1), this[st + Jt] = (J / vt >> 0) - Me & 255;
                    return st + gt;
                  }, et.prototype.writeIntBE = function(J, st, gt, zt) {
                    if (J = +J, st >>>= 0, !zt) {
                      var Xt = Math.pow(2, 8 * gt - 1);
                      Yt(this, J, st, gt, Xt - 1, -Xt);
                    }
                    var Jt = gt - 1, vt = 1, Me = 0;
                    for (this[st + Jt] = 255 & J; --Jt >= 0 && (vt *= 256); )
                      J < 0 && Me === 0 && this[st + Jt + 1] !== 0 && (Me = 1), this[st + Jt] = (J / vt >> 0) - Me & 255;
                    return st + gt;
                  }, et.prototype.writeInt8 = function(J, st, gt) {
                    return J = +J, st >>>= 0, gt || Yt(this, J, st, 1, 127, -128), J < 0 && (J = 255 + J + 1), this[st] = 255 & J, st + 1;
                  }, et.prototype.writeInt16LE = function(J, st, gt) {
                    return J = +J, st >>>= 0, gt || Yt(this, J, st, 2, 32767, -32768), this[st] = 255 & J, this[st + 1] = J >>> 8, st + 2;
                  }, et.prototype.writeInt16BE = function(J, st, gt) {
                    return J = +J, st >>>= 0, gt || Yt(this, J, st, 2, 32767, -32768), this[st] = J >>> 8, this[st + 1] = 255 & J, st + 2;
                  }, et.prototype.writeInt32LE = function(J, st, gt) {
                    return J = +J, st >>>= 0, gt || Yt(this, J, st, 4, 2147483647, -2147483648), this[st] = 255 & J, this[st + 1] = J >>> 8, this[st + 2] = J >>> 16, this[st + 3] = J >>> 24, st + 4;
                  }, et.prototype.writeInt32BE = function(J, st, gt) {
                    return J = +J, st >>>= 0, gt || Yt(this, J, st, 4, 2147483647, -2147483648), J < 0 && (J = 4294967295 + J + 1), this[st] = J >>> 24, this[st + 1] = J >>> 16, this[st + 2] = J >>> 8, this[st + 3] = 255 & J, st + 4;
                  }, et.prototype.writeFloatLE = function(J, st, gt) {
                    return ie(this, J, st, !0, gt);
                  }, et.prototype.writeFloatBE = function(J, st, gt) {
                    return ie(this, J, st, !1, gt);
                  }, et.prototype.writeDoubleLE = function(J, st, gt) {
                    return Ye(this, J, st, !0, gt);
                  }, et.prototype.writeDoubleBE = function(J, st, gt) {
                    return Ye(this, J, st, !1, gt);
                  }, et.prototype.copy = function(J, st, gt, zt) {
                    if (!et.isBuffer(J))
                      throw new TypeError("argument should be a Buffer");
                    if (gt || (gt = 0), zt || zt === 0 || (zt = this.length), st >= J.length && (st = J.length), st || (st = 0), zt > 0 && zt < gt && (zt = gt), zt === gt || J.length === 0 || this.length === 0)
                      return 0;
                    if (st < 0)
                      throw new RangeError("targetStart out of bounds");
                    if (gt < 0 || gt >= this.length)
                      throw new RangeError("Index out of range");
                    if (zt < 0)
                      throw new RangeError("sourceEnd out of bounds");
                    zt > this.length && (zt = this.length), J.length - st < zt - gt && (zt = J.length - st + gt);
                    var Xt = zt - gt;
                    if (this === J && typeof Uint8Array.prototype.copyWithin == "function")
                      this.copyWithin(st, gt, zt);
                    else if (this === J && gt < st && st < zt)
                      for (var Jt = Xt - 1; Jt >= 0; --Jt)
                        J[Jt + st] = this[Jt + gt];
                    else
                      Uint8Array.prototype.set.call(J, this.subarray(gt, zt), st);
                    return Xt;
                  }, et.prototype.fill = function(J, st, gt, zt) {
                    if (typeof J == "string") {
                      if (typeof st == "string" ? (zt = st, st = 0, gt = this.length) : typeof gt == "string" && (zt = gt, gt = this.length), zt !== void 0 && typeof zt != "string")
                        throw new TypeError("encoding must be a string");
                      if (typeof zt == "string" && !et.isEncoding(zt))
                        throw new TypeError("Unknown encoding: " + zt);
                      if (J.length === 1) {
                        var Xt = J.charCodeAt(0);
                        (zt === "utf8" && Xt < 128 || zt === "latin1") && (J = Xt);
                      }
                    } else
                      typeof J == "number" && (J &= 255);
                    if (st < 0 || this.length < st || this.length < gt)
                      throw new RangeError("Out of range index");
                    if (gt <= st)
                      return this;
                    var Jt;
                    if (st >>>= 0, gt = gt === void 0 ? this.length : gt >>> 0, J || (J = 0), typeof J == "number")
                      for (Jt = st; Jt < gt; ++Jt)
                        this[Jt] = J;
                    else {
                      var vt = et.isBuffer(J) ? J : et.from(J, zt), Me = vt.length;
                      if (Me === 0)
                        throw new TypeError('The value "' + J + '" is invalid for argument "value"');
                      for (Jt = 0; Jt < gt - st; ++Jt)
                        this[Jt + st] = vt[Jt % Me];
                    }
                    return this;
                  };
                  var We = /[^+/0-9A-Za-z-_]/g;
                  function Le(J, st) {
                    var gt;
                    st = st || 1 / 0;
                    for (var zt = J.length, Xt = null, Jt = [], vt = 0; vt < zt; ++vt) {
                      if ((gt = J.charCodeAt(vt)) > 55295 && gt < 57344) {
                        if (!Xt) {
                          if (gt > 56319) {
                            (st -= 3) > -1 && Jt.push(239, 191, 189);
                            continue;
                          }
                          if (vt + 1 === zt) {
                            (st -= 3) > -1 && Jt.push(239, 191, 189);
                            continue;
                          }
                          Xt = gt;
                          continue;
                        }
                        if (gt < 56320) {
                          (st -= 3) > -1 && Jt.push(239, 191, 189), Xt = gt;
                          continue;
                        }
                        gt = 65536 + (Xt - 55296 << 10 | gt - 56320);
                      } else
                        Xt && (st -= 3) > -1 && Jt.push(239, 191, 189);
                      if (Xt = null, gt < 128) {
                        if ((st -= 1) < 0)
                          break;
                        Jt.push(gt);
                      } else if (gt < 2048) {
                        if ((st -= 2) < 0)
                          break;
                        Jt.push(gt >> 6 | 192, 63 & gt | 128);
                      } else if (gt < 65536) {
                        if ((st -= 3) < 0)
                          break;
                        Jt.push(gt >> 12 | 224, gt >> 6 & 63 | 128, 63 & gt | 128);
                      } else {
                        if (!(gt < 1114112))
                          throw new Error("Invalid code point");
                        if ((st -= 4) < 0)
                          break;
                        Jt.push(gt >> 18 | 240, gt >> 12 & 63 | 128, gt >> 6 & 63 | 128, 63 & gt | 128);
                      }
                    }
                    return Jt;
                  }
                  function Te(J) {
                    return B.toByteArray(function(st) {
                      if ((st = (st = st.split("=")[0]).trim().replace(We, "")).length < 2)
                        return "";
                      for (; st.length % 4 != 0; )
                        st += "=";
                      return st;
                    }(J));
                  }
                  function Re(J, st, gt, zt) {
                    for (var Xt = 0; Xt < zt && !(Xt + gt >= st.length || Xt >= J.length); ++Xt)
                      st[Xt + gt] = J[Xt];
                    return Xt;
                  }
                  function en(J, st) {
                    return J instanceof st || J != null && J.constructor != null && J.constructor.name != null && J.constructor.name === st.name;
                  }
                  function cn(J) {
                    return J != J;
                  }
                }).call(this);
              }).call(this, s({}).Buffer);
            }, function(W) {
              return n || v(n = { exports: {}, parent: W }, n.exports), n.exports;
            }), r = {}, o = typeof Reflect == "object" ? Reflect : null, u = o && typeof o.apply == "function" ? o.apply : function(W, N, R) {
              return Function.prototype.apply.call(W, N, R);
            };
            i = o && typeof o.ownKeys == "function" ? o.ownKeys : Object.getOwnPropertySymbols ? function(W) {
              return Object.getOwnPropertyNames(W).concat(Object.getOwnPropertySymbols(W));
            } : function(W) {
              return Object.getOwnPropertyNames(W);
            };
            var a = Number.isNaN || function(W) {
              return W != W;
            };
            function f() {
              f.init.call(this);
            }
            (r = f).once = function(W, N) {
              return new Promise(function(R, z) {
                function et(yt) {
                  W.removeListener(N, ht), z(yt);
                }
                function ht() {
                  typeof W.removeListener == "function" && W.removeListener("error", et), R([].slice.call(arguments));
                }
                k(W, N, ht, { once: !0 }), N !== "error" && function(yt, Ct, Et) {
                  typeof yt.on == "function" && k(yt, "error", Ct, { once: !0 });
                }(W, et);
              });
            }, f.EventEmitter = f, f.prototype._events = void 0, f.prototype._eventsCount = 0, f.prototype._maxListeners = void 0;
            var y = 10;
            function T(W) {
              if (typeof W != "function")
                throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof W);
            }
            function h(W) {
              return W._maxListeners === void 0 ? f.defaultMaxListeners : W._maxListeners;
            }
            function _(W, N, R, z) {
              var et, ht, yt, Ct;
              if (T(R), (ht = W._events) === void 0 ? (ht = W._events = /* @__PURE__ */ Object.create(null), W._eventsCount = 0) : (ht.newListener !== void 0 && (W.emit("newListener", N, R.listener ? R.listener : R), ht = W._events), yt = ht[N]), yt === void 0)
                yt = ht[N] = R, ++W._eventsCount;
              else if (typeof yt == "function" ? yt = ht[N] = z ? [R, yt] : [yt, R] : z ? yt.unshift(R) : yt.push(R), (et = h(W)) > 0 && yt.length > et && !yt.warned) {
                yt.warned = !0;
                var Et = new Error("Possible EventEmitter memory leak detected. " + yt.length + " " + String(N) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                Et.name = "MaxListenersExceededWarning", Et.emitter = W, Et.type = N, Et.count = yt.length, Ct = Et, console && console.warn && console.warn(Ct);
              }
              return W;
            }
            function g(W, N, R) {
              var z = { fired: !1, wrapFn: void 0, target: W, type: N, listener: R }, et = function() {
                if (!this.fired)
                  return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
              }.bind(z);
              return et.listener = R, z.wrapFn = et, et;
            }
            function S(W, N, R) {
              var z = W._events;
              if (z === void 0)
                return [];
              var et = z[N];
              return et === void 0 ? [] : typeof et == "function" ? R ? [et.listener || et] : [et] : R ? function(ht) {
                for (var yt = new Array(ht.length), Ct = 0; Ct < yt.length; ++Ct)
                  yt[Ct] = ht[Ct].listener || ht[Ct];
                return yt;
              }(et) : b(et, et.length);
            }
            function d(W) {
              var N = this._events;
              if (N !== void 0) {
                var R = N[W];
                if (typeof R == "function")
                  return 1;
                if (R !== void 0)
                  return R.length;
              }
              return 0;
            }
            function b(W, N) {
              for (var R = new Array(N), z = 0; z < N; ++z)
                R[z] = W[z];
              return R;
            }
            function k(W, N, R, z) {
              if (typeof W.on == "function")
                z.once ? W.once(N, R) : W.on(N, R);
              else {
                if (typeof W.addEventListener != "function")
                  throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof W);
                W.addEventListener(N, function et(ht) {
                  z.once && W.removeEventListener(N, et), R(ht);
                });
              }
            }
            Object.defineProperty(f, "defaultMaxListeners", { enumerable: !0, get: function() {
              return y;
            }, set: function(W) {
              if (typeof W != "number" || W < 0 || a(W))
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + W + ".");
              y = W;
            } }), f.init = function() {
              this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
            }, f.prototype.setMaxListeners = function(W) {
              if (typeof W != "number" || W < 0 || a(W))
                throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + W + ".");
              return this._maxListeners = W, this;
            }, f.prototype.getMaxListeners = function() {
              return h(this);
            }, f.prototype.emit = function(W) {
              for (var N = [], R = 1; R < arguments.length; R++)
                N.push(arguments[R]);
              var z = W === "error", et = this._events;
              if (et !== void 0)
                z = z && et.error === void 0;
              else if (!z)
                return !1;
              if (z) {
                var ht;
                if (N.length > 0 && (ht = N[0]), ht instanceof Error)
                  throw ht;
                var yt = new Error("Unhandled error." + (ht ? " (" + ht.message + ")" : ""));
                throw yt.context = ht, yt;
              }
              var Ct = et[W];
              if (Ct === void 0)
                return !1;
              if (typeof Ct == "function")
                u(Ct, this, N);
              else {
                var Et = Ct.length, Zt = b(Ct, Et);
                for (R = 0; R < Et; ++R)
                  u(Zt[R], this, N);
              }
              return !0;
            }, f.prototype.addListener = function(W, N) {
              return _(this, W, N, !1);
            }, f.prototype.on = f.prototype.addListener, f.prototype.prependListener = function(W, N) {
              return _(this, W, N, !0);
            }, f.prototype.once = function(W, N) {
              return T(N), this.on(W, g(this, W, N)), this;
            }, f.prototype.prependOnceListener = function(W, N) {
              return T(N), this.prependListener(W, g(this, W, N)), this;
            }, f.prototype.removeListener = function(W, N) {
              var R, z, et, ht, yt;
              if (T(N), (z = this._events) === void 0)
                return this;
              if ((R = z[W]) === void 0)
                return this;
              if (R === N || R.listener === N)
                --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete z[W], z.removeListener && this.emit("removeListener", W, R.listener || N));
              else if (typeof R != "function") {
                for (et = -1, ht = R.length - 1; ht >= 0; ht--)
                  if (R[ht] === N || R[ht].listener === N) {
                    yt = R[ht].listener, et = ht;
                    break;
                  }
                if (et < 0)
                  return this;
                et === 0 ? R.shift() : function(Ct, Et) {
                  for (; Et + 1 < Ct.length; Et++)
                    Ct[Et] = Ct[Et + 1];
                  Ct.pop();
                }(R, et), R.length === 1 && (z[W] = R[0]), z.removeListener !== void 0 && this.emit("removeListener", W, yt || N);
              }
              return this;
            }, f.prototype.off = f.prototype.removeListener, f.prototype.removeAllListeners = function(W) {
              var N, R, z;
              if ((R = this._events) === void 0)
                return this;
              if (R.removeListener === void 0)
                return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : R[W] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete R[W]), this;
              if (arguments.length === 0) {
                var et, ht = Object.keys(R);
                for (z = 0; z < ht.length; ++z)
                  (et = ht[z]) !== "removeListener" && this.removeAllListeners(et);
                return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
              }
              if (typeof (N = R[W]) == "function")
                this.removeListener(W, N);
              else if (N !== void 0)
                for (z = N.length - 1; z >= 0; z--)
                  this.removeListener(W, N[z]);
              return this;
            }, f.prototype.listeners = function(W) {
              return S(this, W, !0);
            }, f.prototype.rawListeners = function(W) {
              return S(this, W, !1);
            }, f.listenerCount = function(W, N) {
              return typeof W.listenerCount == "function" ? W.listenerCount(N) : d.call(W, N);
            }, f.prototype.listenerCount = d, f.prototype.eventNames = function() {
              return this._eventsCount > 0 ? i(this._events) : [];
            };
            var O = function(...W) {
              try {
                return JSON.stringify.apply(null, W);
              } catch (N) {
                return "[Cannot display object: " + N.message + "]";
              }
            }, A = {};
            A = class extends Error {
              constructor(W) {
                super(W.filter((N) => N !== "").map((N) => typeof N == "string" ? N : N instanceof Error ? N.message : O(N)).join(" ") || "Unknown error"), typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, A.assert);
              }
            };
            var l, E = function(W, ...N) {
              if (!W)
                throw N.length === 1 && N[0] instanceof Error ? N[0] : new A(N);
            };
            const M = {};
            l = function(W, N, R) {
              if (N === !1 || N == null)
                return W;
              typeof (R = R || {}) == "string" && (R = { separator: R });
              const z = Array.isArray(N);
              E(!z || !R.separator, "Separator option no valid for array-based chain");
              const et = z ? N : N.split(R.separator || ".");
              let ht = W;
              for (let yt = 0; yt < et.length; ++yt) {
                let Ct = et[yt];
                const Et = R.iterables && M.iterables(ht);
                if (Array.isArray(ht) || Et === "set") {
                  const Zt = Number(Ct);
                  Number.isInteger(Zt) && (Ct = Zt < 0 ? ht.length + Zt : Zt);
                }
                if (!ht || typeof ht == "function" && R.functions === !1 || !Et && ht[Ct] === void 0) {
                  E(!R.strict || yt + 1 === et.length, "Missing segment", Ct, "in reach path ", N), E(typeof ht == "object" || R.functions === !0 || typeof ht != "function", "Invalid segment", Ct, "in reach path ", N), ht = R.default;
                  break;
                }
                ht = Et ? Et === "set" ? [...ht][Ct] : ht.get(Ct) : ht[Ct];
              }
              return ht;
            }, M.iterables = function(W) {
              return W instanceof Set ? "set" : W instanceof Map ? "map" : void 0;
            };
            for (var B = { toByteArray: function(W) {
              var N, R, z = function(Zt) {
                var Qt = Zt.length;
                if (Qt % 4 > 0)
                  throw new Error("Invalid string. Length must be a multiple of 4");
                var Rt = Zt.indexOf("=");
                return Rt === -1 && (Rt = Qt), [Rt, Rt === Qt ? 0 : 4 - Rt % 4];
              }(W), et = z[0], ht = z[1], yt = new D(3 * (et + ht) / 4 - ht), Ct = 0, Et = ht > 0 ? et - 4 : et;
              for (R = 0; R < Et; R += 4)
                N = K[W.charCodeAt(R)] << 18 | K[W.charCodeAt(R + 1)] << 12 | K[W.charCodeAt(R + 2)] << 6 | K[W.charCodeAt(R + 3)], yt[Ct++] = N >> 16 & 255, yt[Ct++] = N >> 8 & 255, yt[Ct++] = 255 & N;
              return ht === 2 && (N = K[W.charCodeAt(R)] << 2 | K[W.charCodeAt(R + 1)] >> 4, yt[Ct++] = 255 & N), ht === 1 && (N = K[W.charCodeAt(R)] << 10 | K[W.charCodeAt(R + 1)] << 4 | K[W.charCodeAt(R + 2)] >> 2, yt[Ct++] = N >> 8 & 255, yt[Ct++] = 255 & N), yt;
            }, fromByteArray: function(W) {
              for (var N, R = W.length, z = R % 3, et = [], ht = 0, yt = R - z; ht < yt; ht += 16383)
                et.push(nt(W, ht, ht + 16383 > yt ? yt : ht + 16383));
              return z === 1 ? (N = W[R - 1], et.push(X[N >> 2] + X[N << 4 & 63] + "==")) : z === 2 && (N = (W[R - 2] << 8) + W[R - 1], et.push(X[N >> 10] + X[N >> 4 & 63] + X[N << 2 & 63] + "=")), et.join("");
            } }, X = [], K = [], D = typeof Uint8Array != "undefined" ? Uint8Array : Array, j = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Z = 0, tt = j.length; Z < tt; ++Z)
              X[Z] = j[Z], K[j.charCodeAt(Z)] = Z;
            function nt(W, N, R) {
              for (var z, et, ht = [], yt = N; yt < R; yt += 3)
                z = (W[yt] << 16 & 16711680) + (W[yt + 1] << 8 & 65280) + (255 & W[yt + 2]), ht.push(X[(et = z) >> 18 & 63] + X[et >> 12 & 63] + X[et >> 6 & 63] + X[63 & et]);
              return ht.join("");
            }
            K["-".charCodeAt(0)] = 62, K["_".charCodeAt(0)] = 63;
            var ct = { read: function(W, N, R, z, et) {
              var ht, yt, Ct = 8 * et - z - 1, Et = (1 << Ct) - 1, Zt = Et >> 1, Qt = -7, Rt = R ? et - 1 : 0, Lt = R ? -1 : 1, te = W[N + Rt];
              for (Rt += Lt, ht = te & (1 << -Qt) - 1, te >>= -Qt, Qt += Ct; Qt > 0; ht = 256 * ht + W[N + Rt], Rt += Lt, Qt -= 8)
                ;
              for (yt = ht & (1 << -Qt) - 1, ht >>= -Qt, Qt += z; Qt > 0; yt = 256 * yt + W[N + Rt], Rt += Lt, Qt -= 8)
                ;
              if (ht === 0)
                ht = 1 - Zt;
              else {
                if (ht === Et)
                  return yt ? NaN : 1 / 0 * (te ? -1 : 1);
                yt += Math.pow(2, z), ht -= Zt;
              }
              return (te ? -1 : 1) * yt * Math.pow(2, ht - z);
            }, write: function(W, N, R, z, et, ht) {
              var yt, Ct, Et, Zt = 8 * ht - et - 1, Qt = (1 << Zt) - 1, Rt = Qt >> 1, Lt = et === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, te = z ? 0 : ht - 1, Oe = z ? 1 : -1, ke = N < 0 || N === 0 && 1 / N < 0 ? 1 : 0;
              for (N = Math.abs(N), isNaN(N) || N === 1 / 0 ? (Ct = isNaN(N) ? 1 : 0, yt = Qt) : (yt = Math.floor(Math.log(N) / Math.LN2), N * (Et = Math.pow(2, -yt)) < 1 && (yt--, Et *= 2), (N += yt + Rt >= 1 ? Lt / Et : Lt * Math.pow(2, 1 - Rt)) * Et >= 2 && (yt++, Et /= 2), yt + Rt >= Qt ? (Ct = 0, yt = Qt) : yt + Rt >= 1 ? (Ct = (N * Et - 1) * Math.pow(2, et), yt += Rt) : (Ct = N * Math.pow(2, Rt - 1) * Math.pow(2, et), yt = 0)); et >= 8; W[R + te] = 255 & Ct, te += Oe, Ct /= 256, et -= 8)
                ;
              for (yt = yt << et | Ct, Zt += et; Zt > 0; W[R + te] = 255 & yt, te += Oe, yt /= 256, Zt -= 8)
                ;
              W[R + te - Oe] |= 128 * ke;
            } }, ut = {};
            (function(W) {
              (function() {
                const N = {};
                ut = ut = { array: Array.prototype, buffer: W && W.prototype, date: Date.prototype, error: Error.prototype, generic: Object.prototype, map: Map.prototype, promise: Promise.prototype, regex: RegExp.prototype, set: Set.prototype, weakMap: WeakMap.prototype, weakSet: WeakSet.prototype }, N.typeMap = /* @__PURE__ */ new Map([["[object Error]", ut.error], ["[object Map]", ut.map], ["[object Promise]", ut.promise], ["[object Set]", ut.set], ["[object WeakMap]", ut.weakMap], ["[object WeakSet]", ut.weakSet]]), ut.getInternalProto = function(R) {
                  if (Array.isArray(R))
                    return ut.array;
                  if (W && R instanceof W)
                    return ut.buffer;
                  if (R instanceof Date)
                    return ut.date;
                  if (R instanceof RegExp)
                    return ut.regex;
                  if (R instanceof Error)
                    return ut.error;
                  const z = Object.prototype.toString.call(R);
                  return N.typeMap.get(z) || ut.generic;
                };
              }).call(this);
            }).call(this, s({}).Buffer);
            var V = function(W, N = {}) {
              return N.symbols !== !1 ? Reflect.ownKeys(W) : Object.getOwnPropertyNames(W);
            }, ot = {};
            (function(W) {
              (function() {
                const N = { needsProtoHack: /* @__PURE__ */ new Set([ut.set, ut.map, ut.weakSet, ut.weakMap]) };
                ot = N.clone = function(R, z = {}, et = null) {
                  if (typeof R != "object" || R === null)
                    return R;
                  let ht = N.clone, yt = et;
                  if (z.shallow) {
                    if (z.shallow !== !0)
                      return N.cloneWithShallow(R, z);
                    ht = (Qt) => Qt;
                  } else if (yt) {
                    const Qt = yt.get(R);
                    if (Qt)
                      return Qt;
                  } else
                    yt = /* @__PURE__ */ new Map();
                  const Ct = ut.getInternalProto(R);
                  if (Ct === ut.buffer)
                    return W && W.from(R);
                  if (Ct === ut.date)
                    return new Date(R.getTime());
                  if (Ct === ut.regex)
                    return new RegExp(R);
                  const Et = N.base(R, Ct, z);
                  if (Et === R)
                    return R;
                  if (yt && yt.set(R, Et), Ct === ut.set)
                    for (const Qt of R)
                      Et.add(ht(Qt, z, yt));
                  else if (Ct === ut.map)
                    for (const [Qt, Rt] of R)
                      Et.set(Qt, ht(Rt, z, yt));
                  const Zt = V(R, z);
                  for (const Qt of Zt) {
                    if (Qt === "__proto__")
                      continue;
                    if (Ct === ut.array && Qt === "length") {
                      Et.length = R.length;
                      continue;
                    }
                    const Rt = Object.getOwnPropertyDescriptor(R, Qt);
                    Rt ? Rt.get || Rt.set ? Object.defineProperty(Et, Qt, Rt) : Rt.enumerable ? Et[Qt] = ht(R[Qt], z, yt) : Object.defineProperty(Et, Qt, { enumerable: !1, writable: !0, configurable: !0, value: ht(R[Qt], z, yt) }) : Object.defineProperty(Et, Qt, { enumerable: !0, writable: !0, configurable: !0, value: ht(R[Qt], z, yt) });
                  }
                  return Et;
                }, N.cloneWithShallow = function(R, z) {
                  const et = z.shallow;
                  (z = Object.assign({}, z)).shallow = !1;
                  const ht = /* @__PURE__ */ new Map();
                  for (const yt of et) {
                    const Ct = l(R, yt);
                    typeof Ct != "object" && typeof Ct != "function" || ht.set(Ct, Ct);
                  }
                  return N.clone(R, z, ht);
                }, N.base = function(R, z, et) {
                  if (et.prototype === !1)
                    return N.needsProtoHack.has(z) ? new z.constructor() : z === ut.array ? [] : {};
                  const ht = Object.getPrototypeOf(R);
                  if (ht && ht.isImmutable)
                    return R;
                  if (z === ut.array) {
                    const yt = [];
                    return ht !== z && Object.setPrototypeOf(yt, ht), yt;
                  }
                  if (N.needsProtoHack.has(z)) {
                    const yt = new ht.constructor();
                    return ht !== z && Object.setPrototypeOf(yt, ht), yt;
                  }
                  return Object.create(ht);
                };
              }).call(this);
            }).call(this, s({}).Buffer);
            var xt, Ut = {};
            (function(W) {
              (function() {
                const N = {};
                Ut = N.merge = function(R, z, et) {
                  if (E(R && typeof R == "object", "Invalid target value: must be an object"), E(z == null || typeof z == "object", "Invalid source value: must be null, undefined, or an object"), !z)
                    return R;
                  if (et = Object.assign({ nullOverride: !0, mergeArrays: !0 }, et), Array.isArray(z)) {
                    E(Array.isArray(R), "Cannot merge array onto an object"), et.mergeArrays || (R.length = 0);
                    for (let yt = 0; yt < z.length; ++yt)
                      R.push(ot(z[yt], { symbols: et.symbols }));
                    return R;
                  }
                  const ht = V(z, et);
                  for (let yt = 0; yt < ht.length; ++yt) {
                    const Ct = ht[yt];
                    if (Ct === "__proto__" || !Object.prototype.propertyIsEnumerable.call(z, Ct))
                      continue;
                    const Et = z[Ct];
                    if (Et && typeof Et == "object") {
                      if (R[Ct] === Et)
                        continue;
                      !R[Ct] || typeof R[Ct] != "object" || Array.isArray(R[Ct]) !== Array.isArray(Et) || Et instanceof Date || W && W.isBuffer(Et) || Et instanceof RegExp ? R[Ct] = ot(Et, { symbols: et.symbols }) : N.merge(R[Ct], Et, et);
                    } else
                      (Et != null || et.nullOverride) && (R[Ct] = Et);
                  }
                  return R;
                };
              }).call(this);
            }).call(this, s({}).Buffer);
            const pt = {};
            xt = function(W, N, R = {}) {
              if (E(W && typeof W == "object", "Invalid defaults value: must be an object"), E(!N || N === !0 || typeof N == "object", "Invalid source value: must be true, falsy or an object"), E(typeof R == "object", "Invalid options: must be an object"), !N)
                return null;
              if (R.shallow)
                return pt.applyToDefaultsWithShallow(W, N, R);
              const z = ot(W);
              if (N === !0)
                return z;
              const et = R.nullOverride !== void 0 && R.nullOverride;
              return Ut(z, N, { nullOverride: et, mergeArrays: !1 });
            }, pt.applyToDefaultsWithShallow = function(W, N, R) {
              const z = R.shallow;
              E(Array.isArray(z), "Invalid keys");
              const et = /* @__PURE__ */ new Map(), ht = N === !0 ? null : /* @__PURE__ */ new Set();
              for (let Et of z) {
                Et = Array.isArray(Et) ? Et : Et.split(".");
                const Zt = l(W, Et);
                Zt && typeof Zt == "object" ? et.set(Zt, ht && l(N, Et) || Zt) : ht && ht.add(Et);
              }
              const yt = ot(W, {}, et);
              if (!ht)
                return yt;
              for (const Et of ht)
                pt.reachCopy(yt, N, Et);
              const Ct = R.nullOverride !== void 0 && R.nullOverride;
              return Ut(yt, N, { nullOverride: Ct, mergeArrays: !1 });
            }, pt.reachCopy = function(W, N, R) {
              for (const ht of R) {
                if (!(ht in N))
                  return;
                const yt = N[ht];
                if (typeof yt != "object" || yt === null)
                  return;
                N = yt;
              }
              const z = N;
              let et = W;
              for (let ht = 0; ht < R.length - 1; ++ht) {
                const yt = R[ht];
                typeof et[yt] != "object" && (et[yt] = {}), et = et[yt];
              }
              et[R[R.length - 1]] = z;
            };
            var at, bt, Q, At = at = {};
            function Pt() {
              throw new Error("setTimeout has not been defined");
            }
            function q() {
              throw new Error("clearTimeout has not been defined");
            }
            function G(W) {
              if (bt === setTimeout)
                return setTimeout(W, 0);
              if ((bt === Pt || !bt) && setTimeout)
                return bt = setTimeout, setTimeout(W, 0);
              try {
                return bt(W, 0);
              } catch (N) {
                try {
                  return bt.call(null, W, 0);
                } catch (R) {
                  return bt.call(this, W, 0);
                }
              }
            }
            (function() {
              try {
                bt = typeof setTimeout == "function" ? setTimeout : Pt;
              } catch (W) {
                bt = Pt;
              }
              try {
                Q = typeof clearTimeout == "function" ? clearTimeout : q;
              } catch (W) {
                Q = q;
              }
            })();
            var lt, It = [], Ft = !1, H = -1;
            function F() {
              Ft && lt && (Ft = !1, lt.length ? It = lt.concat(It) : H = -1, It.length && P());
            }
            function P() {
              if (!Ft) {
                var W = G(F);
                Ft = !0;
                for (var N = It.length; N; ) {
                  for (lt = It, It = []; ++H < N; )
                    lt && lt[H].run();
                  H = -1, N = It.length;
                }
                lt = null, Ft = !1, function(R) {
                  if (Q === clearTimeout)
                    return clearTimeout(R);
                  if ((Q === q || !Q) && clearTimeout)
                    return Q = clearTimeout, clearTimeout(R);
                  try {
                    Q(R);
                  } catch (z) {
                    try {
                      return Q.call(null, R);
                    } catch (et) {
                      return Q.call(this, R);
                    }
                  }
                }(W);
              }
            }
            function U(W, N) {
              this.fun = W, this.array = N;
            }
            function rt() {
            }
            At.nextTick = function(W) {
              var N = new Array(arguments.length - 1);
              if (arguments.length > 1)
                for (var R = 1; R < arguments.length; R++)
                  N[R - 1] = arguments[R];
              It.push(new U(W, N)), It.length !== 1 || Ft || G(P);
            }, U.prototype.run = function() {
              this.fun.apply(null, this.array);
            }, At.title = "browser", At.browser = !0, At.env = {}, At.argv = [], At.version = "", At.versions = {}, At.on = rt, At.addListener = rt, At.once = rt, At.off = rt, At.removeListener = rt, At.removeAllListeners = rt, At.emit = rt, At.prependListener = rt, At.prependOnceListener = rt, At.listeners = function(W) {
              return [];
            }, At.binding = function(W) {
              throw new Error("process.binding is not supported");
            }, At.cwd = function() {
              return "/";
            }, At.chdir = function(W) {
              throw new Error("process.chdir is not supported");
            }, At.umask = function() {
              return 0;
            };
            var ft = {};
            (function(W) {
              (function() {
                const N = {};
                ft = N.Bench = class {
                  constructor() {
                    this.ts = 0, this.reset();
                  }
                  reset() {
                    this.ts = N.Bench.now();
                  }
                  elapsed() {
                    return N.Bench.now() - this.ts;
                  }
                  static now() {
                    const R = W.hrtime();
                    return 1e3 * R[0] + R[1] / 1e6;
                  }
                };
              }).call(this);
            }).call(this, at);
            var Ot = function() {
            }, Wt = {};
            (function(W) {
              (function() {
                const N = { mismatched: null };
                Wt = function(R, z, et) {
                  return et = Object.assign({ prototype: !0 }, et), !!N.isDeepEqual(R, z, et, []);
                }, N.isDeepEqual = function(R, z, et, ht) {
                  if (R === z)
                    return R !== 0 || 1 / R == 1 / z;
                  const yt = typeof R;
                  if (yt !== typeof z || R === null || z === null)
                    return !1;
                  if (yt === "function") {
                    if (!et.deepFunction || R.toString() !== z.toString())
                      return !1;
                  } else if (yt !== "object")
                    return R != R && z != z;
                  const Ct = N.getSharedType(R, z, !!et.prototype);
                  switch (Ct) {
                    case ut.buffer:
                      return W && W.prototype.equals.call(R, z);
                    case ut.promise:
                      return R === z;
                    case ut.regex:
                      return R.toString() === z.toString();
                    case N.mismatched:
                      return !1;
                  }
                  for (let Et = ht.length - 1; Et >= 0; --Et)
                    if (ht[Et].isSame(R, z))
                      return !0;
                  ht.push(new N.SeenEntry(R, z));
                  try {
                    return !!N.isDeepEqualObj(Ct, R, z, et, ht);
                  } finally {
                    ht.pop();
                  }
                }, N.getSharedType = function(R, z, et) {
                  if (et)
                    return Object.getPrototypeOf(R) !== Object.getPrototypeOf(z) ? N.mismatched : ut.getInternalProto(R);
                  const ht = ut.getInternalProto(R);
                  return ht !== ut.getInternalProto(z) ? N.mismatched : ht;
                }, N.valueOf = function(R) {
                  const z = R.valueOf;
                  if (z === void 0)
                    return R;
                  try {
                    return z.call(R);
                  } catch (et) {
                    return et;
                  }
                }, N.hasOwnEnumerableProperty = function(R, z) {
                  return Object.prototype.propertyIsEnumerable.call(R, z);
                }, N.isSetSimpleEqual = function(R, z) {
                  for (const et of Set.prototype.values.call(R))
                    if (!Set.prototype.has.call(z, et))
                      return !1;
                  return !0;
                }, N.isDeepEqualObj = function(R, z, et, ht, yt) {
                  const { isDeepEqual: Ct, valueOf: Et, hasOwnEnumerableProperty: Zt } = N, { keys: Qt, getOwnPropertySymbols: Rt } = Object;
                  if (R === ut.array) {
                    if (!ht.part) {
                      if (z.length !== et.length)
                        return !1;
                      for (let Gt = 0; Gt < z.length; ++Gt)
                        if (!Ct(z[Gt], et[Gt], ht, yt))
                          return !1;
                      return !0;
                    }
                    for (const Gt of z)
                      for (const be of et)
                        if (Ct(Gt, be, ht, yt))
                          return !0;
                  } else if (R === ut.set) {
                    if (z.size !== et.size)
                      return !1;
                    if (!N.isSetSimpleEqual(z, et)) {
                      const Gt = new Set(Set.prototype.values.call(et));
                      for (const be of Set.prototype.values.call(z)) {
                        if (Gt.delete(be))
                          continue;
                        let ve = !1;
                        for (const we of Gt)
                          if (Ct(be, we, ht, yt)) {
                            Gt.delete(we), ve = !0;
                            break;
                          }
                        if (!ve)
                          return !1;
                      }
                    }
                  } else if (R === ut.map) {
                    if (z.size !== et.size)
                      return !1;
                    for (const [Gt, be] of Map.prototype.entries.call(z))
                      if (be === void 0 && !Map.prototype.has.call(et, Gt) || !Ct(be, Map.prototype.get.call(et, Gt), ht, yt))
                        return !1;
                  } else if (R === ut.error && (z.name !== et.name || z.message !== et.message))
                    return !1;
                  const Lt = Et(z), te = Et(et);
                  if ((z !== Lt || et !== te) && !Ct(Lt, te, ht, yt))
                    return !1;
                  const Oe = Qt(z);
                  if (!ht.part && Oe.length !== Qt(et).length && !ht.skip)
                    return !1;
                  let ke = 0;
                  for (const Gt of Oe)
                    if (ht.skip && ht.skip.includes(Gt))
                      et[Gt] === void 0 && ++ke;
                    else if (!Zt(et, Gt) || !Ct(z[Gt], et[Gt], ht, yt))
                      return !1;
                  if (!ht.part && Oe.length - ke !== Qt(et).length)
                    return !1;
                  if (ht.symbols !== !1) {
                    const Gt = Rt(z), be = new Set(Rt(et));
                    for (const ve of Gt) {
                      if (!ht.skip || !ht.skip.includes(ve)) {
                        if (Zt(z, ve)) {
                          if (!Zt(et, ve) || !Ct(z[ve], et[ve], ht, yt))
                            return !1;
                        } else if (Zt(et, ve))
                          return !1;
                      }
                      be.delete(ve);
                    }
                    for (const ve of be)
                      if (Zt(et, ve))
                        return !1;
                  }
                  return !0;
                }, N.SeenEntry = class {
                  constructor(R, z) {
                    this.obj = R, this.ref = z;
                  }
                  isSame(R, z) {
                    return this.obj === R && this.ref === z;
                  }
                };
              }).call(this);
            }).call(this, s({}).Buffer);
            var ce, ye = function(W) {
              return W.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
            };
            const ge = {};
            var Ce;
            ce = function(W, N, R = {}) {
              return typeof N != "object" && (N = [N]), E(!Array.isArray(N) || N.length, "Values array cannot be empty"), typeof W == "string" ? ge.string(W, N, R) : Array.isArray(W) ? ge.array(W, N, R) : (E(typeof W == "object", "Reference must be string or an object"), ge.object(W, N, R));
            }, ge.array = function(W, N, R) {
              if (Array.isArray(N) || (N = [N]), !W.length || R.only && R.once && W.length !== N.length)
                return !1;
              let z;
              const et = /* @__PURE__ */ new Map();
              for (const yt of N)
                if (R.deep && yt && typeof yt == "object") {
                  z = z || ge.compare(R);
                  let Ct = !1;
                  for (const [Et, Zt] of et.entries())
                    if (z(Et, yt)) {
                      ++Zt.allowed, Ct = !0;
                      break;
                    }
                  Ct || et.set(yt, { allowed: 1, hits: 0 });
                } else {
                  const Ct = et.get(yt);
                  Ct ? ++Ct.allowed : et.set(yt, { allowed: 1, hits: 0 });
                }
              let ht = 0;
              for (const yt of W) {
                let Ct;
                if (R.deep && yt && typeof yt == "object") {
                  z = z || ge.compare(R);
                  for (const [Et, Zt] of et.entries())
                    if (z(Et, yt)) {
                      Ct = Zt;
                      break;
                    }
                } else
                  Ct = et.get(yt);
                if (Ct && (++Ct.hits, ++ht, R.once && Ct.hits > Ct.allowed))
                  return !1;
              }
              if (R.only && ht !== W.length)
                return !1;
              for (const yt of et.values())
                if (yt.hits !== yt.allowed && yt.hits < yt.allowed && !R.part)
                  return !1;
              return !!ht;
            }, ge.object = function(W, N, R) {
              E(R.once === void 0, "Cannot use option once with object");
              const z = V(W, R);
              if (!z.length)
                return !1;
              if (Array.isArray(N))
                return ge.array(z, N, R);
              const et = Object.getOwnPropertySymbols(N).filter((Et) => N.propertyIsEnumerable(Et)), ht = [...Object.keys(N), ...et], yt = ge.compare(R), Ct = new Set(ht);
              for (const Et of z)
                if (Ct.has(Et)) {
                  if (!yt(N[Et], W[Et]))
                    return !1;
                  Ct.delete(Et);
                } else if (R.only)
                  return !1;
              return !Ct.size || !!R.part && Ct.size < ht.length;
            }, ge.string = function(W, N, R) {
              if (W === "")
                return N.length === 1 && N[0] === "" || !R.once && !N.some((Et) => Et !== "");
              const z = /* @__PURE__ */ new Map(), et = [];
              for (const Et of N)
                if (E(typeof Et == "string", "Cannot compare string reference to non-string value"), Et) {
                  const Zt = z.get(Et);
                  Zt ? ++Zt.allowed : (z.set(Et, { allowed: 1, hits: 0 }), et.push(ye(Et)));
                } else if (R.once || R.only)
                  return !1;
              if (!et.length)
                return !0;
              const ht = new RegExp(`(${et.join("|")})`, "g"), yt = W.replace(ht, (Et, Zt) => (++z.get(Zt).hits, ""));
              if (R.only && yt)
                return !1;
              let Ct = !1;
              for (const Et of z.values())
                if (Et.hits && (Ct = !0), Et.hits !== Et.allowed && (Et.hits < Et.allowed && !R.part || R.once))
                  return !1;
              return !!Ct;
            }, ge.compare = function(W) {
              if (!W.deep)
                return ge.shallow;
              const N = W.only !== void 0, R = W.part !== void 0, z = { prototype: N ? W.only : !!R && !W.part, part: N ? !W.only : !!R && W.part };
              return (et, ht) => Wt(et, ht, z);
            }, ge.shallow = function(W, N) {
              return W === N;
            };
            const _e = {};
            Ce = function(W) {
              if (!W)
                return "";
              let N = "";
              for (let R = 0; R < W.length; ++R) {
                const z = W.charCodeAt(R);
                _e.isSafe(z) ? N += W[R] : N += _e.escapeHtmlChar(z);
              }
              return N;
            }, _e.escapeHtmlChar = function(W) {
              const N = _e.namedHtml[W];
              return N !== void 0 ? N : W >= 256 ? "&#" + W + ";" : `&#x${W.toString(16).padStart(2, "0")};`;
            }, _e.isSafe = function(W) {
              return _e.safeCharCodes[W] !== void 0;
            }, _e.namedHtml = { 38: "&amp;", 60: "&lt;", 62: "&gt;", 34: "&quot;", 160: "&nbsp;", 162: "&cent;", 163: "&pound;", 164: "&curren;", 169: "&copy;", 174: "&reg;" }, _e.safeCharCodes = function() {
              const W = {};
              for (let N = 32; N < 123; ++N)
                (N >= 97 || N >= 65 && N <= 90 || N >= 48 && N <= 57 || N === 32 || N === 46 || N === 44 || N === 45 || N === 58 || N === 95) && (W[N] = null);
              return W;
            }();
            const je = {};
            var Ie, $e = je.flatten = function(W, N) {
              const R = N || [];
              for (let z = 0; z < W.length; ++z)
                Array.isArray(W[z]) ? je.flatten(W[z], R) : R.push(W[z]);
              return R;
            };
            const He = {};
            Ie = function(W, N, R = {}) {
              if (!W || !N)
                return R.first ? null : [];
              const z = [], et = Array.isArray(W) ? new Set(W) : W, ht = /* @__PURE__ */ new Set();
              for (const yt of N)
                if (He.has(et, yt) && !ht.has(yt)) {
                  if (R.first)
                    return yt;
                  z.push(yt), ht.add(yt);
                }
              return R.first ? null : z;
            }, He.has = function(W, N) {
              return typeof W.has == "function" ? W.has(N) : W[N] !== void 0;
            };
            var De = {};
            De.applyToDefaults = xt, De.assert = E, De.Bench = ft, De.block = function() {
              return new Promise(Ot);
            }, De.clone = ot, De.contain = ce, De.deepEqual = Wt, De.Error = A, De.escapeHeaderAttribute = function(W) {
              return E(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(W), "Bad attribute value (" + W + ")"), W.replace(/\\/g, "\\\\").replace(/\"/g, '\\"');
            }, De.escapeHtml = Ce, De.escapeJson = function(W) {
              if (!W)
                return "";
              let N;
              return W.replace(/[<>&\u2028\u2029]/g, (R) => (N = R.charCodeAt(0)) === 60 ? "\\u003c" : N === 62 ? "\\u003e" : N === 38 ? "\\u0026" : N === 8232 ? "\\u2028" : "\\u2029");
            }, De.escapeRegex = ye, De.flatten = $e, De.ignore = Ot, De.intersect = Ie, De.isPromise = function(W) {
              return !!W && typeof W.then == "function";
            }, De.merge = Ut, De.once = function(W) {
              if (W._hoekOnce)
                return W;
              let N = !1;
              const R = function(...z) {
                N || (N = !0, W(...z));
              };
              return R._hoekOnce = !0, R;
            }, De.reach = l, De.reachTemplate = function(W, N, R) {
              return N.replace(/{([^{}]+)}/g, (z, et) => {
                const ht = l(W, et, R);
                return ht == null ? "" : ht;
              });
            }, De.stringify = O, De.wait = function(W, N) {
              if (typeof W != "number" && W !== void 0)
                throw new TypeError("Timeout must be a number");
              return new Promise((R) => setTimeout(R, W, N));
            };
            var _t = { exports: {} };
            (function(W) {
              (function() {
                (function(N) {
                  typeof _t.exports == "object" ? _t.exports = N() : (typeof window != "undefined" ? window : W !== void 0 ? W : typeof self != "undefined" ? self : this).Nua = N();
                })(function() {
                  return function(N, R, z) {
                    var et = (z = z || {}).depth || Number.MAX_VALUE, ht = z.setter, yt = !!z.preserve;
                    typeof N == "object" && typeof R == "object" && function Ct(Et, Zt, Qt) {
                      if (!(Et == null || Zt == null || et <= Qt)) {
                        var Rt = Qt + 1;
                        if (Array.isArray(Et) && Array.isArray(Zt)) {
                          for (var Lt = 0; Lt < Et.length; Lt++)
                            typeof Et[Lt] == "object" ? Ct(Et[Lt], Zt[Lt], Rt) : ht ? ht(Et, Lt, Zt[Lt]) : Et[Lt] = Zt[Lt];
                          for (; Lt < Zt.length; Lt++)
                            ht ? ht(Et, Lt, Zt[Lt]) : Et[Lt] = Zt[Lt];
                          Et.splice(Zt.length);
                        } else {
                          for (var te = Object.keys(Et), Oe = 0; Oe < te.length; Oe++) {
                            var ke = Et[te[Oe]], Gt = Zt[te[Oe]];
                            (ke === null ? "null" : typeof ke) == "object" && (Gt === null ? "null" : typeof Gt) == "object" ? Ct(ke, Gt, Rt) : Gt === void 0 ? yt || delete Et[te[Oe]] : ht ? ht(Et, te[Oe], Gt) : Et[te[Oe]] = Gt;
                          }
                          for (var be = Object.keys(Zt), ve = 0; ve < be.length; ve++)
                            Et[be[ve]] === void 0 && (ht ? (ht(Et, be[ve], Zt[be[ve]]), Zt[be[ve]] == null || !Array.isArray(Zt[be[ve]]) && typeof Zt[be[ve]] != "object" || Ct(Et[be[ve]], Zt[be[ve]], Rt)) : Et[be[ve]] = Zt[be[ve]]);
                        }
                      }
                    }(N, R, 0);
                  };
                });
              }).call(this);
            }).call(this, typeof p != "undefined" ? p : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}), _t = _t.exports;
            var jt = {}, mt = this && this.__createBinding || (Object.create ? function(W, N, R, z) {
              z === void 0 && (z = R), Object.defineProperty(W, z, { enumerable: !0, get: function() {
                return N[R];
              } });
            } : function(W, N, R, z) {
              z === void 0 && (z = R), W[z] = N[R];
            }), St = this && this.__setModuleDefault || (Object.create ? function(W, N) {
              Object.defineProperty(W, "default", { enumerable: !0, value: N });
            } : function(W, N) {
              W.default = N;
            }), kt = this && this.__importStar || function(W) {
              if (W && W.__esModule)
                return W;
              var N = {};
              if (W != null)
                for (var R in W)
                  R !== "default" && Object.prototype.hasOwnProperty.call(W, R) && mt(N, W, R);
              return St(N, W), N;
            }, Dt = this && this.__importDefault || function(W) {
              return W && W.__esModule ? W : { default: W };
            };
            Object.defineProperty(jt, "__esModule", { value: !0 }), jt.LegacyOrdu = jt.Task = jt.Ordu = void 0;
            const it = kt(De), qt = Dt(_t);
            class he {
              constructor(N) {
                var R;
                this.runid = N.id == null ? ("" + Math.random()).substring(2) : N.id, this.name = N.name || "task" + he.count++, this.before = N.before, this.after = N.after, this.exec = N.exec || ((z) => {
                }), this.if = N.if || void 0, this.active = N.active == null || N.active, this.meta = Object.assign(N.meta || {}, { when: Date.now(), from: (R = N.meta) === null || R === void 0 ? void 0 : R.from });
              }
            }
            jt.Task = he, he.count = 0;
            class $ {
              constructor(N, R, z, et) {
                this.op = "not-defined", this.task = N, this.name = N.name, this.start = Date.now(), this.end = Number.MAX_SAFE_INTEGER, this.index = R, this.total = z, this.async = !1, this.runid = et;
              }
              update(N) {
                N = N == null ? {} : N, this.out = N.out == null ? {} : N.out, this.err = N instanceof Error ? N : N.err, this.op = this.err != null ? "stop" : typeof N.op == "string" ? N.op : "next", this.why = N.why || "";
              }
            }
            function Vt(W, N) {
              for (var R = 0; R < N.length; ++R)
                if (W.indexOf(N[R]) === -1)
                  return !1;
              return !0;
            }
            return jt.Ordu = class extends r.EventEmitter {
              constructor(W) {
                super(), this.task = {}, this._opts = Ge({ debug: !1 }, W), this._tasks = [], this._operator_map = { next: () => ({ stop: !1 }), skip: () => ({ stop: !1 }), stop: (N, R, z) => ((0, qt.default)(z, N.out, { preserve: !0 }), { stop: !0, err: N.err }), merge: (N, R, z) => ((0, qt.default)(z, N.out, { preserve: !0 }), { stop: !1 }) };
              }
              operator(W, N) {
                let R = typeof W == "string" ? W : W.name;
                this._operator_map[R] = N || W;
              }
              operators() {
                return this._operator_map;
              }
              add(W, N) {
                let R;
                var z;
                if (this._opts.debug && (R = (z = new Error()) == null ? [] : (z.stack || "").split(/\n/).slice(4).map((ht) => ht.substring(4))), typeof W == "function") {
                  let ht = N = N || {};
                  ht.exec = W, ht.name = W.name ? W.name : ht.name, this._add_task(ht, R);
                } else if (Array.isArray(W))
                  for (var et = 0; et < W.length; et++) {
                    let ht = W[et];
                    typeof W[et] == "function" && (ht = { name: W[et].name, exec: W[et] }), this._add_task(ht, R);
                  }
                else
                  this._add_task(W, R);
                return this;
              }
              _add_task(W, N) {
                N && (W.meta = W.meta || {}, W.meta.from = Object.assign(W.meta.from || {}, { callpoint$: N }));
                let R = new he(W), z = 0;
                for (; z < this._tasks.length && (R.before == null || this._tasks[z].name !== R.before); z++)
                  if (R.after != null && this._tasks[z].name === R.after) {
                    z++;
                    break;
                  }
                this._tasks.splice(z, 0, R), this.task[R.name] = R;
              }
              execSync(W, N, R) {
                return this._execImpl(W, N, R);
              }
              exec(W, N, R) {
                return sn(this, null, function* () {
                  return new Promise((z) => {
                    this._execImpl(W, N, R, z);
                  });
                });
              }
              _execImpl(W, N, R, z) {
                const et = this;
                let ht = (R = R == null ? {} : R).runid || (Math.random() + "").substring(2), yt = Date.now(), Ct = [...et._tasks], Et = { ctx: W || {}, data: N || {} }, Zt = [], Qt = 0, Rt = 0, Lt;
                return te(0);
                function te(Gt) {
                  if (Gt >= Ct.length) {
                    let Ue = function() {
                      let rn = Lt ? Lt.err : null, pn = { tasklog: Zt, task: rn ? Ct[Rt] : void 0, taskcount: Qt, tasktotal: Ct.length, start: yt, end: Date.now(), err: rn, data: Et.data };
                      return R.done && R.done(pn), pn;
                    }();
                    return z ? z(Ue) : Ue;
                  }
                  Rt = Gt;
                  let be, ve, we = Ct[Gt], se = new $(we, Gt, Ct.length, ht);
                  if (we.active && et._task_if(we, Et.data))
                    try {
                      Qt++;
                      let Ue = Object.assign({ task: we }, Et);
                      (be = we.exec(Ue)) instanceof Promise ? (se.async = !0, be.then((rn) => ve = rn).catch((rn) => ve = rn).finally(() => Oe(Gt, we, ve, se))) : ve = be;
                    } catch (Ue) {
                      ve = Ue;
                    }
                  else
                    ve = { op: "skip" };
                  if (!se.async)
                    return Oe(Gt, we, ve, se);
                }
                function Oe(Gt, be, ve, we) {
                  we.end = Date.now(), we.update(ve), et.emit("task-result", we);
                  let se = { stop: !1, err: void 0, async: !1 };
                  try {
                    let Ue = et._operate(we, Et.ctx, Et.data);
                    Ue instanceof Promise ? (se.async = !0, Ue.then((rn) => {
                      Object.assign(se, rn);
                    }).catch((rn) => {
                      se.stop = !0, se.err = rn;
                    }).finally(() => {
                      ke(Gt, be, we, se);
                    })) : (se = Ue).async = !1;
                  } catch (Ue) {
                    se.stop = !0, se.err = Ue;
                  }
                  if (!se.async)
                    return ke(Gt, be, we, se);
                }
                function ke(Gt, be, ve, we) {
                  Lt = we;
                  let se = { name: be.name, op: ve.op, task: be, result: ve, operate: we, data: et._opts.debug ? JSON.parse(JSON.stringify(Et.data)) : void 0 };
                  return Zt.push(se), et.emit("task-end", se), we.stop ? Gt = Ct.length : ++Gt, te(Gt);
                }
              }
              tasks() {
                return [...this._tasks];
              }
              _operate(W, N, R) {
                if (W.err)
                  return { stop: !0, err: W.err, async: !1 };
                let z = this._operator_map[W.op];
                return z ? z(W, N, R) : { stop: !0, err: new Error("Unknown operation: " + W.op), async: !1 };
              }
              _task_if(W, N) {
                if (W.if) {
                  let R = W.if;
                  return Object.keys(R).reduce((z, et) => {
                    let ht = it.reach(N, et);
                    return z && it.contain({ $: ht }, { $: R[et] }, { deep: !0 });
                  }, !0);
                }
                return !0;
              }
            }, jt.LegacyOrdu = function(W) {
              var N = {};
              (W = W || {}).name = W.name || "ordu0", N.add = function(z, et) {
                return (et = et || z).name || Object.defineProperty(et, "name", { value: W.name + "_task" + R.length }), et.tags = z.tags || [], R.push(et), N;
              }, N.process = function() {
                var z = arguments.length, et = 0 < z && arguments[--z], ht = 0 < z && arguments[--z], yt = 0 < z && arguments[--z];
                et = et || {}, ht = ht || {}, (yt = yt || {}).tags = yt.tags || [];
                for (var Ct = 0; Ct < R.length; ++Ct) {
                  var Et = R[Ct];
                  if (!(0 < yt.tags.length) || Vt(Et.tags, yt.tags)) {
                    var Zt = Ct, Qt = Et.name;
                    ht.index$ = Zt, ht.taskname$ = Qt;
                    var Rt = Et(ht, et);
                    if (Rt)
                      return Rt.index$ = Zt, Rt.taskname$ = Qt, Rt.ctxt$ = ht, Rt.data$ = et, Rt;
                  }
                }
                return null;
              }, N.tasknames = function() {
                return R.map(function(z) {
                  return z.name;
                });
              }, N.taskdetails = function() {
                return R.map(function(z) {
                  return z.name + ":{tags:" + z.tags + "}";
                });
              }, N.toString = function() {
                return W.name + ":[" + N.tasknames() + "]";
              };
              var R = [];
              return N;
            }, jt;
          });
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 145: [function(x, C, c) {
      var p = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
      function v(s, r) {
        return Object.prototype.hasOwnProperty.call(s, r);
      }
      c.assign = function(s) {
        for (var r = Array.prototype.slice.call(arguments, 1); r.length; ) {
          var o = r.shift();
          if (o) {
            if (typeof o != "object")
              throw new TypeError(o + "must be non-object");
            for (var u in o)
              v(o, u) && (s[u] = o[u]);
          }
        }
        return s;
      }, c.shrinkBuf = function(s, r) {
        return s.length === r ? s : s.subarray ? s.subarray(0, r) : (s.length = r, s);
      };
      var n = { arraySet: function(s, r, o, u, a) {
        if (r.subarray && s.subarray)
          s.set(r.subarray(o, o + u), a);
        else
          for (var f = 0; f < u; f++)
            s[a + f] = r[o + f];
      }, flattenChunks: function(s) {
        var r, o, u, a, f, y;
        for (u = 0, r = 0, o = s.length; r < o; r++)
          u += s[r].length;
        for (y = new Uint8Array(u), a = 0, r = 0, o = s.length; r < o; r++)
          f = s[r], y.set(f, a), a += f.length;
        return y;
      } }, i = { arraySet: function(s, r, o, u, a) {
        for (var f = 0; f < u; f++)
          s[a + f] = r[o + f];
      }, flattenChunks: function(s) {
        return [].concat.apply([], s);
      } };
      c.setTyped = function(s) {
        s ? (c.Buf8 = Uint8Array, c.Buf16 = Uint16Array, c.Buf32 = Int32Array, c.assign(c, n)) : (c.Buf8 = Array, c.Buf16 = Array, c.Buf32 = Array, c.assign(c, i));
      }, c.setTyped(p);
    }, {}], 146: [function(x, C, c) {
      function p(v, n, i, s) {
        for (var r = 65535 & v | 0, o = v >>> 16 & 65535 | 0, u = 0; i !== 0; ) {
          i -= u = i > 2e3 ? 2e3 : i;
          do
            o = o + (r = r + n[s++] | 0) | 0;
          while (--u);
          r %= 65521, o %= 65521;
        }
        return r | o << 16 | 0;
      }
      C.exports = p;
    }, {}], 147: [function(x, C, c) {
      C.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 148: [function(x, C, c) {
      function p() {
        for (var i, s = [], r = 0; r < 256; r++) {
          i = r;
          for (var o = 0; o < 8; o++)
            i = 1 & i ? 3988292384 ^ i >>> 1 : i >>> 1;
          s[r] = i;
        }
        return s;
      }
      var v = p();
      function n(i, s, r, o) {
        var u = v, a = o + r;
        i ^= -1;
        for (var f = o; f < a; f++)
          i = i >>> 8 ^ u[255 & (i ^ s[f])];
        return -1 ^ i;
      }
      C.exports = n;
    }, {}], 149: [function(x, C, c) {
      var p, v = x("../utils/common"), n = x("./trees"), i = x("./adler32"), s = x("./crc32"), r = x("./messages"), o = 0, u = 1, a = 3, f = 4, y = 5, T = 0, h = 1, _ = -2, g = -3, S = -5, d = -1, b = 1, k = 2, O = 3, A = 4, l = 0, E = 2, M = 8, B = 9, X = 15, K = 8, D = 29, j = 256, Z = j + 1 + D, tt = 30, nt = 19, ct = 2 * Z + 1, ut = 15, V = 3, ot = 258, xt = ot + V + 1, Ut = 32, pt = 42, at = 69, bt = 73, Q = 91, At = 103, Pt = 113, q = 666, G = 1, lt = 2, It = 3, Ft = 4, H = 3;
      function F($, Vt) {
        return $.msg = r[Vt], Vt;
      }
      function P($) {
        return ($ << 1) - ($ > 4 ? 9 : 0);
      }
      function U($) {
        for (var Vt = $.length; --Vt >= 0; )
          $[Vt] = 0;
      }
      function rt($) {
        var Vt = $.state, W = Vt.pending;
        W > $.avail_out && (W = $.avail_out), W !== 0 && (v.arraySet($.output, Vt.pending_buf, Vt.pending_out, W, $.next_out), $.next_out += W, Vt.pending_out += W, $.total_out += W, $.avail_out -= W, Vt.pending -= W, Vt.pending === 0 && (Vt.pending_out = 0));
      }
      function ft($, Vt) {
        n._tr_flush_block($, $.block_start >= 0 ? $.block_start : -1, $.strstart - $.block_start, Vt), $.block_start = $.strstart, rt($.strm);
      }
      function Ot($, Vt) {
        $.pending_buf[$.pending++] = Vt;
      }
      function Wt($, Vt) {
        $.pending_buf[$.pending++] = Vt >>> 8 & 255, $.pending_buf[$.pending++] = 255 & Vt;
      }
      function ce($, Vt, W, N) {
        var R = $.avail_in;
        return R > N && (R = N), R === 0 ? 0 : ($.avail_in -= R, v.arraySet(Vt, $.input, $.next_in, R, W), $.state.wrap === 1 ? $.adler = i($.adler, Vt, R, W) : $.state.wrap === 2 && ($.adler = s($.adler, Vt, R, W)), $.next_in += R, $.total_in += R, R);
      }
      function ye($, Vt) {
        var W, N, R = $.max_chain_length, z = $.strstart, et = $.prev_length, ht = $.nice_match, yt = $.strstart > $.w_size - xt ? $.strstart - ($.w_size - xt) : 0, Ct = $.window, Et = $.w_mask, Zt = $.prev, Qt = $.strstart + ot, Rt = Ct[z + et - 1], Lt = Ct[z + et];
        $.prev_length >= $.good_match && (R >>= 2), ht > $.lookahead && (ht = $.lookahead);
        do
          if (Ct[(W = Vt) + et] === Lt && Ct[W + et - 1] === Rt && Ct[W] === Ct[z] && Ct[++W] === Ct[z + 1]) {
            z += 2, W++;
            do
              ;
            while (Ct[++z] === Ct[++W] && Ct[++z] === Ct[++W] && Ct[++z] === Ct[++W] && Ct[++z] === Ct[++W] && Ct[++z] === Ct[++W] && Ct[++z] === Ct[++W] && Ct[++z] === Ct[++W] && Ct[++z] === Ct[++W] && z < Qt);
            if (N = ot - (Qt - z), z = Qt - ot, N > et) {
              if ($.match_start = Vt, et = N, N >= ht)
                break;
              Rt = Ct[z + et - 1], Lt = Ct[z + et];
            }
          }
        while ((Vt = Zt[Vt & Et]) > yt && --R != 0);
        return et <= $.lookahead ? et : $.lookahead;
      }
      function ge($) {
        var Vt, W, N, R, z, et = $.w_size;
        do {
          if (R = $.window_size - $.lookahead - $.strstart, $.strstart >= et + (et - xt)) {
            v.arraySet($.window, $.window, et, et, 0), $.match_start -= et, $.strstart -= et, $.block_start -= et, Vt = W = $.hash_size;
            do
              N = $.head[--Vt], $.head[Vt] = N >= et ? N - et : 0;
            while (--W);
            Vt = W = et;
            do
              N = $.prev[--Vt], $.prev[Vt] = N >= et ? N - et : 0;
            while (--W);
            R += et;
          }
          if ($.strm.avail_in === 0)
            break;
          if (W = ce($.strm, $.window, $.strstart + $.lookahead, R), $.lookahead += W, $.lookahead + $.insert >= V)
            for (z = $.strstart - $.insert, $.ins_h = $.window[z], $.ins_h = ($.ins_h << $.hash_shift ^ $.window[z + 1]) & $.hash_mask; $.insert && ($.ins_h = ($.ins_h << $.hash_shift ^ $.window[z + V - 1]) & $.hash_mask, $.prev[z & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = z, z++, $.insert--, !($.lookahead + $.insert < V)); )
              ;
        } while ($.lookahead < xt && $.strm.avail_in !== 0);
      }
      function Ce($, Vt) {
        var W = 65535;
        for (W > $.pending_buf_size - 5 && (W = $.pending_buf_size - 5); ; ) {
          if ($.lookahead <= 1) {
            if (ge($), $.lookahead === 0 && Vt === o)
              return G;
            if ($.lookahead === 0)
              break;
          }
          $.strstart += $.lookahead, $.lookahead = 0;
          var N = $.block_start + W;
          if (($.strstart === 0 || $.strstart >= N) && ($.lookahead = $.strstart - N, $.strstart = N, ft($, !1), $.strm.avail_out === 0) || $.strstart - $.block_start >= $.w_size - xt && (ft($, !1), $.strm.avail_out === 0))
            return G;
        }
        return $.insert = 0, Vt === f ? (ft($, !0), $.strm.avail_out === 0 ? It : Ft) : ($.strstart > $.block_start && (ft($, !1), $.strm.avail_out), G);
      }
      function _e($, Vt) {
        for (var W, N; ; ) {
          if ($.lookahead < xt) {
            if (ge($), $.lookahead < xt && Vt === o)
              return G;
            if ($.lookahead === 0)
              break;
          }
          if (W = 0, $.lookahead >= V && ($.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + V - 1]) & $.hash_mask, W = $.prev[$.strstart & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = $.strstart), W !== 0 && $.strstart - W <= $.w_size - xt && ($.match_length = ye($, W)), $.match_length >= V)
            if (N = n._tr_tally($, $.strstart - $.match_start, $.match_length - V), $.lookahead -= $.match_length, $.match_length <= $.max_lazy_match && $.lookahead >= V) {
              $.match_length--;
              do
                $.strstart++, $.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + V - 1]) & $.hash_mask, W = $.prev[$.strstart & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = $.strstart;
              while (--$.match_length != 0);
              $.strstart++;
            } else
              $.strstart += $.match_length, $.match_length = 0, $.ins_h = $.window[$.strstart], $.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + 1]) & $.hash_mask;
          else
            N = n._tr_tally($, 0, $.window[$.strstart]), $.lookahead--, $.strstart++;
          if (N && (ft($, !1), $.strm.avail_out === 0))
            return G;
        }
        return $.insert = $.strstart < V - 1 ? $.strstart : V - 1, Vt === f ? (ft($, !0), $.strm.avail_out === 0 ? It : Ft) : $.last_lit && (ft($, !1), $.strm.avail_out === 0) ? G : lt;
      }
      function je($, Vt) {
        for (var W, N, R; ; ) {
          if ($.lookahead < xt) {
            if (ge($), $.lookahead < xt && Vt === o)
              return G;
            if ($.lookahead === 0)
              break;
          }
          if (W = 0, $.lookahead >= V && ($.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + V - 1]) & $.hash_mask, W = $.prev[$.strstart & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = $.strstart), $.prev_length = $.match_length, $.prev_match = $.match_start, $.match_length = V - 1, W !== 0 && $.prev_length < $.max_lazy_match && $.strstart - W <= $.w_size - xt && ($.match_length = ye($, W), $.match_length <= 5 && ($.strategy === b || $.match_length === V && $.strstart - $.match_start > 4096) && ($.match_length = V - 1)), $.prev_length >= V && $.match_length <= $.prev_length) {
            R = $.strstart + $.lookahead - V, N = n._tr_tally($, $.strstart - 1 - $.prev_match, $.prev_length - V), $.lookahead -= $.prev_length - 1, $.prev_length -= 2;
            do
              ++$.strstart <= R && ($.ins_h = ($.ins_h << $.hash_shift ^ $.window[$.strstart + V - 1]) & $.hash_mask, W = $.prev[$.strstart & $.w_mask] = $.head[$.ins_h], $.head[$.ins_h] = $.strstart);
            while (--$.prev_length != 0);
            if ($.match_available = 0, $.match_length = V - 1, $.strstart++, N && (ft($, !1), $.strm.avail_out === 0))
              return G;
          } else if ($.match_available) {
            if ((N = n._tr_tally($, 0, $.window[$.strstart - 1])) && ft($, !1), $.strstart++, $.lookahead--, $.strm.avail_out === 0)
              return G;
          } else
            $.match_available = 1, $.strstart++, $.lookahead--;
        }
        return $.match_available && (N = n._tr_tally($, 0, $.window[$.strstart - 1]), $.match_available = 0), $.insert = $.strstart < V - 1 ? $.strstart : V - 1, Vt === f ? (ft($, !0), $.strm.avail_out === 0 ? It : Ft) : $.last_lit && (ft($, !1), $.strm.avail_out === 0) ? G : lt;
      }
      function Ie($, Vt) {
        for (var W, N, R, z, et = $.window; ; ) {
          if ($.lookahead <= ot) {
            if (ge($), $.lookahead <= ot && Vt === o)
              return G;
            if ($.lookahead === 0)
              break;
          }
          if ($.match_length = 0, $.lookahead >= V && $.strstart > 0 && (N = et[R = $.strstart - 1]) === et[++R] && N === et[++R] && N === et[++R]) {
            z = $.strstart + ot;
            do
              ;
            while (N === et[++R] && N === et[++R] && N === et[++R] && N === et[++R] && N === et[++R] && N === et[++R] && N === et[++R] && N === et[++R] && R < z);
            $.match_length = ot - (z - R), $.match_length > $.lookahead && ($.match_length = $.lookahead);
          }
          if ($.match_length >= V ? (W = n._tr_tally($, 1, $.match_length - V), $.lookahead -= $.match_length, $.strstart += $.match_length, $.match_length = 0) : (W = n._tr_tally($, 0, $.window[$.strstart]), $.lookahead--, $.strstart++), W && (ft($, !1), $.strm.avail_out === 0))
            return G;
        }
        return $.insert = 0, Vt === f ? (ft($, !0), $.strm.avail_out === 0 ? It : Ft) : $.last_lit && (ft($, !1), $.strm.avail_out === 0) ? G : lt;
      }
      function $e($, Vt) {
        for (var W; ; ) {
          if ($.lookahead === 0 && (ge($), $.lookahead === 0)) {
            if (Vt === o)
              return G;
            break;
          }
          if ($.match_length = 0, W = n._tr_tally($, 0, $.window[$.strstart]), $.lookahead--, $.strstart++, W && (ft($, !1), $.strm.avail_out === 0))
            return G;
        }
        return $.insert = 0, Vt === f ? (ft($, !0), $.strm.avail_out === 0 ? It : Ft) : $.last_lit && (ft($, !1), $.strm.avail_out === 0) ? G : lt;
      }
      function He($, Vt, W, N, R) {
        this.good_length = $, this.max_lazy = Vt, this.nice_length = W, this.max_chain = N, this.func = R;
      }
      function De($) {
        $.window_size = 2 * $.w_size, U($.head), $.max_lazy_match = p[$.level].max_lazy, $.good_match = p[$.level].good_length, $.nice_match = p[$.level].nice_length, $.max_chain_length = p[$.level].max_chain, $.strstart = 0, $.block_start = 0, $.lookahead = 0, $.insert = 0, $.match_length = $.prev_length = V - 1, $.match_available = 0, $.ins_h = 0;
      }
      function _t() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = M, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new v.Buf16(2 * ct), this.dyn_dtree = new v.Buf16(2 * (2 * tt + 1)), this.bl_tree = new v.Buf16(2 * (2 * nt + 1)), U(this.dyn_ltree), U(this.dyn_dtree), U(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new v.Buf16(ut + 1), this.heap = new v.Buf16(2 * Z + 1), U(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new v.Buf16(2 * Z + 1), U(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function jt($) {
        var Vt;
        return $ && $.state ? ($.total_in = $.total_out = 0, $.data_type = E, (Vt = $.state).pending = 0, Vt.pending_out = 0, Vt.wrap < 0 && (Vt.wrap = -Vt.wrap), Vt.status = Vt.wrap ? pt : Pt, $.adler = Vt.wrap === 2 ? 0 : 1, Vt.last_flush = o, n._tr_init(Vt), T) : F($, _);
      }
      function mt($) {
        var Vt = jt($);
        return Vt === T && De($.state), Vt;
      }
      function St($, Vt) {
        return $ && $.state ? $.state.wrap !== 2 ? _ : ($.state.gzhead = Vt, T) : _;
      }
      function kt($, Vt, W, N, R, z) {
        if (!$)
          return _;
        var et = 1;
        if (Vt === d && (Vt = 6), N < 0 ? (et = 0, N = -N) : N > 15 && (et = 2, N -= 16), R < 1 || R > B || W !== M || N < 8 || N > 15 || Vt < 0 || Vt > 9 || z < 0 || z > A)
          return F($, _);
        N === 8 && (N = 9);
        var ht = new _t();
        return $.state = ht, ht.strm = $, ht.wrap = et, ht.gzhead = null, ht.w_bits = N, ht.w_size = 1 << ht.w_bits, ht.w_mask = ht.w_size - 1, ht.hash_bits = R + 7, ht.hash_size = 1 << ht.hash_bits, ht.hash_mask = ht.hash_size - 1, ht.hash_shift = ~~((ht.hash_bits + V - 1) / V), ht.window = new v.Buf8(2 * ht.w_size), ht.head = new v.Buf16(ht.hash_size), ht.prev = new v.Buf16(ht.w_size), ht.lit_bufsize = 1 << R + 6, ht.pending_buf_size = 4 * ht.lit_bufsize, ht.pending_buf = new v.Buf8(ht.pending_buf_size), ht.d_buf = 1 * ht.lit_bufsize, ht.l_buf = 3 * ht.lit_bufsize, ht.level = Vt, ht.strategy = z, ht.method = W, mt($);
      }
      function Dt($, Vt) {
        return kt($, Vt, M, X, K, l);
      }
      function it($, Vt) {
        var W, N, R, z;
        if (!$ || !$.state || Vt > y || Vt < 0)
          return $ ? F($, _) : _;
        if (N = $.state, !$.output || !$.input && $.avail_in !== 0 || N.status === q && Vt !== f)
          return F($, $.avail_out === 0 ? S : _);
        if (N.strm = $, W = N.last_flush, N.last_flush = Vt, N.status === pt)
          if (N.wrap === 2)
            $.adler = 0, Ot(N, 31), Ot(N, 139), Ot(N, 8), N.gzhead ? (Ot(N, (N.gzhead.text ? 1 : 0) + (N.gzhead.hcrc ? 2 : 0) + (N.gzhead.extra ? 4 : 0) + (N.gzhead.name ? 8 : 0) + (N.gzhead.comment ? 16 : 0)), Ot(N, 255 & N.gzhead.time), Ot(N, N.gzhead.time >> 8 & 255), Ot(N, N.gzhead.time >> 16 & 255), Ot(N, N.gzhead.time >> 24 & 255), Ot(N, N.level === 9 ? 2 : N.strategy >= k || N.level < 2 ? 4 : 0), Ot(N, 255 & N.gzhead.os), N.gzhead.extra && N.gzhead.extra.length && (Ot(N, 255 & N.gzhead.extra.length), Ot(N, N.gzhead.extra.length >> 8 & 255)), N.gzhead.hcrc && ($.adler = s($.adler, N.pending_buf, N.pending, 0)), N.gzindex = 0, N.status = at) : (Ot(N, 0), Ot(N, 0), Ot(N, 0), Ot(N, 0), Ot(N, 0), Ot(N, N.level === 9 ? 2 : N.strategy >= k || N.level < 2 ? 4 : 0), Ot(N, H), N.status = Pt);
          else {
            var et = M + (N.w_bits - 8 << 4) << 8;
            et |= (N.strategy >= k || N.level < 2 ? 0 : N.level < 6 ? 1 : N.level === 6 ? 2 : 3) << 6, N.strstart !== 0 && (et |= Ut), et += 31 - et % 31, N.status = Pt, Wt(N, et), N.strstart !== 0 && (Wt(N, $.adler >>> 16), Wt(N, 65535 & $.adler)), $.adler = 1;
          }
        if (N.status === at)
          if (N.gzhead.extra) {
            for (R = N.pending; N.gzindex < (65535 & N.gzhead.extra.length) && (N.pending !== N.pending_buf_size || (N.gzhead.hcrc && N.pending > R && ($.adler = s($.adler, N.pending_buf, N.pending - R, R)), rt($), R = N.pending, N.pending !== N.pending_buf_size)); )
              Ot(N, 255 & N.gzhead.extra[N.gzindex]), N.gzindex++;
            N.gzhead.hcrc && N.pending > R && ($.adler = s($.adler, N.pending_buf, N.pending - R, R)), N.gzindex === N.gzhead.extra.length && (N.gzindex = 0, N.status = bt);
          } else
            N.status = bt;
        if (N.status === bt)
          if (N.gzhead.name) {
            R = N.pending;
            do {
              if (N.pending === N.pending_buf_size && (N.gzhead.hcrc && N.pending > R && ($.adler = s($.adler, N.pending_buf, N.pending - R, R)), rt($), R = N.pending, N.pending === N.pending_buf_size)) {
                z = 1;
                break;
              }
              z = N.gzindex < N.gzhead.name.length ? 255 & N.gzhead.name.charCodeAt(N.gzindex++) : 0, Ot(N, z);
            } while (z !== 0);
            N.gzhead.hcrc && N.pending > R && ($.adler = s($.adler, N.pending_buf, N.pending - R, R)), z === 0 && (N.gzindex = 0, N.status = Q);
          } else
            N.status = Q;
        if (N.status === Q)
          if (N.gzhead.comment) {
            R = N.pending;
            do {
              if (N.pending === N.pending_buf_size && (N.gzhead.hcrc && N.pending > R && ($.adler = s($.adler, N.pending_buf, N.pending - R, R)), rt($), R = N.pending, N.pending === N.pending_buf_size)) {
                z = 1;
                break;
              }
              z = N.gzindex < N.gzhead.comment.length ? 255 & N.gzhead.comment.charCodeAt(N.gzindex++) : 0, Ot(N, z);
            } while (z !== 0);
            N.gzhead.hcrc && N.pending > R && ($.adler = s($.adler, N.pending_buf, N.pending - R, R)), z === 0 && (N.status = At);
          } else
            N.status = At;
        if (N.status === At && (N.gzhead.hcrc ? (N.pending + 2 > N.pending_buf_size && rt($), N.pending + 2 <= N.pending_buf_size && (Ot(N, 255 & $.adler), Ot(N, $.adler >> 8 & 255), $.adler = 0, N.status = Pt)) : N.status = Pt), N.pending !== 0) {
          if (rt($), $.avail_out === 0)
            return N.last_flush = -1, T;
        } else if ($.avail_in === 0 && P(Vt) <= P(W) && Vt !== f)
          return F($, S);
        if (N.status === q && $.avail_in !== 0)
          return F($, S);
        if ($.avail_in !== 0 || N.lookahead !== 0 || Vt !== o && N.status !== q) {
          var ht = N.strategy === k ? $e(N, Vt) : N.strategy === O ? Ie(N, Vt) : p[N.level].func(N, Vt);
          if (ht !== It && ht !== Ft || (N.status = q), ht === G || ht === It)
            return $.avail_out === 0 && (N.last_flush = -1), T;
          if (ht === lt && (Vt === u ? n._tr_align(N) : Vt !== y && (n._tr_stored_block(N, 0, 0, !1), Vt === a && (U(N.head), N.lookahead === 0 && (N.strstart = 0, N.block_start = 0, N.insert = 0))), rt($), $.avail_out === 0))
            return N.last_flush = -1, T;
        }
        return Vt !== f ? T : N.wrap <= 0 ? h : (N.wrap === 2 ? (Ot(N, 255 & $.adler), Ot(N, $.adler >> 8 & 255), Ot(N, $.adler >> 16 & 255), Ot(N, $.adler >> 24 & 255), Ot(N, 255 & $.total_in), Ot(N, $.total_in >> 8 & 255), Ot(N, $.total_in >> 16 & 255), Ot(N, $.total_in >> 24 & 255)) : (Wt(N, $.adler >>> 16), Wt(N, 65535 & $.adler)), rt($), N.wrap > 0 && (N.wrap = -N.wrap), N.pending !== 0 ? T : h);
      }
      function qt($) {
        var Vt;
        return $ && $.state ? (Vt = $.state.status) !== pt && Vt !== at && Vt !== bt && Vt !== Q && Vt !== At && Vt !== Pt && Vt !== q ? F($, _) : ($.state = null, Vt === Pt ? F($, g) : T) : _;
      }
      function he($, Vt) {
        var W, N, R, z, et, ht, yt, Ct, Et = Vt.length;
        if (!$ || !$.state || (z = (W = $.state).wrap) === 2 || z === 1 && W.status !== pt || W.lookahead)
          return _;
        for (z === 1 && ($.adler = i($.adler, Vt, Et, 0)), W.wrap = 0, Et >= W.w_size && (z === 0 && (U(W.head), W.strstart = 0, W.block_start = 0, W.insert = 0), Ct = new v.Buf8(W.w_size), v.arraySet(Ct, Vt, Et - W.w_size, W.w_size, 0), Vt = Ct, Et = W.w_size), et = $.avail_in, ht = $.next_in, yt = $.input, $.avail_in = Et, $.next_in = 0, $.input = Vt, ge(W); W.lookahead >= V; ) {
          N = W.strstart, R = W.lookahead - (V - 1);
          do
            W.ins_h = (W.ins_h << W.hash_shift ^ W.window[N + V - 1]) & W.hash_mask, W.prev[N & W.w_mask] = W.head[W.ins_h], W.head[W.ins_h] = N, N++;
          while (--R);
          W.strstart = N, W.lookahead = V - 1, ge(W);
        }
        return W.strstart += W.lookahead, W.block_start = W.strstart, W.insert = W.lookahead, W.lookahead = 0, W.match_length = W.prev_length = V - 1, W.match_available = 0, $.next_in = ht, $.input = yt, $.avail_in = et, W.wrap = z, T;
      }
      p = [new He(0, 0, 0, 0, Ce), new He(4, 4, 8, 4, _e), new He(4, 5, 16, 8, _e), new He(4, 6, 32, 32, _e), new He(4, 4, 16, 16, je), new He(8, 16, 32, 32, je), new He(8, 16, 128, 128, je), new He(8, 32, 128, 256, je), new He(32, 128, 258, 1024, je), new He(32, 258, 258, 4096, je)], c.deflateInit = Dt, c.deflateInit2 = kt, c.deflateReset = mt, c.deflateResetKeep = jt, c.deflateSetHeader = St, c.deflate = it, c.deflateEnd = qt, c.deflateSetDictionary = he, c.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 145, "./adler32": 146, "./crc32": 148, "./messages": 153, "./trees": 154 }], 150: [function(x, C, c) {
      var p = 30, v = 12;
      C.exports = function(n, i) {
        var s, r, o, u, a, f, y, T, h, _, g, S, d, b, k, O, A, l, E, M, B, X, K, D, j;
        s = n.state, r = n.next_in, D = n.input, o = r + (n.avail_in - 5), u = n.next_out, j = n.output, a = u - (i - n.avail_out), f = u + (n.avail_out - 257), y = s.dmax, T = s.wsize, h = s.whave, _ = s.wnext, g = s.window, S = s.hold, d = s.bits, b = s.lencode, k = s.distcode, O = (1 << s.lenbits) - 1, A = (1 << s.distbits) - 1;
        t:
          do {
            d < 15 && (S += D[r++] << d, d += 8, S += D[r++] << d, d += 8), l = b[S & O];
            e:
              for (; ; ) {
                if (S >>>= E = l >>> 24, d -= E, (E = l >>> 16 & 255) === 0)
                  j[u++] = 65535 & l;
                else {
                  if (!(16 & E)) {
                    if (!(64 & E)) {
                      l = b[(65535 & l) + (S & (1 << E) - 1)];
                      continue e;
                    }
                    if (32 & E) {
                      s.mode = v;
                      break t;
                    }
                    n.msg = "invalid literal/length code", s.mode = p;
                    break t;
                  }
                  M = 65535 & l, (E &= 15) && (d < E && (S += D[r++] << d, d += 8), M += S & (1 << E) - 1, S >>>= E, d -= E), d < 15 && (S += D[r++] << d, d += 8, S += D[r++] << d, d += 8), l = k[S & A];
                  n:
                    for (; ; ) {
                      if (S >>>= E = l >>> 24, d -= E, !(16 & (E = l >>> 16 & 255))) {
                        if (!(64 & E)) {
                          l = k[(65535 & l) + (S & (1 << E) - 1)];
                          continue n;
                        }
                        n.msg = "invalid distance code", s.mode = p;
                        break t;
                      }
                      if (B = 65535 & l, d < (E &= 15) && (S += D[r++] << d, (d += 8) < E && (S += D[r++] << d, d += 8)), (B += S & (1 << E) - 1) > y) {
                        n.msg = "invalid distance too far back", s.mode = p;
                        break t;
                      }
                      if (S >>>= E, d -= E, B > (E = u - a)) {
                        if ((E = B - E) > h && s.sane) {
                          n.msg = "invalid distance too far back", s.mode = p;
                          break t;
                        }
                        if (X = 0, K = g, _ === 0) {
                          if (X += T - E, E < M) {
                            M -= E;
                            do
                              j[u++] = g[X++];
                            while (--E);
                            X = u - B, K = j;
                          }
                        } else if (_ < E) {
                          if (X += T + _ - E, (E -= _) < M) {
                            M -= E;
                            do
                              j[u++] = g[X++];
                            while (--E);
                            if (X = 0, _ < M) {
                              M -= E = _;
                              do
                                j[u++] = g[X++];
                              while (--E);
                              X = u - B, K = j;
                            }
                          }
                        } else if (X += _ - E, E < M) {
                          M -= E;
                          do
                            j[u++] = g[X++];
                          while (--E);
                          X = u - B, K = j;
                        }
                        for (; M > 2; )
                          j[u++] = K[X++], j[u++] = K[X++], j[u++] = K[X++], M -= 3;
                        M && (j[u++] = K[X++], M > 1 && (j[u++] = K[X++]));
                      } else {
                        X = u - B;
                        do
                          j[u++] = j[X++], j[u++] = j[X++], j[u++] = j[X++], M -= 3;
                        while (M > 2);
                        M && (j[u++] = j[X++], M > 1 && (j[u++] = j[X++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (r < o && u < f);
        r -= M = d >> 3, S &= (1 << (d -= M << 3)) - 1, n.next_in = r, n.next_out = u, n.avail_in = r < o ? o - r + 5 : 5 - (r - o), n.avail_out = u < f ? f - u + 257 : 257 - (u - f), s.hold = S, s.bits = d;
      };
    }, {}], 151: [function(x, C, c) {
      var p = x("../utils/common"), v = x("./adler32"), n = x("./crc32"), i = x("./inffast"), s = x("./inftrees"), r = 0, o = 1, u = 2, a = 4, f = 5, y = 6, T = 0, h = 1, _ = 2, g = -2, S = -3, d = -4, b = -5, k = 8, O = 1, A = 2, l = 3, E = 4, M = 5, B = 6, X = 7, K = 8, D = 9, j = 10, Z = 11, tt = 12, nt = 13, ct = 14, ut = 15, V = 16, ot = 17, xt = 18, Ut = 19, pt = 20, at = 21, bt = 22, Q = 23, At = 24, Pt = 25, q = 26, G = 27, lt = 28, It = 29, Ft = 30, H = 31, F = 32, P = 852, U = 592, rt = 15, ft = rt;
      function Ot(kt) {
        return (kt >>> 24 & 255) + (kt >>> 8 & 65280) + ((65280 & kt) << 8) + ((255 & kt) << 24);
      }
      function Wt() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new p.Buf16(320), this.work = new p.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function ce(kt) {
        var Dt;
        return kt && kt.state ? (Dt = kt.state, kt.total_in = kt.total_out = Dt.total = 0, kt.msg = "", Dt.wrap && (kt.adler = 1 & Dt.wrap), Dt.mode = O, Dt.last = 0, Dt.havedict = 0, Dt.dmax = 32768, Dt.head = null, Dt.hold = 0, Dt.bits = 0, Dt.lencode = Dt.lendyn = new p.Buf32(P), Dt.distcode = Dt.distdyn = new p.Buf32(U), Dt.sane = 1, Dt.back = -1, T) : g;
      }
      function ye(kt) {
        var Dt;
        return kt && kt.state ? ((Dt = kt.state).wsize = 0, Dt.whave = 0, Dt.wnext = 0, ce(kt)) : g;
      }
      function ge(kt, Dt) {
        var it, qt;
        return kt && kt.state ? (qt = kt.state, Dt < 0 ? (it = 0, Dt = -Dt) : (it = 1 + (Dt >> 4), Dt < 48 && (Dt &= 15)), Dt && (Dt < 8 || Dt > 15) ? g : (qt.window !== null && qt.wbits !== Dt && (qt.window = null), qt.wrap = it, qt.wbits = Dt, ye(kt))) : g;
      }
      function Ce(kt, Dt) {
        var it, qt;
        return kt ? (qt = new Wt(), kt.state = qt, qt.window = null, (it = ge(kt, Dt)) !== T && (kt.state = null), it) : g;
      }
      function _e(kt) {
        return Ce(kt, ft);
      }
      var je, Ie, $e = !0;
      function He(kt) {
        if ($e) {
          var Dt;
          for (je = new p.Buf32(512), Ie = new p.Buf32(32), Dt = 0; Dt < 144; )
            kt.lens[Dt++] = 8;
          for (; Dt < 256; )
            kt.lens[Dt++] = 9;
          for (; Dt < 280; )
            kt.lens[Dt++] = 7;
          for (; Dt < 288; )
            kt.lens[Dt++] = 8;
          for (s(o, kt.lens, 0, 288, je, 0, kt.work, { bits: 9 }), Dt = 0; Dt < 32; )
            kt.lens[Dt++] = 5;
          s(u, kt.lens, 0, 32, Ie, 0, kt.work, { bits: 5 }), $e = !1;
        }
        kt.lencode = je, kt.lenbits = 9, kt.distcode = Ie, kt.distbits = 5;
      }
      function De(kt, Dt, it, qt) {
        var he, $ = kt.state;
        return $.window === null && ($.wsize = 1 << $.wbits, $.wnext = 0, $.whave = 0, $.window = new p.Buf8($.wsize)), qt >= $.wsize ? (p.arraySet($.window, Dt, it - $.wsize, $.wsize, 0), $.wnext = 0, $.whave = $.wsize) : ((he = $.wsize - $.wnext) > qt && (he = qt), p.arraySet($.window, Dt, it - qt, he, $.wnext), (qt -= he) ? (p.arraySet($.window, Dt, it - qt, qt, 0), $.wnext = qt, $.whave = $.wsize) : ($.wnext += he, $.wnext === $.wsize && ($.wnext = 0), $.whave < $.wsize && ($.whave += he))), 0;
      }
      function _t(kt, Dt) {
        var it, qt, he, $, Vt, W, N, R, z, et, ht, yt, Ct, Et, Zt, Qt, Rt, Lt, te, Oe, ke, Gt, be, ve, we = 0, se = new p.Buf8(4), Ue = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!kt || !kt.state || !kt.output || !kt.input && kt.avail_in !== 0)
          return g;
        (it = kt.state).mode === tt && (it.mode = nt), Vt = kt.next_out, he = kt.output, N = kt.avail_out, $ = kt.next_in, qt = kt.input, W = kt.avail_in, R = it.hold, z = it.bits, et = W, ht = N, Gt = T;
        t:
          for (; ; )
            switch (it.mode) {
              case O:
                if (it.wrap === 0) {
                  it.mode = nt;
                  break;
                }
                for (; z < 16; ) {
                  if (W === 0)
                    break t;
                  W--, R += qt[$++] << z, z += 8;
                }
                if (2 & it.wrap && R === 35615) {
                  it.check = 0, se[0] = 255 & R, se[1] = R >>> 8 & 255, it.check = n(it.check, se, 2, 0), R = 0, z = 0, it.mode = A;
                  break;
                }
                if (it.flags = 0, it.head && (it.head.done = !1), !(1 & it.wrap) || (((255 & R) << 8) + (R >> 8)) % 31) {
                  kt.msg = "incorrect header check", it.mode = Ft;
                  break;
                }
                if ((15 & R) !== k) {
                  kt.msg = "unknown compression method", it.mode = Ft;
                  break;
                }
                if (z -= 4, ke = 8 + (15 & (R >>>= 4)), it.wbits === 0)
                  it.wbits = ke;
                else if (ke > it.wbits) {
                  kt.msg = "invalid window size", it.mode = Ft;
                  break;
                }
                it.dmax = 1 << ke, kt.adler = it.check = 1, it.mode = 512 & R ? j : tt, R = 0, z = 0;
                break;
              case A:
                for (; z < 16; ) {
                  if (W === 0)
                    break t;
                  W--, R += qt[$++] << z, z += 8;
                }
                if (it.flags = R, (255 & it.flags) !== k) {
                  kt.msg = "unknown compression method", it.mode = Ft;
                  break;
                }
                if (57344 & it.flags) {
                  kt.msg = "unknown header flags set", it.mode = Ft;
                  break;
                }
                it.head && (it.head.text = R >> 8 & 1), 512 & it.flags && (se[0] = 255 & R, se[1] = R >>> 8 & 255, it.check = n(it.check, se, 2, 0)), R = 0, z = 0, it.mode = l;
              case l:
                for (; z < 32; ) {
                  if (W === 0)
                    break t;
                  W--, R += qt[$++] << z, z += 8;
                }
                it.head && (it.head.time = R), 512 & it.flags && (se[0] = 255 & R, se[1] = R >>> 8 & 255, se[2] = R >>> 16 & 255, se[3] = R >>> 24 & 255, it.check = n(it.check, se, 4, 0)), R = 0, z = 0, it.mode = E;
              case E:
                for (; z < 16; ) {
                  if (W === 0)
                    break t;
                  W--, R += qt[$++] << z, z += 8;
                }
                it.head && (it.head.xflags = 255 & R, it.head.os = R >> 8), 512 & it.flags && (se[0] = 255 & R, se[1] = R >>> 8 & 255, it.check = n(it.check, se, 2, 0)), R = 0, z = 0, it.mode = M;
              case M:
                if (1024 & it.flags) {
                  for (; z < 16; ) {
                    if (W === 0)
                      break t;
                    W--, R += qt[$++] << z, z += 8;
                  }
                  it.length = R, it.head && (it.head.extra_len = R), 512 & it.flags && (se[0] = 255 & R, se[1] = R >>> 8 & 255, it.check = n(it.check, se, 2, 0)), R = 0, z = 0;
                } else
                  it.head && (it.head.extra = null);
                it.mode = B;
              case B:
                if (1024 & it.flags && ((yt = it.length) > W && (yt = W), yt && (it.head && (ke = it.head.extra_len - it.length, it.head.extra || (it.head.extra = new Array(it.head.extra_len)), p.arraySet(it.head.extra, qt, $, yt, ke)), 512 & it.flags && (it.check = n(it.check, qt, yt, $)), W -= yt, $ += yt, it.length -= yt), it.length))
                  break t;
                it.length = 0, it.mode = X;
              case X:
                if (2048 & it.flags) {
                  if (W === 0)
                    break t;
                  yt = 0;
                  do
                    ke = qt[$ + yt++], it.head && ke && it.length < 65536 && (it.head.name += String.fromCharCode(ke));
                  while (ke && yt < W);
                  if (512 & it.flags && (it.check = n(it.check, qt, yt, $)), W -= yt, $ += yt, ke)
                    break t;
                } else
                  it.head && (it.head.name = null);
                it.length = 0, it.mode = K;
              case K:
                if (4096 & it.flags) {
                  if (W === 0)
                    break t;
                  yt = 0;
                  do
                    ke = qt[$ + yt++], it.head && ke && it.length < 65536 && (it.head.comment += String.fromCharCode(ke));
                  while (ke && yt < W);
                  if (512 & it.flags && (it.check = n(it.check, qt, yt, $)), W -= yt, $ += yt, ke)
                    break t;
                } else
                  it.head && (it.head.comment = null);
                it.mode = D;
              case D:
                if (512 & it.flags) {
                  for (; z < 16; ) {
                    if (W === 0)
                      break t;
                    W--, R += qt[$++] << z, z += 8;
                  }
                  if (R !== (65535 & it.check)) {
                    kt.msg = "header crc mismatch", it.mode = Ft;
                    break;
                  }
                  R = 0, z = 0;
                }
                it.head && (it.head.hcrc = it.flags >> 9 & 1, it.head.done = !0), kt.adler = it.check = 0, it.mode = tt;
                break;
              case j:
                for (; z < 32; ) {
                  if (W === 0)
                    break t;
                  W--, R += qt[$++] << z, z += 8;
                }
                kt.adler = it.check = Ot(R), R = 0, z = 0, it.mode = Z;
              case Z:
                if (it.havedict === 0)
                  return kt.next_out = Vt, kt.avail_out = N, kt.next_in = $, kt.avail_in = W, it.hold = R, it.bits = z, _;
                kt.adler = it.check = 1, it.mode = tt;
              case tt:
                if (Dt === f || Dt === y)
                  break t;
              case nt:
                if (it.last) {
                  R >>>= 7 & z, z -= 7 & z, it.mode = G;
                  break;
                }
                for (; z < 3; ) {
                  if (W === 0)
                    break t;
                  W--, R += qt[$++] << z, z += 8;
                }
                switch (it.last = 1 & R, z -= 1, 3 & (R >>>= 1)) {
                  case 0:
                    it.mode = ct;
                    break;
                  case 1:
                    if (He(it), it.mode = pt, Dt === y) {
                      R >>>= 2, z -= 2;
                      break t;
                    }
                    break;
                  case 2:
                    it.mode = ot;
                    break;
                  case 3:
                    kt.msg = "invalid block type", it.mode = Ft;
                }
                R >>>= 2, z -= 2;
                break;
              case ct:
                for (R >>>= 7 & z, z -= 7 & z; z < 32; ) {
                  if (W === 0)
                    break t;
                  W--, R += qt[$++] << z, z += 8;
                }
                if ((65535 & R) != (R >>> 16 ^ 65535)) {
                  kt.msg = "invalid stored block lengths", it.mode = Ft;
                  break;
                }
                if (it.length = 65535 & R, R = 0, z = 0, it.mode = ut, Dt === y)
                  break t;
              case ut:
                it.mode = V;
              case V:
                if (yt = it.length) {
                  if (yt > W && (yt = W), yt > N && (yt = N), yt === 0)
                    break t;
                  p.arraySet(he, qt, $, yt, Vt), W -= yt, $ += yt, N -= yt, Vt += yt, it.length -= yt;
                  break;
                }
                it.mode = tt;
                break;
              case ot:
                for (; z < 14; ) {
                  if (W === 0)
                    break t;
                  W--, R += qt[$++] << z, z += 8;
                }
                if (it.nlen = 257 + (31 & R), R >>>= 5, z -= 5, it.ndist = 1 + (31 & R), R >>>= 5, z -= 5, it.ncode = 4 + (15 & R), R >>>= 4, z -= 4, it.nlen > 286 || it.ndist > 30) {
                  kt.msg = "too many length or distance symbols", it.mode = Ft;
                  break;
                }
                it.have = 0, it.mode = xt;
              case xt:
                for (; it.have < it.ncode; ) {
                  for (; z < 3; ) {
                    if (W === 0)
                      break t;
                    W--, R += qt[$++] << z, z += 8;
                  }
                  it.lens[Ue[it.have++]] = 7 & R, R >>>= 3, z -= 3;
                }
                for (; it.have < 19; )
                  it.lens[Ue[it.have++]] = 0;
                if (it.lencode = it.lendyn, it.lenbits = 7, be = { bits: it.lenbits }, Gt = s(r, it.lens, 0, 19, it.lencode, 0, it.work, be), it.lenbits = be.bits, Gt) {
                  kt.msg = "invalid code lengths set", it.mode = Ft;
                  break;
                }
                it.have = 0, it.mode = Ut;
              case Ut:
                for (; it.have < it.nlen + it.ndist; ) {
                  for (; Qt = (we = it.lencode[R & (1 << it.lenbits) - 1]) >>> 16 & 255, Rt = 65535 & we, !((Zt = we >>> 24) <= z); ) {
                    if (W === 0)
                      break t;
                    W--, R += qt[$++] << z, z += 8;
                  }
                  if (Rt < 16)
                    R >>>= Zt, z -= Zt, it.lens[it.have++] = Rt;
                  else {
                    if (Rt === 16) {
                      for (ve = Zt + 2; z < ve; ) {
                        if (W === 0)
                          break t;
                        W--, R += qt[$++] << z, z += 8;
                      }
                      if (R >>>= Zt, z -= Zt, it.have === 0) {
                        kt.msg = "invalid bit length repeat", it.mode = Ft;
                        break;
                      }
                      ke = it.lens[it.have - 1], yt = 3 + (3 & R), R >>>= 2, z -= 2;
                    } else if (Rt === 17) {
                      for (ve = Zt + 3; z < ve; ) {
                        if (W === 0)
                          break t;
                        W--, R += qt[$++] << z, z += 8;
                      }
                      z -= Zt, ke = 0, yt = 3 + (7 & (R >>>= Zt)), R >>>= 3, z -= 3;
                    } else {
                      for (ve = Zt + 7; z < ve; ) {
                        if (W === 0)
                          break t;
                        W--, R += qt[$++] << z, z += 8;
                      }
                      z -= Zt, ke = 0, yt = 11 + (127 & (R >>>= Zt)), R >>>= 7, z -= 7;
                    }
                    if (it.have + yt > it.nlen + it.ndist) {
                      kt.msg = "invalid bit length repeat", it.mode = Ft;
                      break;
                    }
                    for (; yt--; )
                      it.lens[it.have++] = ke;
                  }
                }
                if (it.mode === Ft)
                  break;
                if (it.lens[256] === 0) {
                  kt.msg = "invalid code -- missing end-of-block", it.mode = Ft;
                  break;
                }
                if (it.lenbits = 9, be = { bits: it.lenbits }, Gt = s(o, it.lens, 0, it.nlen, it.lencode, 0, it.work, be), it.lenbits = be.bits, Gt) {
                  kt.msg = "invalid literal/lengths set", it.mode = Ft;
                  break;
                }
                if (it.distbits = 6, it.distcode = it.distdyn, be = { bits: it.distbits }, Gt = s(u, it.lens, it.nlen, it.ndist, it.distcode, 0, it.work, be), it.distbits = be.bits, Gt) {
                  kt.msg = "invalid distances set", it.mode = Ft;
                  break;
                }
                if (it.mode = pt, Dt === y)
                  break t;
              case pt:
                it.mode = at;
              case at:
                if (W >= 6 && N >= 258) {
                  kt.next_out = Vt, kt.avail_out = N, kt.next_in = $, kt.avail_in = W, it.hold = R, it.bits = z, i(kt, ht), Vt = kt.next_out, he = kt.output, N = kt.avail_out, $ = kt.next_in, qt = kt.input, W = kt.avail_in, R = it.hold, z = it.bits, it.mode === tt && (it.back = -1);
                  break;
                }
                for (it.back = 0; Qt = (we = it.lencode[R & (1 << it.lenbits) - 1]) >>> 16 & 255, Rt = 65535 & we, !((Zt = we >>> 24) <= z); ) {
                  if (W === 0)
                    break t;
                  W--, R += qt[$++] << z, z += 8;
                }
                if (Qt && !(240 & Qt)) {
                  for (Lt = Zt, te = Qt, Oe = Rt; Qt = (we = it.lencode[Oe + ((R & (1 << Lt + te) - 1) >> Lt)]) >>> 16 & 255, Rt = 65535 & we, !(Lt + (Zt = we >>> 24) <= z); ) {
                    if (W === 0)
                      break t;
                    W--, R += qt[$++] << z, z += 8;
                  }
                  R >>>= Lt, z -= Lt, it.back += Lt;
                }
                if (R >>>= Zt, z -= Zt, it.back += Zt, it.length = Rt, Qt === 0) {
                  it.mode = q;
                  break;
                }
                if (32 & Qt) {
                  it.back = -1, it.mode = tt;
                  break;
                }
                if (64 & Qt) {
                  kt.msg = "invalid literal/length code", it.mode = Ft;
                  break;
                }
                it.extra = 15 & Qt, it.mode = bt;
              case bt:
                if (it.extra) {
                  for (ve = it.extra; z < ve; ) {
                    if (W === 0)
                      break t;
                    W--, R += qt[$++] << z, z += 8;
                  }
                  it.length += R & (1 << it.extra) - 1, R >>>= it.extra, z -= it.extra, it.back += it.extra;
                }
                it.was = it.length, it.mode = Q;
              case Q:
                for (; Qt = (we = it.distcode[R & (1 << it.distbits) - 1]) >>> 16 & 255, Rt = 65535 & we, !((Zt = we >>> 24) <= z); ) {
                  if (W === 0)
                    break t;
                  W--, R += qt[$++] << z, z += 8;
                }
                if (!(240 & Qt)) {
                  for (Lt = Zt, te = Qt, Oe = Rt; Qt = (we = it.distcode[Oe + ((R & (1 << Lt + te) - 1) >> Lt)]) >>> 16 & 255, Rt = 65535 & we, !(Lt + (Zt = we >>> 24) <= z); ) {
                    if (W === 0)
                      break t;
                    W--, R += qt[$++] << z, z += 8;
                  }
                  R >>>= Lt, z -= Lt, it.back += Lt;
                }
                if (R >>>= Zt, z -= Zt, it.back += Zt, 64 & Qt) {
                  kt.msg = "invalid distance code", it.mode = Ft;
                  break;
                }
                it.offset = Rt, it.extra = 15 & Qt, it.mode = At;
              case At:
                if (it.extra) {
                  for (ve = it.extra; z < ve; ) {
                    if (W === 0)
                      break t;
                    W--, R += qt[$++] << z, z += 8;
                  }
                  it.offset += R & (1 << it.extra) - 1, R >>>= it.extra, z -= it.extra, it.back += it.extra;
                }
                if (it.offset > it.dmax) {
                  kt.msg = "invalid distance too far back", it.mode = Ft;
                  break;
                }
                it.mode = Pt;
              case Pt:
                if (N === 0)
                  break t;
                if (yt = ht - N, it.offset > yt) {
                  if ((yt = it.offset - yt) > it.whave && it.sane) {
                    kt.msg = "invalid distance too far back", it.mode = Ft;
                    break;
                  }
                  yt > it.wnext ? (yt -= it.wnext, Ct = it.wsize - yt) : Ct = it.wnext - yt, yt > it.length && (yt = it.length), Et = it.window;
                } else
                  Et = he, Ct = Vt - it.offset, yt = it.length;
                yt > N && (yt = N), N -= yt, it.length -= yt;
                do
                  he[Vt++] = Et[Ct++];
                while (--yt);
                it.length === 0 && (it.mode = at);
                break;
              case q:
                if (N === 0)
                  break t;
                he[Vt++] = it.length, N--, it.mode = at;
                break;
              case G:
                if (it.wrap) {
                  for (; z < 32; ) {
                    if (W === 0)
                      break t;
                    W--, R |= qt[$++] << z, z += 8;
                  }
                  if (ht -= N, kt.total_out += ht, it.total += ht, ht && (kt.adler = it.check = it.flags ? n(it.check, he, ht, Vt - ht) : v(it.check, he, ht, Vt - ht)), ht = N, (it.flags ? R : Ot(R)) !== it.check) {
                    kt.msg = "incorrect data check", it.mode = Ft;
                    break;
                  }
                  R = 0, z = 0;
                }
                it.mode = lt;
              case lt:
                if (it.wrap && it.flags) {
                  for (; z < 32; ) {
                    if (W === 0)
                      break t;
                    W--, R += qt[$++] << z, z += 8;
                  }
                  if (R !== (4294967295 & it.total)) {
                    kt.msg = "incorrect length check", it.mode = Ft;
                    break;
                  }
                  R = 0, z = 0;
                }
                it.mode = It;
              case It:
                Gt = h;
                break t;
              case Ft:
                Gt = S;
                break t;
              case H:
                return d;
              case F:
              default:
                return g;
            }
        return kt.next_out = Vt, kt.avail_out = N, kt.next_in = $, kt.avail_in = W, it.hold = R, it.bits = z, (it.wsize || ht !== kt.avail_out && it.mode < Ft && (it.mode < G || Dt !== a)) && De(kt, kt.output, kt.next_out, ht - kt.avail_out) ? (it.mode = H, d) : (et -= kt.avail_in, ht -= kt.avail_out, kt.total_in += et, kt.total_out += ht, it.total += ht, it.wrap && ht && (kt.adler = it.check = it.flags ? n(it.check, he, ht, kt.next_out - ht) : v(it.check, he, ht, kt.next_out - ht)), kt.data_type = it.bits + (it.last ? 64 : 0) + (it.mode === tt ? 128 : 0) + (it.mode === pt || it.mode === ut ? 256 : 0), (et === 0 && ht === 0 || Dt === a) && Gt === T && (Gt = b), Gt);
      }
      function jt(kt) {
        if (!kt || !kt.state)
          return g;
        var Dt = kt.state;
        return Dt.window && (Dt.window = null), kt.state = null, T;
      }
      function mt(kt, Dt) {
        var it;
        return kt && kt.state && 2 & (it = kt.state).wrap ? (it.head = Dt, Dt.done = !1, T) : g;
      }
      function St(kt, Dt) {
        var it, qt = Dt.length;
        return kt && kt.state ? (it = kt.state).wrap !== 0 && it.mode !== Z ? g : it.mode === Z && v(1, Dt, qt, 0) !== it.check ? S : De(kt, Dt, qt, qt) ? (it.mode = H, d) : (it.havedict = 1, T) : g;
      }
      c.inflateReset = ye, c.inflateReset2 = ge, c.inflateResetKeep = ce, c.inflateInit = _e, c.inflateInit2 = Ce, c.inflate = _t, c.inflateEnd = jt, c.inflateGetHeader = mt, c.inflateSetDictionary = St, c.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 145, "./adler32": 146, "./crc32": 148, "./inffast": 150, "./inftrees": 152 }], 152: [function(x, C, c) {
      var p = x("../utils/common"), v = 15, n = 852, i = 592, s = 0, r = 1, o = 2, u = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], f = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], y = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      C.exports = function(T, h, _, g, S, d, b, k) {
        var O, A, l, E, M, B, X, K, D, j = k.bits, Z = 0, tt = 0, nt = 0, ct = 0, ut = 0, V = 0, ot = 0, xt = 0, Ut = 0, pt = 0, at = null, bt = 0, Q = new p.Buf16(v + 1), At = new p.Buf16(v + 1), Pt = null, q = 0;
        for (Z = 0; Z <= v; Z++)
          Q[Z] = 0;
        for (tt = 0; tt < g; tt++)
          Q[h[_ + tt]]++;
        for (ut = j, ct = v; ct >= 1 && Q[ct] === 0; ct--)
          ;
        if (ut > ct && (ut = ct), ct === 0)
          return S[d++] = 20971520, S[d++] = 20971520, k.bits = 1, 0;
        for (nt = 1; nt < ct && Q[nt] === 0; nt++)
          ;
        for (ut < nt && (ut = nt), xt = 1, Z = 1; Z <= v; Z++)
          if (xt <<= 1, (xt -= Q[Z]) < 0)
            return -1;
        if (xt > 0 && (T === s || ct !== 1))
          return -1;
        for (At[1] = 0, Z = 1; Z < v; Z++)
          At[Z + 1] = At[Z] + Q[Z];
        for (tt = 0; tt < g; tt++)
          h[_ + tt] !== 0 && (b[At[h[_ + tt]]++] = tt);
        if (T === s ? (at = Pt = b, B = 19) : T === r ? (at = u, bt -= 257, Pt = a, q -= 257, B = 256) : (at = f, Pt = y, B = -1), pt = 0, tt = 0, Z = nt, M = d, V = ut, ot = 0, l = -1, E = (Ut = 1 << ut) - 1, T === r && Ut > n || T === o && Ut > i)
          return 1;
        for (; ; ) {
          X = Z - ot, b[tt] < B ? (K = 0, D = b[tt]) : b[tt] > B ? (K = Pt[q + b[tt]], D = at[bt + b[tt]]) : (K = 96, D = 0), O = 1 << Z - ot, nt = A = 1 << V;
          do
            S[M + (pt >> ot) + (A -= O)] = X << 24 | K << 16 | D | 0;
          while (A !== 0);
          for (O = 1 << Z - 1; pt & O; )
            O >>= 1;
          if (O !== 0 ? (pt &= O - 1, pt += O) : pt = 0, tt++, --Q[Z] == 0) {
            if (Z === ct)
              break;
            Z = h[_ + b[tt]];
          }
          if (Z > ut && (pt & E) !== l) {
            for (ot === 0 && (ot = ut), M += nt, xt = 1 << (V = Z - ot); V + ot < ct && !((xt -= Q[V + ot]) <= 0); )
              V++, xt <<= 1;
            if (Ut += 1 << V, T === r && Ut > n || T === o && Ut > i)
              return 1;
            S[l = pt & E] = ut << 24 | V << 16 | M - d | 0;
          }
        }
        return pt !== 0 && (S[M + pt] = Z - ot << 24 | 64 << 16 | 0), k.bits = ut, 0;
      };
    }, { "../utils/common": 145 }], 153: [function(x, C, c) {
      C.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 154: [function(x, C, c) {
      var p = x("../utils/common"), v = 4, n = 0, i = 1, s = 2;
      function r(_t) {
        for (var jt = _t.length; --jt >= 0; )
          _t[jt] = 0;
      }
      var o = 0, u = 1, a = 2, f = 3, y = 258, T = 29, h = 256, _ = h + 1 + T, g = 30, S = 19, d = 2 * _ + 1, b = 15, k = 16, O = 7, A = 256, l = 16, E = 17, M = 18, B = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], X = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], K = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], D = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], j = 512, Z = new Array(2 * (_ + 2));
      r(Z);
      var tt = new Array(2 * g);
      r(tt);
      var nt = new Array(j);
      r(nt);
      var ct = new Array(y - f + 1);
      r(ct);
      var ut = new Array(T);
      r(ut);
      var V, ot, xt, Ut = new Array(g);
      function pt(_t, jt, mt, St, kt) {
        this.static_tree = _t, this.extra_bits = jt, this.extra_base = mt, this.elems = St, this.max_length = kt, this.has_stree = _t && _t.length;
      }
      function at(_t, jt) {
        this.dyn_tree = _t, this.max_code = 0, this.stat_desc = jt;
      }
      function bt(_t) {
        return _t < 256 ? nt[_t] : nt[256 + (_t >>> 7)];
      }
      function Q(_t, jt) {
        _t.pending_buf[_t.pending++] = 255 & jt, _t.pending_buf[_t.pending++] = jt >>> 8 & 255;
      }
      function At(_t, jt, mt) {
        _t.bi_valid > k - mt ? (_t.bi_buf |= jt << _t.bi_valid & 65535, Q(_t, _t.bi_buf), _t.bi_buf = jt >> k - _t.bi_valid, _t.bi_valid += mt - k) : (_t.bi_buf |= jt << _t.bi_valid & 65535, _t.bi_valid += mt);
      }
      function Pt(_t, jt, mt) {
        At(_t, mt[2 * jt], mt[2 * jt + 1]);
      }
      function q(_t, jt) {
        var mt = 0;
        do
          mt |= 1 & _t, _t >>>= 1, mt <<= 1;
        while (--jt > 0);
        return mt >>> 1;
      }
      function G(_t) {
        _t.bi_valid === 16 ? (Q(_t, _t.bi_buf), _t.bi_buf = 0, _t.bi_valid = 0) : _t.bi_valid >= 8 && (_t.pending_buf[_t.pending++] = 255 & _t.bi_buf, _t.bi_buf >>= 8, _t.bi_valid -= 8);
      }
      function lt(_t, jt) {
        var mt, St, kt, Dt, it, qt, he = jt.dyn_tree, $ = jt.max_code, Vt = jt.stat_desc.static_tree, W = jt.stat_desc.has_stree, N = jt.stat_desc.extra_bits, R = jt.stat_desc.extra_base, z = jt.stat_desc.max_length, et = 0;
        for (Dt = 0; Dt <= b; Dt++)
          _t.bl_count[Dt] = 0;
        for (he[2 * _t.heap[_t.heap_max] + 1] = 0, mt = _t.heap_max + 1; mt < d; mt++)
          (Dt = he[2 * he[2 * (St = _t.heap[mt]) + 1] + 1] + 1) > z && (Dt = z, et++), he[2 * St + 1] = Dt, St > $ || (_t.bl_count[Dt]++, it = 0, St >= R && (it = N[St - R]), qt = he[2 * St], _t.opt_len += qt * (Dt + it), W && (_t.static_len += qt * (Vt[2 * St + 1] + it)));
        if (et !== 0) {
          do {
            for (Dt = z - 1; _t.bl_count[Dt] === 0; )
              Dt--;
            _t.bl_count[Dt]--, _t.bl_count[Dt + 1] += 2, _t.bl_count[z]--, et -= 2;
          } while (et > 0);
          for (Dt = z; Dt !== 0; Dt--)
            for (St = _t.bl_count[Dt]; St !== 0; )
              (kt = _t.heap[--mt]) > $ || (he[2 * kt + 1] !== Dt && (_t.opt_len += (Dt - he[2 * kt + 1]) * he[2 * kt], he[2 * kt + 1] = Dt), St--);
        }
      }
      function It(_t, jt, mt) {
        var St, kt, Dt = new Array(b + 1), it = 0;
        for (St = 1; St <= b; St++)
          Dt[St] = it = it + mt[St - 1] << 1;
        for (kt = 0; kt <= jt; kt++) {
          var qt = _t[2 * kt + 1];
          qt !== 0 && (_t[2 * kt] = q(Dt[qt]++, qt));
        }
      }
      function Ft() {
        var _t, jt, mt, St, kt, Dt = new Array(b + 1);
        for (mt = 0, St = 0; St < T - 1; St++)
          for (ut[St] = mt, _t = 0; _t < 1 << B[St]; _t++)
            ct[mt++] = St;
        for (ct[mt - 1] = St, kt = 0, St = 0; St < 16; St++)
          for (Ut[St] = kt, _t = 0; _t < 1 << X[St]; _t++)
            nt[kt++] = St;
        for (kt >>= 7; St < g; St++)
          for (Ut[St] = kt << 7, _t = 0; _t < 1 << X[St] - 7; _t++)
            nt[256 + kt++] = St;
        for (jt = 0; jt <= b; jt++)
          Dt[jt] = 0;
        for (_t = 0; _t <= 143; )
          Z[2 * _t + 1] = 8, _t++, Dt[8]++;
        for (; _t <= 255; )
          Z[2 * _t + 1] = 9, _t++, Dt[9]++;
        for (; _t <= 279; )
          Z[2 * _t + 1] = 7, _t++, Dt[7]++;
        for (; _t <= 287; )
          Z[2 * _t + 1] = 8, _t++, Dt[8]++;
        for (It(Z, _ + 1, Dt), _t = 0; _t < g; _t++)
          tt[2 * _t + 1] = 5, tt[2 * _t] = q(_t, 5);
        V = new pt(Z, B, h + 1, _, b), ot = new pt(tt, X, 0, g, b), xt = new pt(new Array(0), K, 0, S, O);
      }
      function H(_t) {
        var jt;
        for (jt = 0; jt < _; jt++)
          _t.dyn_ltree[2 * jt] = 0;
        for (jt = 0; jt < g; jt++)
          _t.dyn_dtree[2 * jt] = 0;
        for (jt = 0; jt < S; jt++)
          _t.bl_tree[2 * jt] = 0;
        _t.dyn_ltree[2 * A] = 1, _t.opt_len = _t.static_len = 0, _t.last_lit = _t.matches = 0;
      }
      function F(_t) {
        _t.bi_valid > 8 ? Q(_t, _t.bi_buf) : _t.bi_valid > 0 && (_t.pending_buf[_t.pending++] = _t.bi_buf), _t.bi_buf = 0, _t.bi_valid = 0;
      }
      function P(_t, jt, mt, St) {
        F(_t), St && (Q(_t, mt), Q(_t, ~mt)), p.arraySet(_t.pending_buf, _t.window, jt, mt, _t.pending), _t.pending += mt;
      }
      function U(_t, jt, mt, St) {
        var kt = 2 * jt, Dt = 2 * mt;
        return _t[kt] < _t[Dt] || _t[kt] === _t[Dt] && St[jt] <= St[mt];
      }
      function rt(_t, jt, mt) {
        for (var St = _t.heap[mt], kt = mt << 1; kt <= _t.heap_len && (kt < _t.heap_len && U(jt, _t.heap[kt + 1], _t.heap[kt], _t.depth) && kt++, !U(jt, St, _t.heap[kt], _t.depth)); )
          _t.heap[mt] = _t.heap[kt], mt = kt, kt <<= 1;
        _t.heap[mt] = St;
      }
      function ft(_t, jt, mt) {
        var St, kt, Dt, it, qt = 0;
        if (_t.last_lit !== 0)
          do
            St = _t.pending_buf[_t.d_buf + 2 * qt] << 8 | _t.pending_buf[_t.d_buf + 2 * qt + 1], kt = _t.pending_buf[_t.l_buf + qt], qt++, St === 0 ? Pt(_t, kt, jt) : (Pt(_t, (Dt = ct[kt]) + h + 1, jt), (it = B[Dt]) !== 0 && At(_t, kt -= ut[Dt], it), Pt(_t, Dt = bt(--St), mt), (it = X[Dt]) !== 0 && At(_t, St -= Ut[Dt], it));
          while (qt < _t.last_lit);
        Pt(_t, A, jt);
      }
      function Ot(_t, jt) {
        var mt, St, kt, Dt = jt.dyn_tree, it = jt.stat_desc.static_tree, qt = jt.stat_desc.has_stree, he = jt.stat_desc.elems, $ = -1;
        for (_t.heap_len = 0, _t.heap_max = d, mt = 0; mt < he; mt++)
          Dt[2 * mt] !== 0 ? (_t.heap[++_t.heap_len] = $ = mt, _t.depth[mt] = 0) : Dt[2 * mt + 1] = 0;
        for (; _t.heap_len < 2; )
          Dt[2 * (kt = _t.heap[++_t.heap_len] = $ < 2 ? ++$ : 0)] = 1, _t.depth[kt] = 0, _t.opt_len--, qt && (_t.static_len -= it[2 * kt + 1]);
        for (jt.max_code = $, mt = _t.heap_len >> 1; mt >= 1; mt--)
          rt(_t, Dt, mt);
        kt = he;
        do
          mt = _t.heap[1], _t.heap[1] = _t.heap[_t.heap_len--], rt(_t, Dt, 1), St = _t.heap[1], _t.heap[--_t.heap_max] = mt, _t.heap[--_t.heap_max] = St, Dt[2 * kt] = Dt[2 * mt] + Dt[2 * St], _t.depth[kt] = (_t.depth[mt] >= _t.depth[St] ? _t.depth[mt] : _t.depth[St]) + 1, Dt[2 * mt + 1] = Dt[2 * St + 1] = kt, _t.heap[1] = kt++, rt(_t, Dt, 1);
        while (_t.heap_len >= 2);
        _t.heap[--_t.heap_max] = _t.heap[1], lt(_t, jt), It(Dt, $, _t.bl_count);
      }
      function Wt(_t, jt, mt) {
        var St, kt, Dt = -1, it = jt[1], qt = 0, he = 7, $ = 4;
        for (it === 0 && (he = 138, $ = 3), jt[2 * (mt + 1) + 1] = 65535, St = 0; St <= mt; St++)
          kt = it, it = jt[2 * (St + 1) + 1], ++qt < he && kt === it || (qt < $ ? _t.bl_tree[2 * kt] += qt : kt !== 0 ? (kt !== Dt && _t.bl_tree[2 * kt]++, _t.bl_tree[2 * l]++) : qt <= 10 ? _t.bl_tree[2 * E]++ : _t.bl_tree[2 * M]++, qt = 0, Dt = kt, it === 0 ? (he = 138, $ = 3) : kt === it ? (he = 6, $ = 3) : (he = 7, $ = 4));
      }
      function ce(_t, jt, mt) {
        var St, kt, Dt = -1, it = jt[1], qt = 0, he = 7, $ = 4;
        for (it === 0 && (he = 138, $ = 3), St = 0; St <= mt; St++)
          if (kt = it, it = jt[2 * (St + 1) + 1], !(++qt < he && kt === it)) {
            if (qt < $)
              do
                Pt(_t, kt, _t.bl_tree);
              while (--qt != 0);
            else
              kt !== 0 ? (kt !== Dt && (Pt(_t, kt, _t.bl_tree), qt--), Pt(_t, l, _t.bl_tree), At(_t, qt - 3, 2)) : qt <= 10 ? (Pt(_t, E, _t.bl_tree), At(_t, qt - 3, 3)) : (Pt(_t, M, _t.bl_tree), At(_t, qt - 11, 7));
            qt = 0, Dt = kt, it === 0 ? (he = 138, $ = 3) : kt === it ? (he = 6, $ = 3) : (he = 7, $ = 4);
          }
      }
      function ye(_t) {
        var jt;
        for (Wt(_t, _t.dyn_ltree, _t.l_desc.max_code), Wt(_t, _t.dyn_dtree, _t.d_desc.max_code), Ot(_t, _t.bl_desc), jt = S - 1; jt >= 3 && _t.bl_tree[2 * D[jt] + 1] === 0; jt--)
          ;
        return _t.opt_len += 3 * (jt + 1) + 5 + 5 + 4, jt;
      }
      function ge(_t, jt, mt, St) {
        var kt;
        for (At(_t, jt - 257, 5), At(_t, mt - 1, 5), At(_t, St - 4, 4), kt = 0; kt < St; kt++)
          At(_t, _t.bl_tree[2 * D[kt] + 1], 3);
        ce(_t, _t.dyn_ltree, jt - 1), ce(_t, _t.dyn_dtree, mt - 1);
      }
      function Ce(_t) {
        var jt, mt = 4093624447;
        for (jt = 0; jt <= 31; jt++, mt >>>= 1)
          if (1 & mt && _t.dyn_ltree[2 * jt] !== 0)
            return n;
        if (_t.dyn_ltree[18] !== 0 || _t.dyn_ltree[20] !== 0 || _t.dyn_ltree[26] !== 0)
          return i;
        for (jt = 32; jt < h; jt++)
          if (_t.dyn_ltree[2 * jt] !== 0)
            return i;
        return n;
      }
      r(Ut);
      var _e = !1;
      function je(_t) {
        _e || (Ft(), _e = !0), _t.l_desc = new at(_t.dyn_ltree, V), _t.d_desc = new at(_t.dyn_dtree, ot), _t.bl_desc = new at(_t.bl_tree, xt), _t.bi_buf = 0, _t.bi_valid = 0, H(_t);
      }
      function Ie(_t, jt, mt, St) {
        At(_t, (o << 1) + (St ? 1 : 0), 3), P(_t, jt, mt, !0);
      }
      function $e(_t) {
        At(_t, u << 1, 3), Pt(_t, A, Z), G(_t);
      }
      function He(_t, jt, mt, St) {
        var kt, Dt, it = 0;
        _t.level > 0 ? (_t.strm.data_type === s && (_t.strm.data_type = Ce(_t)), Ot(_t, _t.l_desc), Ot(_t, _t.d_desc), it = ye(_t), kt = _t.opt_len + 3 + 7 >>> 3, (Dt = _t.static_len + 3 + 7 >>> 3) <= kt && (kt = Dt)) : kt = Dt = mt + 5, mt + 4 <= kt && jt !== -1 ? Ie(_t, jt, mt, St) : _t.strategy === v || Dt === kt ? (At(_t, (u << 1) + (St ? 1 : 0), 3), ft(_t, Z, tt)) : (At(_t, (a << 1) + (St ? 1 : 0), 3), ge(_t, _t.l_desc.max_code + 1, _t.d_desc.max_code + 1, it + 1), ft(_t, _t.dyn_ltree, _t.dyn_dtree)), H(_t), St && F(_t);
      }
      function De(_t, jt, mt) {
        return _t.pending_buf[_t.d_buf + 2 * _t.last_lit] = jt >>> 8 & 255, _t.pending_buf[_t.d_buf + 2 * _t.last_lit + 1] = 255 & jt, _t.pending_buf[_t.l_buf + _t.last_lit] = 255 & mt, _t.last_lit++, jt === 0 ? _t.dyn_ltree[2 * mt]++ : (_t.matches++, jt--, _t.dyn_ltree[2 * (ct[mt] + h + 1)]++, _t.dyn_dtree[2 * bt(jt)]++), _t.last_lit === _t.lit_bufsize - 1;
      }
      c._tr_init = je, c._tr_stored_block = Ie, c._tr_flush_block = He, c._tr_tally = De, c._tr_align = $e;
    }, { "../utils/common": 145 }], 155: [function(x, C, c) {
      function p() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      }
      C.exports = p;
    }, {}], 156: [function(x, C, c) {
      (function(p) {
        (function() {
          function v(r) {
            if (typeof r != "string")
              throw new TypeError("Path must be a string. Received " + JSON.stringify(r));
          }
          function n(r, o) {
            for (var u, a = "", f = 0, y = -1, T = 0, h = 0; h <= r.length; ++h) {
              if (h < r.length)
                u = r.charCodeAt(h);
              else {
                if (u === 47)
                  break;
                u = 47;
              }
              if (u === 47) {
                if (!(y === h - 1 || T === 1))
                  if (y !== h - 1 && T === 2) {
                    if (a.length < 2 || f !== 2 || a.charCodeAt(a.length - 1) !== 46 || a.charCodeAt(a.length - 2) !== 46) {
                      if (a.length > 2) {
                        var _ = a.lastIndexOf("/");
                        if (_ !== a.length - 1) {
                          _ === -1 ? (a = "", f = 0) : f = (a = a.slice(0, _)).length - 1 - a.lastIndexOf("/"), y = h, T = 0;
                          continue;
                        }
                      } else if (a.length === 2 || a.length === 1) {
                        a = "", f = 0, y = h, T = 0;
                        continue;
                      }
                    }
                    o && (a.length > 0 ? a += "/.." : a = "..", f = 2);
                  } else
                    a.length > 0 ? a += "/" + r.slice(y + 1, h) : a = r.slice(y + 1, h), f = h - y - 1;
                y = h, T = 0;
              } else
                u === 46 && T !== -1 ? ++T : T = -1;
            }
            return a;
          }
          function i(r, o) {
            var u = o.dir || o.root, a = o.base || (o.name || "") + (o.ext || "");
            return u ? u === o.root ? u + a : u + r + a : a;
          }
          var s = { resolve: function() {
            for (var r, o = "", u = !1, a = arguments.length - 1; a >= -1 && !u; a--) {
              var f;
              a >= 0 ? f = arguments[a] : (r === void 0 && (r = p.cwd()), f = r), v(f), f.length !== 0 && (o = f + "/" + o, u = f.charCodeAt(0) === 47);
            }
            return o = n(o, !u), u ? o.length > 0 ? "/" + o : "/" : o.length > 0 ? o : ".";
          }, normalize: function(r) {
            if (v(r), r.length === 0)
              return ".";
            var o = r.charCodeAt(0) === 47, u = r.charCodeAt(r.length - 1) === 47;
            return (r = n(r, !o)).length !== 0 || o || (r = "."), r.length > 0 && u && (r += "/"), o ? "/" + r : r;
          }, isAbsolute: function(r) {
            return v(r), r.length > 0 && r.charCodeAt(0) === 47;
          }, join: function() {
            if (arguments.length === 0)
              return ".";
            for (var r, o = 0; o < arguments.length; ++o) {
              var u = arguments[o];
              v(u), u.length > 0 && (r === void 0 ? r = u : r += "/" + u);
            }
            return r === void 0 ? "." : s.normalize(r);
          }, relative: function(r, o) {
            if (v(r), v(o), r === o || (r = s.resolve(r)) === (o = s.resolve(o)))
              return "";
            for (var u = 1; u < r.length && r.charCodeAt(u) === 47; ++u)
              ;
            for (var a = r.length, f = a - u, y = 1; y < o.length && o.charCodeAt(y) === 47; ++y)
              ;
            for (var T = o.length - y, h = f < T ? f : T, _ = -1, g = 0; g <= h; ++g) {
              if (g === h) {
                if (T > h) {
                  if (o.charCodeAt(y + g) === 47)
                    return o.slice(y + g + 1);
                  if (g === 0)
                    return o.slice(y + g);
                } else
                  f > h && (r.charCodeAt(u + g) === 47 ? _ = g : g === 0 && (_ = 0));
                break;
              }
              var S = r.charCodeAt(u + g);
              if (S !== o.charCodeAt(y + g))
                break;
              S === 47 && (_ = g);
            }
            var d = "";
            for (g = u + _ + 1; g <= a; ++g)
              g !== a && r.charCodeAt(g) !== 47 || (d.length === 0 ? d += ".." : d += "/..");
            return d.length > 0 ? d + o.slice(y + _) : (y += _, o.charCodeAt(y) === 47 && ++y, o.slice(y));
          }, _makeLong: function(r) {
            return r;
          }, dirname: function(r) {
            if (v(r), r.length === 0)
              return ".";
            for (var o = r.charCodeAt(0), u = o === 47, a = -1, f = !0, y = r.length - 1; y >= 1; --y)
              if ((o = r.charCodeAt(y)) === 47) {
                if (!f) {
                  a = y;
                  break;
                }
              } else
                f = !1;
            return a === -1 ? u ? "/" : "." : u && a === 1 ? "//" : r.slice(0, a);
          }, basename: function(r, o) {
            if (o !== void 0 && typeof o != "string")
              throw new TypeError('"ext" argument must be a string');
            v(r);
            var u, a = 0, f = -1, y = !0;
            if (o !== void 0 && o.length > 0 && o.length <= r.length) {
              if (o.length === r.length && o === r)
                return "";
              var T = o.length - 1, h = -1;
              for (u = r.length - 1; u >= 0; --u) {
                var _ = r.charCodeAt(u);
                if (_ === 47) {
                  if (!y) {
                    a = u + 1;
                    break;
                  }
                } else
                  h === -1 && (y = !1, h = u + 1), T >= 0 && (_ === o.charCodeAt(T) ? --T == -1 && (f = u) : (T = -1, f = h));
              }
              return a === f ? f = h : f === -1 && (f = r.length), r.slice(a, f);
            }
            for (u = r.length - 1; u >= 0; --u)
              if (r.charCodeAt(u) === 47) {
                if (!y) {
                  a = u + 1;
                  break;
                }
              } else
                f === -1 && (y = !1, f = u + 1);
            return f === -1 ? "" : r.slice(a, f);
          }, extname: function(r) {
            v(r);
            for (var o = -1, u = 0, a = -1, f = !0, y = 0, T = r.length - 1; T >= 0; --T) {
              var h = r.charCodeAt(T);
              if (h !== 47)
                a === -1 && (f = !1, a = T + 1), h === 46 ? o === -1 ? o = T : y !== 1 && (y = 1) : o !== -1 && (y = -1);
              else if (!f) {
                u = T + 1;
                break;
              }
            }
            return o === -1 || a === -1 || y === 0 || y === 1 && o === a - 1 && o === u + 1 ? "" : r.slice(o, a);
          }, format: function(r) {
            if (r === null || typeof r != "object")
              throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof r);
            return i("/", r);
          }, parse: function(r) {
            v(r);
            var o = { root: "", dir: "", base: "", ext: "", name: "" };
            if (r.length === 0)
              return o;
            var u, a = r.charCodeAt(0), f = a === 47;
            f ? (o.root = "/", u = 1) : u = 0;
            for (var y = -1, T = 0, h = -1, _ = !0, g = r.length - 1, S = 0; g >= u; --g)
              if ((a = r.charCodeAt(g)) !== 47)
                h === -1 && (_ = !1, h = g + 1), a === 46 ? y === -1 ? y = g : S !== 1 && (S = 1) : y !== -1 && (S = -1);
              else if (!_) {
                T = g + 1;
                break;
              }
            return y === -1 || h === -1 || S === 0 || S === 1 && y === h - 1 && y === T + 1 ? h !== -1 && (o.base = o.name = T === 0 && f ? r.slice(1, h) : r.slice(T, h)) : (T === 0 && f ? (o.name = r.slice(1, y), o.base = r.slice(1, h)) : (o.name = r.slice(T, y), o.base = r.slice(T, h)), o.ext = r.slice(y, h)), T > 0 ? o.dir = r.slice(0, T - 1) : f && (o.dir = "/"), o;
          }, sep: "/", delimiter: ":", win32: null, posix: null };
          s.posix = s, C.exports = s;
        }).call(this);
      }).call(this, x("_process"));
    }, { _process: 158 }], 157: [function(x, C, c) {
      (function(p) {
        (function() {
          (function(v) {
            typeof c == "object" && typeof C != "undefined" ? C.exports = v() : (typeof window != "undefined" ? window : typeof p != "undefined" ? p : typeof self != "undefined" ? self : this).Patrun = v();
          })(function() {
            var v = { exports: {} };
            (function(k) {
              (function() {
                (function(O) {
                  typeof v.exports == "object" ? v.exports = O() : (typeof window != "undefined" ? window : k !== void 0 ? k : typeof self != "undefined" ? self : this).Gex = O();
                })(function() {
                  var O = { exports: {} };
                  Object.defineProperty(O.exports, "__esModule", { value: !0 }), O.exports.Gex = void 0;
                  class A {
                    constructor(M) {
                      this.desc = "", this.gexmap = {}, M != null && (Array.isArray(M) ? M : [M]).forEach((B) => {
                        this.gexmap[B] = this.re(this.clean(B));
                      });
                    }
                    dodgy(M) {
                      return M == null || Number.isNaN(M);
                    }
                    clean(M) {
                      let B = "" + M;
                      return this.dodgy(M) ? "" : B;
                    }
                    match(M) {
                      M = "" + M;
                      let B = !1, X = Object.keys(this.gexmap);
                      for (let K = 0; K < X.length && !B; K++)
                        B = !!this.gexmap[X[K]].exec(M);
                      return B;
                    }
                    on(M) {
                      if (M == null)
                        return null;
                      let B = typeof M;
                      if (B === "string" || B === "number" || B === "boolean" || M instanceof Date || M instanceof RegExp)
                        return this.match(M) ? M : null;
                      if (Array.isArray(M)) {
                        let X = [];
                        for (let K = 0; K < M.length; K++)
                          !this.dodgy(M[K]) && this.match(M[K]) && X.push(M[K]);
                        return X;
                      }
                      {
                        let X = {};
                        for (let K in M)
                          Object.prototype.hasOwnProperty.call(M, K) && this.match(K) && (X[K] = M[K]);
                        return X;
                      }
                    }
                    esc(M) {
                      let B = this.clean(M);
                      return (B = B.replace(/\*/g, "**")).replace(/\?/g, "*?");
                    }
                    escregexp(M) {
                      return M ? ("" + M).replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : "";
                    }
                    re(M) {
                      if (M === "" || M)
                        return M = "^" + (M = (M = (M = (M = (M = this.escregexp(M)).replace(/\\\*/g, "[\\s\\S]*")).replace(/\\\?/g, "[\\s\\S]")).replace(/\[\\s\\S\]\*\[\\s\\S\]\*/g, "\\*")).replace(/\[\\s\\S\]\*\[\\s\\S\]/g, "\\?")) + "$", new RegExp(M);
                      {
                        let B = Object.keys(this.gexmap);
                        return B.length == 1 ? this.gexmap[B[0]] : Ge({}, this.gexmap);
                      }
                    }
                    toString() {
                      let M = this.desc;
                      return M != "" ? M : this.desc = "Gex[" + Object.keys(this.gexmap) + "]";
                    }
                    inspect() {
                      return this.toString();
                    }
                  }
                  function l(E) {
                    return new A(E);
                  }
                  return O.exports.Gex = l, O.exports = l, O.exports.Gex = l, O.exports.default = l, O.exports;
                });
              }).call(this);
            }).call(this, typeof p != "undefined" ? p : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}), v = v.exports;
            var n, i, s, r, o, u, a, f, y, T = {}, h = this && this.__classPrivateFieldGet || function(k, O, A, l) {
              if (A === "a" && !l)
                throw new TypeError("Private accessor was defined without a getter");
              if (typeof O == "function" ? k !== O || !l : !O.has(k))
                throw new TypeError("Cannot read private member from an object whose class did not declare it");
              return A === "m" ? l : A === "a" ? l.call(k) : l ? l.value : O.get(k);
            };
            Object.defineProperty(T, "__esModule", { value: !0 }), T.IntervalMatcher = T.GexMatcher = void 0, T.GexMatcher = class {
              constructor() {
              }
              make(k, O) {
                if (typeof O == "string" && O.match(/[*?]/)) {
                  let A = (0, v.Gex)(O);
                  return { kind: "gex", match: (l) => A.on(l) != null, fix: O, meta: {}, same(l) {
                    return l != null && l.kind === this.kind && l.fix === this.fix;
                  } };
                }
              }
              scan(k, O) {
                let A = k.filter((l) => l.fix === "*").length > 0;
                return { complete: A, sound: A, gaps: [], overs: [], why: "no-star" };
              }
            };
            const _ = new RegExp(["^/s*", "(=*[<>/(/[]?=*)?/s*([-+0-9a-fA-FeEoOxX]+(/.([0-9a-fA-FeEoOxX]+))?)([/)/]]?)(/s*(,|&+|/|+|/./.)/s*(=*[<>]?=*)/s*([-+.0-9a-fA-FeEoOxX]+)/s*([/)/]]?))?/s*$"].join("").replace(/\//g, "\\"));
            class g {
              constructor() {
                this.kind = "interval", n.set(this, (O, A) => function(l) {
                  return O(l) && A(l);
                }), i.set(this, (O, A) => function(l) {
                  return O(l) || A(l);
                }), s.set(this, (O) => function(A) {
                  return !1;
                }), r.set(this, (O) => function(A) {
                  return !1;
                }), o.set(this, (O) => function(A) {
                  return A > O;
                }), u.set(this, (O) => function(A) {
                  return A >= O;
                }), a.set(this, (O) => function(A) {
                  return A < O;
                }), f.set(this, (O) => function(A) {
                  return A <= O;
                }), y.set(this, (O) => function(A) {
                  return A === O;
                });
              }
              make(O, A) {
                if (typeof A == "string" && A.match(/[=<>.[()\]]/)) {
                  let l = A.match(_);
                  if (l != null) {
                    let E = g.normop(l[1]) || g.normop(l[5]), M = g.normop(l[8]) || g.normop(l[10]), B = h(this, E === "=" ? y : E === "<" || E === ")" ? a : E === "<=" || E === "]" ? f : E === ">" || E === "(" ? o : E === ">=" || E === "[" ? u : r, "f"), X = Number(l[2]), K = l[9] == null ? NaN : Number(l[9]), D = l[7], j = D == null ? h(this, i, "f") : D.substring(0, 1) === "&" || D.substring(0, 1) === "," ? h(this, n, "f") : h(this, i, "f");
                    D === ".." && (j = h(this, n, "f"), B = h(this, r, "f") === B ? h(this, u, "f") : B, M = M === "" ? "<=" : M);
                    let Z = h(this, M == null ? s : M === "=" ? y : M === "<" || M === ")" ? a : M === "<=" || M === "]" ? f : M === ">" ? o : M === ">=" ? u : r, "f");
                    if (X === K && (E === "=" && M != null ? (K = NaN, Z = h(this, s, "f"), B = M.includes("<") ? h(this, f, "f") : M.includes(">") ? h(this, u, "f") : M.includes("=") ? h(this, y, "f") : h(this, r, "f")) : M === "=" && E != null && (K = NaN, Z = h(this, s, "f"), B = E.includes("<") ? h(this, f, "f") : E.includes(">") ? h(this, u, "f") : h(this, r, "f"))), h(this, r, "f") !== B && h(this, s, "f") === Z && (h(this, a, "f") === B || h(this, f, "f") === B ? (Z = B, K = X, B = h(this, u, "f"), X = Number.NEGATIVE_INFINITY, j = h(this, n, "f")) : h(this, o, "f") !== B && h(this, u, "f") !== B || (Z = h(this, f, "f"), K = Number.POSITIVE_INFINITY, j = h(this, n, "f"))), !isNaN(K) && K < X) {
                      let ut = Z, V = K;
                      K = X, X = V, D !== ".." && (Z = B, B = ut);
                    }
                    let tt = B(X), nt = Z(K), ct = j(tt, nt);
                    return { kind: "interval", fix: A, meta: { jo: ct.name, o0: tt.name, n0: X, o1: nt.name, n1: K }, match: (ut) => {
                      let V = !1, ot = parseFloat(ut);
                      return isNaN(ot) || (V = ct(ot)), V;
                    }, same(ut) {
                      return ut != null && ut.kind === this.kind && ut.meta.jo === this.meta.jo && ut.meta.o0 === this.meta.o0 && ut.meta.n0 === this.meta.n0 && ut.meta.o1 === this.meta.o1 && ut.meta.n1 === this.meta.n1;
                    } };
                  }
                }
              }
              scan(O, A) {
                let l = { complete: !1, sound: !1, gaps: [], overs: [], lower: null, upper: null }, E = Number.NEGATIVE_INFINITY, M = Number.POSITIVE_INFINITY, B = this.half_intervals(O);
                B.reduce((K, D) => {
                  let j = D.o === "eq", Z = D.o === "lt", tt = D.o === "lte", nt = D.o === "gt", ct = D.o === "gte", ut = D.n;
                  if (K.lower == null) {
                    let V = { n: E, o: "gte" };
                    K.lower = V, K.upper = D, E == ut && ct || (nt || ct ? K.gaps.push([V, { n: ut, o: nt ? "lte" : "lt", m: 0 }]) : j && K.gaps.push([V, { n: ut, o: "lte", m: 1 }]));
                  } else {
                    let V = K.upper.o === "eq", ot = K.upper.o === "lt", xt = K.upper.o === "lte", Ut = (K.upper.o, K.upper.o, K.upper.n), pt = K.upper;
                    ut === Ut ? ot && (ct || j) || (xt || V) && nt || (V || ot || xt) && K.gaps.push([{ n: Ut, o: V || xt ? "gt" : "gte", m: 2, d: { u: pt, h: D } }, { n: ut, o: j || ct ? "lt" : "lte", m: 3 }]) : Ut < ut ? Z || tt || (V || ot || xt) && K.gaps.push([{ n: Ut, o: V || xt ? "gt" : "gte", m: 4 }, { n: ut, o: j || ct ? "lt" : "lte", m: 5 }]) : K.overs.push([{ n: ut, o: j || ct ? "gte" : "gt", m: 10 }, { n: Ut, o: V || xt ? "lte" : "lt", m: 11 }]), K.upper = D;
                  }
                  return K;
                }, l);
                let X = 0 < B.length && B[B.length - 1];
                return X && M !== X.n && X.o !== "gt" && X.o !== "gte" && l.gaps.push([{ n: X.n, o: X.o === "eq" || X.o === "lte" ? "gt" : "gte", m: 6 }, { n: M, o: "lte", m: 7 }]), l.complete = l.gaps.length === 0, l.sound = l.overs.length === 0, l;
              }
              half_intervals(O) {
                let A = [];
                for (let E of O)
                  A.push([{ n: E.meta.n0, o: E.meta.o0 }, { n: E.meta.n1, o: E.meta.o1 }]);
                var l = ["lt", "lte", "eq", "gte", "gt"];
                return A.map((E) => [isNaN(E[0].n) || E[0].n == null ? null : E[0], isNaN(E[1].n) || E[1].n == null ? null : E[1]].filter((M) => M != null)).sort((E, M) => {
                  if (E[0].n < M[0].n)
                    return -1;
                  if (M[0].n < E[0].n)
                    return 1;
                  var B = l.indexOf(E[0].o), X = l.indexOf(M[0].o);
                  if (B < X)
                    return -1;
                  if (X < B)
                    return 1;
                  if (E[1].n < M[1].n)
                    return -1;
                  if (M[1].n < E[1].n)
                    return 1;
                  var K = l.indexOf(E[1].o), D = l.indexOf(M[1].o);
                  return K < D ? -1 : D < K ? 1 : 0;
                }).reduce((E, M) => E.concat(...M), []);
              }
            }
            T.IntervalMatcher = g, n = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap(), g.normop = (k) => k == null ? null : ((k.match(/([<>\(\)\[\]])/) || [])[1] || "") + ((k.match(/(=)/) || [])[1] || "");
            var S = { exports: {} };
            function d(k) {
              var O = {}, A = {};
              let l = [];
              return (k = k || {}).gex && l.push(new T.GexMatcher()), k.interval && l.push(new T.IntervalMatcher()), O.top = function() {
                return A;
              }, O.add = function(E, M) {
                E = Ge({}, E);
                var B = typeof k == "function" ? k.call(O, E, M) : null, X = Object.keys(E).filter((V) => E[V] != null).sort();
                X.forEach(function(V) {
                  E[V] = String(E[V]);
                });
                for (var K, D = A, j = 0; j < X.length; j++) {
                  var Z = X[j], tt = E[Z];
                  let V = l.reduce((ot, xt) => ot || xt.make(Z, tt), void 0);
                  if ((K = D.v) && Z == D.k)
                    if (V) {
                      var nt = (ut = D.g = D.g || {})[Z] = ut[Z] || [];
                      D = (V = nt.find((ot) => ot.same(V)) || (nt.push(V), V)).keymap || (V.keymap = {});
                    } else
                      D = K[tt] || (K[tt] = {});
                  else if (D.k)
                    if (Z < D.k) {
                      var ct = D.s;
                      ut = D.g, D.s = { k: D.k, v: D.v }, ct && (D.s.s = ct), ut && (D.s.g = ut), D.g && (D.g = {}), D.k = Z, D.v = {}, V ? (nt = (ut = D.g = D.g || {})[Z] = ut[Z] || [], D = (V = nt.find((ot) => ot.same(V)) || (nt.push(V), V)).keymap || (V.keymap = {})) : D = D.v[tt] = {};
                    } else
                      D = D.s || (D.s = {}), j--;
                  else if (D.k = Z, D.v = {}, V) {
                    var ut;
                    nt = (ut = D.g = D.g || {})[Z] = ut[Z] || [], D = (V = nt.find((ot) => ot.same(V)) || (nt.push(V), V)).keymap || (V.keymap = {});
                  } else
                    D = D.v[tt] = {};
                }
                return M !== void 0 && D && (D.d = M, B && (D.f = typeof B == "function" ? B : B.find, D.r = typeof B.remove == "function" ? B.remove : void 0)), O;
              }, O.findexact = function(E) {
                return O.find(E, !0);
              }, O.find = function(E, M, B) {
                if (E == null)
                  return null;
                var X = A, K = A.d === void 0 ? null : A.d, D = A.f, j = null, Z = [], tt = {}, nt = Object.keys(E).length, ct = [];
                A.d !== void 0 && ct.push(A.d);
                do {
                  if (j = X.k, X.v) {
                    var ut = E[j], V = X.v[ut];
                    if (!V && X.g && X.g[j]) {
                      for (var ot = X.g[j], xt = 0; xt < ot.length; xt++)
                        if (ot[xt].match(ut)) {
                          V = ot[xt].keymap;
                          break;
                        }
                    }
                    V ? (tt[j] = !0, X.s && Z.push(X.s), K = V.d === void 0 ? M ? null : K : V.d, B && V.d !== void 0 && ct.push(V.d), D = V.f, X = V) : X = X.s;
                  } else
                    X = null;
                  X == null && 0 < Z.length && (K == null || B && !M) && (X = Z.pop());
                } while (X);
                return M ? Object.keys(tt).length !== nt && (K = null) : K == null && A.d !== void 0 && (K = A.d), D && (K = D.call(O, E, K)), B ? ct : K;
              }, O.remove = function(E) {
                var M, B = A, X = null, K = [];
                do
                  if (M = B.k, B.v || B.g) {
                    if (B.v) {
                      var D = B.v[E[M]];
                      D && K.push({ km: B, v: E[M] });
                    }
                    if (D == null && B.g) {
                      let tt = B.g[M] || [];
                      for (let nt = 0; nt < tt.length; nt++)
                        if (tt[nt].fix === E[M]) {
                          K.push({ km: B, v: E[M], mv: tt[nt] }), D = tt[nt].keymap;
                          break;
                        }
                    }
                    D ? (X = D.d, B = D) : B = B.s;
                  } else
                    B = null;
                while (B);
                if (X !== void 0) {
                  var j = K[K.length - 1];
                  if (j && j.km && j.km.v) {
                    var Z = j.km.v[j.v] || j.mv && j.mv.keymap;
                    !Z || Z.r && !Z.r(E, Z.d) || delete Z.d;
                  }
                }
              }, O.list = function(E, M) {
                E = E || {};
                var B = [];
                return A.d && B.push({ match: {}, data: A.d, find: A.f }), function X(K, D, j, Z) {
                  if (K.v) {
                    var tt, nt = K.k, ct = (0, v.Gex)(E ? E[nt] == null ? M ? null : "*" : E[nt] : "*"), ut = Ge({}, D), V = Ge({}, j);
                    for (var ot in K.v)
                      if (ot === E[nt] || !M && E[nt] == null || ct.on(ot)) {
                        var xt = Ge({}, ut);
                        xt[nt] = ot;
                        var Ut = Ge({}, V);
                        delete Ut[nt], tt = K.v[ot], Object.keys(Ut).length === 0 && tt && tt.d && Z.push({ match: xt, data: tt.d, find: tt.f }), tt && tt.v != null && X(tt, Ge({}, xt), Ge({}, Ut), Z);
                      }
                    (tt = K.s) && X(tt, Ge({}, ut), Ge({}, V), Z);
                  }
                }(A, {}, Ge({}, E), B), B;
              }, O.toString = function(E, M) {
                var B = E === !0 || !!M, X = typeof E == "function" ? E : function(Z) {
                  return typeof Z == "function" ? "<" + Z.name + ">" : "<" + Z + ">";
                };
                function K(Z, tt) {
                  for (var nt = 0; nt < tt; nt++)
                    Z.push(" ");
                }
                var D = [], j = [];
                return function Z(tt, nt, ct, ut) {
                  var V;
                  if (tt.d !== void 0 && (nt.push(" " + X(tt.d)), D.push(ut.join(", ") + " -> " + X(tt.d))), tt.k && (nt.push(`
`), K(nt, ct), nt.push(tt.k + ":")), (tt.v || tt.s || tt.g) && ct++, tt.v)
                    for (var ot = Object.keys(tt.v).sort(), xt = 0; xt < ot.length; xt++) {
                      var Ut = ot[xt];
                      nt.push(`
`), K(nt, ct), nt.push(Ut + " ->"), (V = ut.slice()).push(tt.k + "=" + Ut), Z(tt.v[Ut], nt, ct + 1, V);
                    }
                  if (tt.g)
                    for (ot = Object.keys(tt.g).sort(), xt = 0; xt < ot.length; xt++)
                      for (var pt = tt.g[ot[xt]], at = 0; at < pt.length; at++) {
                        var bt = pt[at];
                        nt.push(`
`), K(nt, ct), nt.push(bt.fix + " ~>"), (V = ut.slice()).push(tt.k + "~" + bt.fix), Z(bt.keymap, nt, ct + 1, V);
                      }
                  tt.s && (nt.push(`
`), K(nt, ct), nt.push("|"), V = ut.slice(), Z(tt.s, nt, ct + 1, V));
                }(A, j, 0, []), B ? j.join("") : D.join(`
`);
              }, O.inspect = O.toString, O.toJSON = function(E) {
                return JSON.stringify(A, function(M, B) {
                  return typeof B == "function" ? "[Function]" : B;
                }, E);
              }, O;
            }
            function b(k) {
              return new d(k);
            }
            return Object.defineProperty(S.exports, "__esModule", { value: !0 }), S.exports.Gex = S.exports.Patrun = void 0, Object.defineProperty(S.exports, "Gex", { enumerable: !0, get: function() {
              return v.Gex;
            } }), S.exports.Patrun = d, S.exports = b, S.exports.Patrun = d, S.exports.Gex = v.Gex, S.exports.default = b, S.exports;
          });
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 158: [function(x, C, c) {
      var p, v, n = C.exports = {};
      function i() {
        throw new Error("setTimeout has not been defined");
      }
      function s() {
        throw new Error("clearTimeout has not been defined");
      }
      function r(S) {
        if (p === setTimeout)
          return setTimeout(S, 0);
        if ((p === i || !p) && setTimeout)
          return p = setTimeout, setTimeout(S, 0);
        try {
          return p(S, 0);
        } catch (d) {
          try {
            return p.call(null, S, 0);
          } catch (b) {
            return p.call(this, S, 0);
          }
        }
      }
      function o(S) {
        if (v === clearTimeout)
          return clearTimeout(S);
        if ((v === s || !v) && clearTimeout)
          return v = clearTimeout, clearTimeout(S);
        try {
          return v(S);
        } catch (d) {
          try {
            return v.call(null, S);
          } catch (b) {
            return v.call(this, S);
          }
        }
      }
      (function() {
        try {
          p = typeof setTimeout == "function" ? setTimeout : i;
        } catch (S) {
          p = i;
        }
        try {
          v = typeof clearTimeout == "function" ? clearTimeout : s;
        } catch (S) {
          v = s;
        }
      })();
      var u, a = [], f = !1, y = -1;
      function T() {
        f && u && (f = !1, u.length ? a = u.concat(a) : y = -1, a.length && h());
      }
      function h() {
        if (!f) {
          var S = r(T);
          f = !0;
          for (var d = a.length; d; ) {
            for (u = a, a = []; ++y < d; )
              u && u[y].run();
            y = -1, d = a.length;
          }
          u = null, f = !1, o(S);
        }
      }
      function _(S, d) {
        this.fun = S, this.array = d;
      }
      function g() {
      }
      n.nextTick = function(S) {
        var d = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var b = 1; b < arguments.length; b++)
            d[b - 1] = arguments[b];
        a.push(new _(S, d)), a.length !== 1 || f || r(h);
      }, _.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, n.title = "browser", n.browser = !0, n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = g, n.addListener = g, n.once = g, n.off = g, n.removeListener = g, n.removeAllListeners = g, n.emit = g, n.prependListener = g, n.prependOnceListener = g, n.listeners = function(S) {
        return [];
      }, n.binding = function(S) {
        throw new Error("process.binding is not supported");
      }, n.cwd = function() {
        return "/";
      }, n.chdir = function(S) {
        throw new Error("process.chdir is not supported");
      }, n.umask = function() {
        return 0;
      };
    }, {}], 159: [function(x, C, c) {
      (function(p) {
        (function() {
          (function(v) {
            var n = typeof c == "object" && c && !c.nodeType && c, i = typeof C == "object" && C && !C.nodeType && C, s = typeof p == "object" && p;
            s.global !== s && s.window !== s && s.self !== s || (v = s);
            var r, o, u = 2147483647, a = 36, f = 1, y = 26, T = 38, h = 700, _ = 72, g = 128, S = "-", d = /^xn--/, b = /[^\x20-\x7E]/, k = /[\x2E\u3002\uFF0E\uFF61]/g, O = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, A = a - f, l = Math.floor, E = String.fromCharCode;
            function M(ct) {
              throw new RangeError(O[ct]);
            }
            function B(ct, ut) {
              for (var V = ct.length, ot = []; V--; )
                ot[V] = ut(ct[V]);
              return ot;
            }
            function X(ct, ut) {
              var V = ct.split("@"), ot = "";
              return V.length > 1 && (ot = V[0] + "@", ct = V[1]), ot + B((ct = ct.replace(k, ".")).split("."), ut).join(".");
            }
            function K(ct) {
              for (var ut, V, ot = [], xt = 0, Ut = ct.length; xt < Ut; )
                (ut = ct.charCodeAt(xt++)) >= 55296 && ut <= 56319 && xt < Ut ? (64512 & (V = ct.charCodeAt(xt++))) == 56320 ? ot.push(((1023 & ut) << 10) + (1023 & V) + 65536) : (ot.push(ut), xt--) : ot.push(ut);
              return ot;
            }
            function D(ct) {
              return B(ct, function(ut) {
                var V = "";
                return ut > 65535 && (V += E((ut -= 65536) >>> 10 & 1023 | 55296), ut = 56320 | 1023 & ut), V += E(ut);
              }).join("");
            }
            function j(ct, ut) {
              return ct + 22 + 75 * (ct < 26) - ((ut != 0) << 5);
            }
            function Z(ct, ut, V) {
              var ot = 0;
              for (ct = V ? l(ct / h) : ct >> 1, ct += l(ct / ut); ct > A * y >> 1; ot += a)
                ct = l(ct / A);
              return l(ot + (A + 1) * ct / (ct + T));
            }
            function tt(ct) {
              var ut, V, ot, xt, Ut, pt, at, bt, Q, At, Pt, q = [], G = ct.length, lt = 0, It = g, Ft = _;
              for ((V = ct.lastIndexOf(S)) < 0 && (V = 0), ot = 0; ot < V; ++ot)
                ct.charCodeAt(ot) >= 128 && M("not-basic"), q.push(ct.charCodeAt(ot));
              for (xt = V > 0 ? V + 1 : 0; xt < G; ) {
                for (Ut = lt, pt = 1, at = a; xt >= G && M("invalid-input"), ((bt = (Pt = ct.charCodeAt(xt++)) - 48 < 10 ? Pt - 22 : Pt - 65 < 26 ? Pt - 65 : Pt - 97 < 26 ? Pt - 97 : a) >= a || bt > l((u - lt) / pt)) && M("overflow"), lt += bt * pt, !(bt < (Q = at <= Ft ? f : at >= Ft + y ? y : at - Ft)); at += a)
                  pt > l(u / (At = a - Q)) && M("overflow"), pt *= At;
                Ft = Z(lt - Ut, ut = q.length + 1, Ut == 0), l(lt / ut) > u - It && M("overflow"), It += l(lt / ut), lt %= ut, q.splice(lt++, 0, It);
              }
              return D(q);
            }
            function nt(ct) {
              var ut, V, ot, xt, Ut, pt, at, bt, Q, At, Pt, q, G, lt, It, Ft = [];
              for (q = (ct = K(ct)).length, ut = g, V = 0, Ut = _, pt = 0; pt < q; ++pt)
                (Pt = ct[pt]) < 128 && Ft.push(E(Pt));
              for (ot = xt = Ft.length, xt && Ft.push(S); ot < q; ) {
                for (at = u, pt = 0; pt < q; ++pt)
                  (Pt = ct[pt]) >= ut && Pt < at && (at = Pt);
                for (at - ut > l((u - V) / (G = ot + 1)) && M("overflow"), V += (at - ut) * G, ut = at, pt = 0; pt < q; ++pt)
                  if ((Pt = ct[pt]) < ut && ++V > u && M("overflow"), Pt == ut) {
                    for (bt = V, Q = a; !(bt < (At = Q <= Ut ? f : Q >= Ut + y ? y : Q - Ut)); Q += a)
                      It = bt - At, lt = a - At, Ft.push(E(j(At + It % lt, 0))), bt = l(It / lt);
                    Ft.push(E(j(bt, 0))), Ut = Z(V, G, ot == xt), V = 0, ++ot;
                  }
                ++V, ++ut;
              }
              return Ft.join("");
            }
            if (r = { version: "1.4.1", ucs2: { decode: K, encode: D }, decode: tt, encode: nt, toASCII: function(ct) {
              return X(ct, function(ut) {
                return b.test(ut) ? "xn--" + nt(ut) : ut;
              });
            }, toUnicode: function(ct) {
              return X(ct, function(ut) {
                return d.test(ut) ? tt(ut.slice(4).toLowerCase()) : ut;
              });
            } }, typeof define != "function")
              if (n && i)
                if (C.exports == n)
                  i.exports = r;
                else
                  for (o in r)
                    r.hasOwnProperty(o) && (n[o] = r[o]);
              else
                v.punycode = r;
          })(this);
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 160: [function(x, C, c) {
      function p(n, i) {
        return Object.prototype.hasOwnProperty.call(n, i);
      }
      C.exports = function(n, i, s, r) {
        i = i || "&", s = s || "=";
        var o = {};
        if (typeof n != "string" || n.length === 0)
          return o;
        var u = /\+/g;
        n = n.split(i);
        var a = 1e3;
        r && typeof r.maxKeys == "number" && (a = r.maxKeys);
        var f = n.length;
        a > 0 && f > a && (f = a);
        for (var y = 0; y < f; ++y) {
          var T, h, _, g, S = n[y].replace(u, "%20"), d = S.indexOf(s);
          d >= 0 ? (T = S.substr(0, d), h = S.substr(d + 1)) : (T = S, h = ""), _ = decodeURIComponent(T), g = decodeURIComponent(h), p(o, _) ? v(o[_]) ? o[_].push(g) : o[_] = [o[_], g] : o[_] = g;
        }
        return o;
      };
      var v = Array.isArray || function(n) {
        return Object.prototype.toString.call(n) === "[object Array]";
      };
    }, {}], 161: [function(x, C, c) {
      var p = function(s) {
        switch (typeof s) {
          case "string":
            return s;
          case "boolean":
            return s ? "true" : "false";
          case "number":
            return isFinite(s) ? s : "";
          default:
            return "";
        }
      };
      C.exports = function(s, r, o, u) {
        return r = r || "&", o = o || "=", s === null && (s = void 0), typeof s == "object" ? n(i(s), function(a) {
          var f = encodeURIComponent(p(a)) + o;
          return v(s[a]) ? n(s[a], function(y) {
            return f + encodeURIComponent(p(y));
          }).join(r) : f + encodeURIComponent(p(s[a]));
        }).join(r) : u ? encodeURIComponent(p(u)) + o + encodeURIComponent(p(s)) : "";
      };
      var v = Array.isArray || function(s) {
        return Object.prototype.toString.call(s) === "[object Array]";
      };
      function n(s, r) {
        if (s.map)
          return s.map(r);
        for (var o = [], u = 0; u < s.length; u++)
          o.push(r(s[u], u));
        return o;
      }
      var i = Object.keys || function(s) {
        var r = [];
        for (var o in s)
          Object.prototype.hasOwnProperty.call(s, o) && r.push(o);
        return r;
      };
    }, {}], 162: [function(x, C, c) {
      c.decode = c.parse = x("./decode"), c.encode = c.stringify = x("./encode");
    }, { "./decode": 160, "./encode": 161 }], 163: [function(x, C, c) {
      Object.defineProperty(c, "__esModule", { value: !0 });
      class p {
        constructor(s, r, o) {
          this.head = -1, this.count = 0, this.sum = 0, this.allcount = 0, this.allsum = 0, this.size = s || 1111, this.duration = r || 6e4, this.clock = o == null ? Date.now : o, this.start = this.clock(), this.vals = new Array(s), this.times = new Array(s), this.head = -1, this.count = 0, this.sum = 0, this.allmin = 0, this.allmax = 0, this.allcount = 0, this.allsum = 0, this.minrate = 0, this.maxrate = 0;
        }
        point(s) {
          if (s == null)
            return;
          let r = this.clock();
          this.head = (this.head + 1) % this.size, this.count === this.size && (this.sum -= this.vals[this.head], this.count--), this.vals[this.head] = s, this.times[this.head] = r, this.count++, this.sum += s, this.allcount++, this.allsum += s, this.allmin = this.allmin == null || s < this.allmin ? s : this.allmin, this.allmax = this.allmax == null || this.allmax < s ? s : this.allmax;
        }
        calculate() {
          let s, r = this.clock(), o = r - this.duration;
          if (0 < this.count) {
            let _ = (this.size + this.head - this.count + 1) % this.size;
            for (s = 0; s++ < this.count && this.times[_] <= o; )
              this.sum -= this.vals[_], this.count--, _ = (_ + 1) % this.size;
          }
          let u, a, f, y = 0 < this.count ? this.sum / this.count : 0, T = 0;
          for (s = 0; s < this.count; s++)
            u = this.vals[(this.size + this.head - s) % this.size], T += Math.pow(u - y, 2), a = a === void 0 || u < a ? u : a, f = f === void 0 || f < u ? u : f;
          let h = 1e3 * this.count / this.duration;
          return this.minrate = this.minrate == null || h < this.minrate ? h : this.minrate, this.maxrate = this.maxrate == null || this.maxrate < h ? h : this.maxrate, { now: r, from: o, start: this.start, count: this.count, sum: this.sum, mean: y, min: a, max: f, stddev: 1 < this.count ? Math.sqrt(T / (this.count - 1)) : 0, rate: h, minrate: this.minrate, maxrate: this.maxrate, allmin: this.allmin, allmax: this.allmax, allcount: this.allcount, allsum: this.allsum, allmean: 0 < this.allcount ? this.allsum / this.allcount : 0, allrate: 1e3 * this.allcount / (r - this.start) };
        }
      }
      function v(i, s, r) {
        let o = /* @__PURE__ */ Object.create(null), u = new p(1, 1).calculate(), a = {};
        return o.point = function(f, y) {
          f == null || y == null || (a[y] = a[y] || new p(i, s, r)).point(f);
        }, o.calculate = function(f) {
          if (f == null) {
            let T = {};
            for (let h in a)
              T[h] = a[h].calculate();
            return T;
          }
          let y = a[f] = a[f] || new p(i, s);
          return y == null ? u : y.calculate();
        }, o.names = function() {
          let f = [];
          for (let y in a)
            f.push(y);
          return f;
        }, o;
      }
      const n = function(i, s, r) {
        return new p(i, s, r);
      };
      n.Stats = p, n.NamedStats = v, c.default = n, typeof C != "undefined" && (C.exports = n);
    }, {}], 164: [function(x, C, c) {
      var p = x("buffer"), v = p.Buffer;
      function n(s, r) {
        for (var o in s)
          r[o] = s[o];
      }
      function i(s, r, o) {
        return v(s, r, o);
      }
      v.from && v.alloc && v.allocUnsafe && v.allocUnsafeSlow ? C.exports = p : (n(p, c), c.Buffer = i), i.prototype = Object.create(v.prototype), n(v, i), i.from = function(s, r, o) {
        if (typeof s == "number")
          throw new TypeError("Argument must not be a number");
        return v(s, r, o);
      }, i.alloc = function(s, r, o) {
        if (typeof s != "number")
          throw new TypeError("Argument must be a number");
        var u = v(s);
        return r !== void 0 ? typeof o == "string" ? u.fill(r, o) : u.fill(r) : u.fill(0), u;
      }, i.allocUnsafe = function(s) {
        if (typeof s != "number")
          throw new TypeError("Argument must be a number");
        return v(s);
      }, i.allocUnsafeSlow = function(s) {
        if (typeof s != "number")
          throw new TypeError("Argument must be a number");
        return p.SlowBuffer(s);
      };
    }, { buffer: 46 }], 165: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = x("util");
          function n(i) {
          }
          C.exports = n, C.exports.preload = function(i) {
            i.options;
            var s = Ge(Ge({}, i.defaults.active), i.options.active);
            this.root.send = function(f) {
              return this.act(f), this;
            }, s.post && (this.root.post = v.promisify(this.act)), s.message && (this.root.message = function(f, y, T) {
              let h = T || y;
              var _ = h == null ? null : function(S, d, b) {
                h.call(this, S, b).then(d).catch(d);
              };
              if (h != null && _ != null) {
                for (var g in h.name != "" && Object.defineProperty(_, "name", { value: h.name }), h)
                  _[g] = h[g];
                p(function() {
                  for (var S in h)
                    _[S] = h[S];
                });
              }
              return T ? this.add(f, y, _) : _ ? this.add(f, _) : this.add(f), this;
            }), s.prepare && (this.root.prepare = function(f) {
              function y(_) {
                return sn(this, null, function* () {
                  return yield f.call(this, _), this.prior(_);
                });
              }
              f.name != "" && Object.defineProperty(y, "name", { value: "prepare_" + f.name });
              const T = this.plugin;
              let h = { role: "seneca", plugin: "init", init: T.name };
              return T.tag != null && T.tag != "-" && (h.tag = T.tag), this.message(h, y), this.plugin.prepare = this.plugin.prepare || [], this.plugin.prepare.push(f), this;
            }), s.destroy && (this.root.destroy = function(f) {
              function y(T) {
                return sn(this, null, function* () {
                  return yield f.call(this, T), this.prior(T);
                });
              }
              return f.name != "" && Object.defineProperty(y, "name", { value: "destroy_" + f.name }), this.message("role:seneca,cmd:close", y), this.plugin.destroy = this.plugin.destroy || [], this.plugin.destroy.push(f), this;
            });
            const r = this.root.prior, o = v.promisify(this.root.prior);
            s.prior && (this.root.prior = function() {
              return sn(this, arguments, function* () {
                return 1 < arguments.length && typeof arguments[arguments.length - 1] == "function" ? r.apply(this, arguments) : yield o.apply(this, arguments);
              });
            });
            const u = this.root.ready, a = v.promisify(this.root.ready);
            s.ready && (this.root.ready = function() {
              return sn(this, arguments, function* () {
                return 0 < arguments.length && typeof arguments[arguments.length - 1] == "function" ? u.apply(this, arguments) : (yield a.apply(this, arguments), this);
              });
            }), this.root.__promisify$$ = !0;
          }, n.defaults = { active: { post: !0, message: !0, prepare: !0, destroy: !0, prior: !0, ready: !0 } };
        }).call(this);
      }).call(this, x("timers").setImmediate);
    }, { timers: 228, util: 238 }], 166: [function(x, C, c) {
      Object.defineProperty(c, "__esModule", { value: !0 });
      const p = x("./meta"), v = x("./common");
      c.api_act = function() {
        const i = this.options(), s = (0, v.build_message)(this, [...arguments], "reply:f?", this.fixedargs), r = s.msg, o = s.reply;
        return (i.debug.act_caller || i.test) && (r.caller$ = `
    Action call arguments and location: ` + (new Error((0, v.msgstr)(r, i.debug.datalen)).stack + `
`).replace(/Error: /, "").replace(/.*\/gate-executor\.js:.*\n/g, "").replace(/.*\/seneca\.js:.*\n/g, "").replace(/.*\/seneca\/lib\/.*\.js:.*\n/g, "")), n.do_act(this, i, r, o), this;
      };
      const n = C.exports.intern = { do_act: function(i, s, r, o) {
        let u = !1;
        const a = n.make_actmsg(r), f = new p.Meta(i, s, r, o);
        f.gate && ((i = i.delegate()).private$.ge = i.private$.ge.gate());
        const y = { seneca: i, origmsg: r, reply: o || v.noop, options: i.options(), callpoint: i.private$.callpoint() }, T = {};
        T.dn = f.id, T.fn = function(h) {
          const _ = (g, S, d) => {
            u || n.handle_reply(s, f, y, a, g, S, d), h();
          };
          try {
            n.execute_action(T, i, s, y, a, f, _);
          } catch (g) {
            if (!s.error.capture.action || (g == null ? void 0 : g.$$seneca_callback_error$$) === !0)
              throw g;
            {
              const S = (0, v.isError)(g) ? g : new Error((0, v.inspect)(g));
              n.handle_reply(s, f, y, a, S), h();
            }
          }
        }, T.ontm = function(h, _, g) {
          u = !0;
          const S = (0, v.error)("action_timeout", { timeout: h, start: _, end: g, message: a, pattern: T.ctxt.pattern, legacy_string: y.options.legacy.timeout_string ? "[TIMEOUT] " : "" });
          n.handle_reply(s, f, y, a, S);
        }, T.tm = f.timeout, i.private$.ge.add(T);
      }, make_actmsg: function(i) {
        const s = Object.assign({}, i);
        return s.id$ != null && delete s.id$, s.caller$ != null && delete s.caller$, s.meta$ != null && delete s.meta$, s.prior$ != null && delete s.prior$, s.parents$ != null && delete s.parents$, i.transport$ != null && (s.transport$ = i.transport$), s;
      }, handle_reply: function(i, s, r, o, u, a, f) {
        s.end = Date.now();
        const y = r.seneca, T = r.reply, h = { meta: s, msg: o, res: u || a, reply_meta: f, has_callback: !0, err: u || null, out: a || null };
        if (r.duration = s.end - s.start, r.actlog = n.actlog, r.errlog = n.errlog, r.error = v.error, s.error = (0, v.isError)(h.res), s.error || h.res !== h.err || (h.err = null), s.explain && f && f.explain && s.explain.length < f.explain.length)
          for (let _ = s.explain.length; _ < f.explain.length; _++)
            s.explain.push(f.explain[_]);
        if (n.process_outward(r, h), h.has_callback)
          try {
            i.legacy.meta_arg_remove ? T.call(y, h.err, h.res) : T.call(y, h.err, h.res, h.meta);
          } catch (_) {
            if (!i.error.capture.callback)
              throw typeof _ == "object" && (_.$$seneca_callback_error$$ = !0), _;
            n.callback_error(y, _, r, h);
          }
      }, errlog: v.make_standard_err_log_entry, actlog: v.make_standard_act_log_entry, process_outward: function(i, s) {
        const r = i.seneca.order.outward.execSync(i, s);
        if (r.err)
          throw r.err;
        const o = r.data;
        if (o.kind != null) {
          if (o.code === "sub_outward_action_failed") {
            const u = Ge({ pattern: i.actdef.pattern, msg: s.msg }, o.info || {});
            s.err = (0, v.error)(o.error, o.code, u);
          } else
            s.err = o.error || (0, v.error)(o.code || "invalid-process-outward-code", o.info || {});
          s.meta = s.meta || {}, s.meta.error = !0;
        }
      }, execute_action: function(i, s, r, o, u, a, f) {
        const y = s.private$, T = a.prior ? y.actdef[a.prior] : s.find(u), h = n.make_act_delegate(s, r, a, T);
        o.seneca = h, o.actdef = T, i.ctxt.pattern = T ? T.pattern : null;
        const _ = { meta: a, msg: u, reply: f }, g = s.order.inward.execSync(o, _);
        if (g.err)
          throw g.err;
        const S = g.data;
        n.handle_inward_break(S, s, _, T, o.origmsg) || (T.sub || h.log.debug(n.actlog(T, u, a, o.origmsg, { kind: "act", case: "IN", did: h.did })), _.id = _.meta.id, _.result = [], _.timelimit = Date.now() + _.meta.timeout, r.history.active && y.history.add(_), r.legacy.meta && (_.msg.meta$ = a), r.legacy.meta_arg_remove ? T.func.call(h, _.msg, _.reply) : T.func.call(h, _.msg, _.reply, _.meta));
      }, make_act_delegate: function(i, s, r, o) {
        r = r || {};
        const u = { plugin$: { full: (o = o || {}).plugin_fullname, name: o.plugin_name, tag: o.plugin_tag } }, a = i.delegate(u), f = i.private$.act || r.parent;
        return a.private$.act = { parent: f && f.meta, meta: r, def: o }, r.tx && (a.fixedargs.tx$ = r.tx), a;
      }, handle_inward_break: function(i, s, r, o, u) {
        if (!i)
          return !1;
        const a = r.msg, f = r.reply, y = r.meta;
        if (i.kind === "error") {
          let T = i.error;
          if (i.code === "sub_inward_action_failed") {
            const h = Ge({ pattern: o.pattern, msg: r.msg }, i.info || {});
            T = (0, v.error)(T, i.code, h);
          } else
            T = T || (0, v.error)(i.code, i.info);
          return y.error = !0, i.log && i.log.level && s.log[i.log.level](n.errlog(T, n.errlog(o || {}, y.prior))), f.call(s, T), !0;
        }
        return i.kind === "result" ? (i.log && i.log.level && s.log[i.log.level](n.actlog(o || {}, a, y, u, i.log.data)), f.call(s, null, i.result), !0) : void 0;
      }, callback_error: function(i, s, r, o) {
        const u = r.duration, a = r.callpoint, f = r.actdef || {}, y = r.origmsg, T = r.reply, h = o.meta, _ = o.msg;
        let g = (0, v.isError)(s) ? s : new Error((0, v.inspect)(s));
        const S = i.options();
        g.seneca || (g = (0, v.error)(g, "act_callback", (0, v.deep)({}, g.details, { message: g.message, pattern: f.pattern, fn: f.func, callback: T, instance: i.toString(), callpoint: a }))), i.log.error(n.actlog(f, _, h, y, { kind: "act", case: "ERR", info: g.message, code: g.code, err: g, duration: u, did: i.did })), i.emit("act-err", _, g, o.res), S.errhandler && S.errhandler.call(i, g, g.meta$);
      } };
    }, { "./common": 170, "./meta": 175 }], 167: [function(x, C, c) {
      Object.defineProperty(c, "__esModule", { value: !0 }), c.addActions = void 0;
      const p = x("./legacy"), v = x("./common");
      function n(f) {
        f.stats = u(f.private$), f.add("sys:seneca,on:point", i), f.add({ role: "seneca", cmd: "ping" }, s), f.add({ role: "seneca", cmd: "stats" }, f.stats), f.add({ role: "seneca", cmd: "close" }, o), f.add({ role: "seneca", info: "fatal" }, r), f.add({ role: "seneca", get: "options" }, a);
      }
      function i(f, y) {
        y();
      }
      function s(f, y) {
        y(this.ping());
      }
      function r(f, y) {
        y();
      }
      function o(f, y) {
        this.emit("close"), y();
      }
      function u(f) {
        return function(y, T) {
          var h;
          return y = y || {}, f.stats.actmap[y.pattern] ? (h = f.stats.actmap[y.pattern]).time = f.timestats.calculate(y.pattern) : ((h = Object.assign({}, f.stats)).now = /* @__PURE__ */ new Date(), h.uptime = h.now - h.start, h.now = new Date(h.now).toISOString(), h.start = new Date(h.start).toISOString(), y.summary == null || v.boolify(y.summary) ? h.actmap = void 0 : Object.keys(f.stats.actmap).forEach((_) => {
            f.stats.actmap[_].time = f.timestats.calculate(_);
          })), T && T(h), h;
        };
      }
      function a(f, y) {
        var T = this.options(), h = f.base || null, _ = h ? T[h] || {} : T, g = f.key ? _[f.key] : _;
        y(p.Legacy.copydata(g));
      }
      c.addActions = n;
    }, { "./common": 170, "./legacy": 173 }], 168: [function(x, C, c) {
      (function(p) {
        (function() {
          Object.defineProperty(c, "__esModule", { value: !0 }), c.task = c.api_add = void 0;
          const v = x("gubu"), n = x("./common"), i = x("jsonic");
          function s() {
            let u = { opts: this.options(), args: (0, n.parsePattern)(this, arguments, "action:f? actdef:o?"), private: this.private$, instance: this }, a = this.order.add.execSync(u, { actdef: null, pattern: null, action: null, strict_add: null, addroute: null });
            if (a.err)
              throw a.err;
            return this;
          }
          c.api_add = s;
          const r = { prepare(u) {
            const a = u.ctx.args;
            let f = a.pattern, y = (0, n.clean)(f), T = a.action || function(_, g, S) {
              S ? g.call(this, null, S.dflt || null, S) : g.call(this, null, null);
            }, h = (0, n.deep)(a.actdef) || {};
            return h.raw = (0, n.deep)({}, f), { op: "merge", out: { actdef: h, action: T, pattern: y } };
          }, plugin(u) {
            const a = u.data.actdef;
            return a.plugin_name = a.plugin_name || "root$", a.plugin_fullname = a.plugin_fullname || a.plugin_name + (a.plugin_tag !== "-" && a.plugin_tag ? "$" + a.plugin_tag : ""), a.plugin = { name: a.plugin_name, tag: a.plugin_tag, fullname: a.plugin_fullname }, { op: "merge", out: { actdef: a } };
          }, callpoint(u) {
            const a = u.ctx.private, f = u.data.actdef;
            let y = a.callpoint();
            return y && (f.callpoint = y), { op: "merge", out: { actdef: f } };
          }, flags(u) {
            const a = u.data.actdef, f = u.data.pattern, y = u.ctx.opts;
            a.sub = !!a.raw.sub$, a.client = !!a.raw.client$, a.deprecate = a.raw.deprecate$, a.fixed = i(a.raw.fixed$ || {}), a.custom = i(a.raw.custom$ || {});
            var T = a.raw.strict$ && a.raw.strict$.add !== null ? !!a.raw.strict$.add : !!y.strict.add;
            return y.legacy.actdef && (a.args = (0, n.deep)(f)), a.pattern = (0, n.pattern)(f), a.msgcanon = i(a.pattern), a.pattern = (0, n.pattern)(f), a.msgcanon = i(a.pattern), { op: "merge", out: { actdef: a, strict_add: T } };
          }, action(u) {
            const a = u.data.actdef, f = u.data.action, y = u.ctx.private;
            var T = f.name == null || f.name === "" ? "action" : f.name;
            return a.id = T + "_" + y.next_action_id(), a.name = T, a.func = f, typeof f.handle == "function" && (a.handle = f.handle), { op: "merge", out: { actdef: a } };
          }, prior(u) {
            const a = u.data.actdef, f = u.data.pattern, y = u.data.strict_add;
            let T = !0;
            var h = u.ctx.instance.find(f);
            return h && y && h.pattern !== a.pattern && (h = null), h ? (typeof h.handle == "function" && (h.client && a.client || !h.client && !a.client) ? (h.handle(a), T = !1) : a.priordef = h, a.priorpath = h.id + ";" + h.priorpath) : a.priorpath = "", { op: "merge", out: { actdef: a, addroute: T } };
          }, rules(u) {
            const a = u.ctx.opts, f = u.data.actdef, y = u.data.pattern;
            let T = {}, h = !1, _ = 0;
            return (0, n.each)(f.raw, function(g, S) {
              g == null || typeof g != "object" && typeof g != "function" || ~S.indexOf("$") || (T[S] = g, _++, delete y[S], g.$_root && (h = !0));
            }), f.rules = T, !a.legacy.rules && !h && 0 < _ && (f.gubu = (0, v.Gubu)((0, v.Open)(T))), { op: "merge", out: { actdef: f } };
          }, register(u) {
            const a = u.data.actdef, f = u.data.pattern, y = u.data.addroute, T = u.ctx.private, h = u.ctx.instance;
            return y && (h.log.debug({ kind: "add", case: a.sub ? "SUB" : "ADD", action: a.id, pattern: a.pattern, callpoint: T.callpoint(!0) }), T.actrouter.add(f, a)), T.stats.actmap[a.pattern] = T.stats.actmap[a.pattern] || o.make_action_stats(a), T.actdef[a.id] = a, { op: "next" };
          }, modify(u) {
            const a = u.data.actdef, f = u.ctx.instance;
            return o.deferred_modify_action(f, a), { op: "next" };
          } };
          c.task = r;
          const o = C.exports.intern = { make_action_stats: function(u) {
            return { id: u.id, plugin: { full: u.plugin_fullname, name: u.plugin_name, tag: u.plugin_tag }, prior: u.priorpath, calls: 0, done: 0, fails: 0, time: {} };
          }, deferred_modify_action: function(u, a) {
            p(function() {
              (0, n.each)(u.private$.action_modifiers, function(f) {
                f.call(u, a);
              });
            });
          } };
        }).call(this);
      }).call(this, x("timers").setImmediate);
    }, { "./common": 170, gubu: 102, jsonic: 119, timers: 228 }], 169: [function(x, C, c) {
      (function(p) {
        (function() {
          Object.defineProperty(c, "__esModule", { value: !0 }), c.API = void 0;
          var v = x("jsonic"), n = x("norma"), i = x("./common"), s = i.make_standard_err_log_entry, r = {};
          function o(at, bt, Q) {
            var At = this;
            return Q = typeof bt == "function" ? bt : Q, bt = typeof bt == "function" ? {} : bt, at = Array.isArray(at) ? at : [at], i.each(at, function(Pt) {
              i.each(At.list(Pt), function(q) {
                At.add(q, Q, bt);
              });
            }), this;
          }
          function u(at, bt, Q) {
            var At = this;
            at = v(at || {});
            var Pt = At.delegate(at);
            return Pt.add = function() {
              return At.add.apply(this, r.fix_args(arguments, at, bt, Q));
            }, Pt.sub = function() {
              return At.sub.apply(this, r.fix_args(arguments, at, bt, Q));
            }, Pt;
          }
          function a(at, bt) {
            var Q = this.private$;
            if (at == null)
              return Q.optioner.get();
            this.log && this.log.debug({ kind: "options", case: "SET", data: at });
            var At = Q.exports.options = Q.optioner.set(at);
            if (typeof at.tag == "string") {
              var Pt = this.root.tag;
              this.root.tag = at.tag, this.root.id = this.root.id.substring(0, this.root.id.indexOf("/" + Pt)) + "/" + at.tag;
            }
            if (at.log) {
              var q = Q.logging.build_log(this);
              At = Q.exports.options = Q.optioner.set({ log: q });
            }
            if (At.debug.callpoint && (Q.callpoint = i.make_callpoint(At.debug.callpoint)), At.legacy.logging && at && at.log && Array.isArray(at.log.map))
              for (var G = 0; G < at.log.map.length; ++G)
                this.logroute(at.log.map[G]);
            return bt ? this : At;
          }
          function f(at) {
            return function(bt) {
              return bt !== !1 && bt == null ? i.promiser(r.close.bind(this, at)) : r.close.call(this, at, bt);
            };
          }
          function y() {
            return this.fullname;
          }
          function T() {
            return this;
          }
          function h(at) {
            if (at === !0)
              return this.private$.explain = [];
            if (at === !1) {
              var bt = this.private$.explain;
              return delete this.private$.explain, bt;
            }
          }
          function _(at) {
            if (typeof at == "function")
              return this.options({ errhandler: at }), this;
            if (at == null)
              throw this.util.error("no_error_code");
            var bt = this.fixedargs && this.fixedargs.plugin$ && this.fixedargs.plugin$.full, Q = bt != null ? this.private$.plugins[bt] : this.context.plugin;
            return Q && Q.eraro && Q.eraro.has(at) ? Q.eraro.apply(this, arguments) : i.eraro.apply(this, arguments);
          }
          function g(...at) {
            if (at.length <= 2)
              return bt(this, !0, at[0], at[1]);
            if (at.length === 3)
              return bt(this, at[0], at[1], at[2]);
            throw this.util.error("fail_wrong_number_of_args", { num_args: at.length });
            function bt(Q, At, Pt, q) {
              if (typeof At != "boolean")
                throw Q.util.error("fail_cond_must_be_bool");
              if (!At)
                return;
              const G = Q.error(Pt, q);
              if (q && q.throw$ === !1)
                return G;
              throw G;
            }
          }
          function S() {
            var at = n("inward:f", arguments);
            return this.root.order.inward.add(at.inward), this;
          }
          function d() {
            var at = n("outward:f", arguments);
            return this.root.order.outward.add(at.outward), this;
          }
          function b(at, bt) {
            var Q = this, At = this.root, Pt = this.options();
            at = at || {}, bt = bt || {};
            var q, G = Object.create(Q);
            function lt() {
              return At.log.apply(G, arguments);
            }
            G.private$ = Object.create(Q.private$), G.did = (G.did ? G.did + "/" : "") + Q.private$.didnid(), Object.assign(lt, At.log), lt.self = () => G;
            var It = Pt.strict.fixedargs ? Object.assign({}, at, Q.fixedargs) : Object.assign({}, Q.fixedargs, at), Ft = Pt.strict.fixedmeta ? Object.assign({}, bt, Q.fixedmeta) : Object.assign({}, Q.fixedmeta, bt), H = Object.assign({}, Q.context);
            return Object.defineProperties(G, { log: { value: lt, writable: !0 }, toString: { value: function() {
              if (q)
                return q;
              var F = {};
              return Object.keys(at).forEach((P) => {
                var U = at[P];
                ~P.indexOf("$") || (F[P] = U);
              }), q = Q.toString() + (Object.keys(F).length ? "/" + v.stringify(F) : "");
            }, writable: !0 }, fixedargs: { value: It, writable: !0 }, fixedmeta: { value: Ft, writable: !0 }, delegate: { value: function(F, P) {
              var U = Object.assign({}, G.fixedargs, F || {}), rt = Object.assign({}, G.fixedmeta, P || {});
              return Q.delegate.call(this, U, rt);
            }, writable: !0 }, context: { value: H, writable: !0 } }), G;
          }
          function k() {
            for (var at = this.private$, bt = this.util.error, Q = n("{pluginname:s deps:a? moredeps:s*}", arguments), At = Q.deps || Q.moredeps || [], Pt = 0; Pt < At.length; Pt++) {
              var q = At[Pt];
              if (!at.plugin_order.byname.includes(q) && !at.plugin_order.byname.includes("seneca-" + q)) {
                this.die(bt("plugin_required", { name: Q.pluginname, dependency: q }));
                break;
              }
            }
          }
          function O(at) {
            var bt = this.private$, Q = this.util.error, At = this.options();
            at === "util" && (at = "basic");
            var Pt = bt.exports[at];
            return !Pt && At.strict.exports ? this.die(Q("export_not_found", { key: at })) : Pt;
          }
          function A(at) {
            return at = at || {}, this.options({ test: !1, quiet: !0, log: "none", reload$: !0 }).test && at.from !== "test" ? this.test() : (this.private$.logging.build_log(this), this);
          }
          function l(at, bt) {
            var Q = this.options();
            Q.tag != "-" && (this.root.id = Q.id$ == null ? this.private$.actnid().substring(0, 4) + "/" + Q.tag : "" + Q.id$), typeof at != "function" && at !== null && (bt = at, at = null);
            var At = { errhandler: at == null ? null : at, test: !0, quiet: !1, reload$: !0, log: (bt = bt === !0 || bt === "true" ? "test" : bt) || "test", debug: { callpoint: !0 } };
            return this.options(At).quiet ? this.quiet({ from: "test" }) : (this.private$.logging.build_log(this), this.private$.logger.from_options$ || (this.root.private$.logger = this.private$.logging.test_logger), this);
          }
          function E() {
            var at = Date.now();
            return { now: at, uptime: at - this.private$.stats.start, id: this.id, cpu: p.cpuUsage(), mem: p.memoryUsage(), act: this.private$.stats.act, tr: this.private$.transport.register.map(function(bt) {
              return Object.assign({ when: bt.when, err: bt.err }, bt.config);
            }) };
          }
          function M(at, bt, Q) {
            var At = typeof at == "string" ? v(at) : at, Pt = typeof bt == "string" ? v(bt) : bt, q = {};
            return typeof Q == "string" && (Q = Q.split(/\s*,\s*/)), Array.isArray(Q) ? Q.forEach(function(G) {
              G.startsWith("-") ? q[G.substring(1)] = !1 : q[G] = !0;
            }) : q = Q && typeof Q == "object" ? Object.assign({}, Q) : null, this.add(At, function(G, lt) {
              var It;
              q ? (It = {}, Object.keys(q).forEach(function(H) {
                q[H] && (It[H] = G[H]);
              })) : It = this.util.clean(G);
              var Ft = Object.assign(It, Pt);
              this.act(Ft, lt);
            }), this;
          }
          function B() {
            return this.delegate({ gate$: !0 });
          }
          function X() {
            return this.fixedargs.gate$ = !1, this;
          }
          function K() {
            return Object.assign({}, this.private$.plugins);
          }
          function D(at, bt) {
            var Q = i.make_plugin_key(at, bt);
            return this.private$.plugins[Q];
          }
          function j(at, bt) {
            var Q = i.make_plugin_key(at, bt);
            return !!this.private$.plugins[Q];
          }
          function Z(at, bt, Q) {
            typeof bt == "boolean" && (Q = bt, bt = null);
            var At = i.make_plugin_key(at, bt), Pt = this.private$.ignore_plugins[At] = Q == null || !!Q;
            return this.log.info({ kind: "plugin", case: "ignore", full: At, ignore: Pt }), this;
          }
          function tt(at, bt) {
            var Q = typeof at == "string" ? v(at) : at;
            Q = (Q = this.util.clean(Q)) || {};
            var At = this.private$.actrouter.find(Q, bt && bt.exact);
            return At || (At = this.private$.actrouter.find({})), At;
          }
          function nt(at) {
            return !!this.find(at, { exact: !0 });
          }
          function ct(at) {
            return this.private$.actrouter.list(at == null ? {} : v(at)).map((bt) => bt.match);
          }
          function ut(at) {
            at = at || {};
            var bt = this.private$.history.stats();
            return bt.log = this.private$.history.list(), { stats: this.stats(at.stats), history: bt, transport: this.private$.transport };
          }
          function V(at) {
            var bt = null;
            return at && at.meta && (bt = this.private$.history.get(at.meta.id)) && bt.reply(at.err, at.out, at.meta), !!bt;
          }
          function ot(at) {
            return function(...bt) {
              var Q = this.private$, At = this, Pt = bt[bt.length - 1];
              typeof Pt == "function" ? bt.pop() : Pt = () => {
              }, At.log.info({ kind: "listen", case: "INIT", data: bt, callpoint: at(!0) });
              var q = At.options().transport || {}, G = r.resolve_config(r.parse_config(bt), q);
              return At.act("role:transport,cmd:listen", { config: G, gate$: !0 }, function(lt, It) {
                if (lt)
                  return At.die(Q.error(lt, "transport_listen", G));
                Pt(null, It), Pt = () => {
                };
              }), At;
            };
          }
          function xt(at) {
            return function() {
              var bt = this.private$, Q = Array.prototype.slice.call(arguments);
              this.log.info({ kind: "client", case: "INIT", data: Q, callpoint: at(!0) });
              var At = this.options().legacy || {}, Pt = this.options().transport || {}, q = r.parse_config(Q);
              q.pg = i.pincanon(q.pin || q.pins);
              var G = r.resolve_config(q, Pt);
              G.id = G.id || i.pattern(q);
              var lt = G.pins || (Array.isArray(G.pin) ? G.pin : [G.pin || ""]);
              lt = lt.map((F) => typeof F == "string" ? v(F) : F);
              var It, Ft = this.order.plugin.task.delegate.exec({ ctx: { seneca: this }, data: { plugin: { name: "seneca_internal_client", tag: void 0 } } }).out.delegate, H = function(F, P, U) {
                At.meta && (U = U || F.meta$), U.local ? this.prior(F, P) : It && It.send ? (At.meta && (F.meta$ = U), It.send.call(this, F, P, U)) : this.log.error("no-transport-client", { config: G, msg: F });
              };
              return H.id = G.id, G.makehandle && (H.handle = G.makehandle(G)), lt.forEach((F) => {
                F = Object.assign({}, F), G.override && Ft.wrap(Ft.util.clean(F), { client_pattern: Ft.util.pattern(F) }, H), F.client$ = !0, F.strict$ = { add: !0 }, Ft.add(F, H);
              }), Ft.act("role:transport,cmd:client", { config: G, gate$: !0 }, function(F, P) {
                return F ? Ft.die(bt.error(F, "transport_client", G)) : P == null ? Ft.die(bt.error("transport_client_null", i.clean(G))) : void (It = P);
              }), this;
            };
          }
          function Ut() {
            var at = n("property:s value:.", arguments), bt = at.property;
            if (bt[0] === "_")
              throw new Error("property cannot start with _");
            if (this.private$.decorations[bt])
              throw new Error("seneca is already decorated with the property: " + bt);
            if (this.root[bt])
              throw new Error("cannot override a core seneca property: " + bt);
            this.root[bt] = this.private$.decorations[bt] = at.value;
          }
          r.parse_config = function(at) {
            var bt = {}, Q = at.filter((Pt) => Pt != null), At = Q.length;
            return At === 1 ? Q[0] && typeof Q[0] == "object" ? bt = Object.assign({}, Q[0]) : bt.port = parseInt(Q[0], 10) : At === 2 ? (bt.port = parseInt(Q[0], 10), bt.host = Q[1]) : At === 3 && (bt.port = parseInt(Q[0], 10), bt.host = Q[1], bt.path = Q[2]), bt;
          }, r.resolve_config = function(at, bt) {
            var Q = Object.assign({}, at);
            Object.keys(bt).forEach((Pt) => {
              var q = bt[Pt];
              q && typeof q == "object" || (Q[Pt] = Q[Pt] === void 0 ? q : Q[Pt]);
            }), Q.type = Q.type || "web", Q.type !== "direct" && Q.type !== "http" || (Q.type = "web");
            var At = bt[Q.type] || {};
            return (Q = Object.assign({}, At, Q)).type !== "web" && Q.type !== "tcp" || (Q.port = Q.port == null ? At.port : Q.port, Q.host = Q.host == null ? At.host : Q.host, Q.path = Q.path == null ? At.path : Q.path), Q;
          }, r.close = function(at, bt) {
            var Q = this, At = Q.options(), Pt = !1, q = function(It) {
              if (!Pt && typeof bt == "function")
                return Pt = !0, bt.call(Q, It);
            };
            if (Q.flags.closed)
              return q();
            Q.ready(lt);
            var G = setTimeout(lt, At.close_delay);
            function lt() {
              if (clearTimeout(G), Q.flags.closed)
                return q();
              Q.closed = !0, Q.flags.closed = !0, i.each(At.system.close_signals, function(It, Ft) {
                It && p.removeListener(Ft, Q.private$.exit_close);
              }), Q.log.debug({ kind: "close", notice: "start", callpoint: at(!0) }), Q.act("role:seneca,cmd:close,closing$:true", function(It) {
                return Q.log.debug(s(It, { kind: "close", notice: "end" })), Q.removeAllListeners("act-in"), Q.removeAllListeners("act-out"), Q.removeAllListeners("act-err"), Q.removeAllListeners("pin"), Q.removeAllListeners("after-pin"), Q.removeAllListeners("ready"), Q.private$.history.close(), Q.private$.status_interval && clearInterval(Q.private$.status_interval), q(It);
              });
            }
            return Q;
          }, r.fix_args = function(at, bt, Q, At) {
            var Pt = i.parsePattern(this, at, "rest:.*", bt);
            return [Pt.pattern].concat({ fixed$: Object.assign({}, Q, Pt.pattern.fixed$), custom$: Object.assign({}, At, Pt.pattern.custom$) }).concat(Pt.rest);
          };
          let pt = { wrap: o, fix: u, options: a, close: f, toString: y, seneca: T, explain: h, error: _, fail: g, inward: S, outward: d, delegate: b, depends: k, export: O, quiet: A, test: l, ping: E, translate: M, gate: B, ungate: X, list_plugins: K, find_plugin: D, has_plugin: j, ignore_plugin: Z, find: tt, has: nt, list: ct, status: ut, reply: V, listen: ot, client: xt, decorate: Ut };
          c.API = pt;
        }).call(this);
      }).call(this, x("_process"));
    }, { "./common": 170, _process: 158, jsonic: 119, norma: 133 }], 170: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = this && this.__importDefault || function(Q) {
            return Q && Q.__esModule ? Q : { default: Q };
          };
          Object.defineProperty(c, "__esModule", { value: !0 }), c.TRACE_ACTION = c.TRACE_SYNC = c.TRACE_END = c.TRACE_START = c.TRACE_VERSION = c.TRACE_TAG = c.TRACE_INSTANCE = c.TRACE_ID = c.TRACE_PATTERN = c.msgstr = c.error = c.inspect = c.isError = c.tagnid = c.parsePattern = c.print = c.history = c.make_trace_desc = c.make_callpoint = c.autoincr = c.resolve_option = c.make_standard_err_log_entry = c.make_standard_act_log_entry = c.makedie = c.each = c.deep = c.clean = c.noop = c.pincanon = c.pattern = c.build_message = c.parse_pattern = c.parse_jsonic = c.boolify = c.make_plugin_key = c.wrap_error = c.stringify = c.promiser = void 0;
          const n = v(x("util")), i = v(x("./errors")), s = x("fast-safe-stringify"), r = x("eraro"), o = x("jsonic"), u = v(x("nid")), a = x("norma"), f = x("lodash.defaultsdeep"), { Print: y } = x("./print"), T = c.error = c.eraro = r({ package: "seneca", msgmap: i.default, override: !0 });
          function h(Q, At) {
            return At = typeof Q == "function" && At == null ? Q : At.bind(Q), new Promise((Pt, q) => {
              At((G, lt) => G ? q(G) : Pt(lt));
            });
          }
          function _() {
            return s(...arguments);
          }
          function g(Q) {
            throw Q.seneca ? Q : T.call(null, ...arguments);
          }
          function S(Q, At) {
            if (Q == null)
              throw T("missing_plugin_name");
            let Pt = Q.name == null ? Q : Q.name, q = Q.tag == null ? At == null ? "" : At : Q.tag;
            if (typeof Pt == "number" && (Pt = "" + Pt), typeof q == "number" && (q = "" + q), Pt == "" || typeof Pt != "string")
              throw T("bad_plugin_name", { name: Pt });
            let G = Pt.match(/^([a-zA-Z@][a-zA-Z0-9.~_\-/]*)\$([a-zA-Z0-9.~_-]+)$/);
            if (G && (Pt = G[1], q = G[2]), !Pt.match(/^(\.|\/|\\|\w:)/) && (!Pt.match(/^[a-zA-Z@][a-zA-Z0-9.~_\-/]*$/) || 1024 < Pt.length))
              throw T("bad_plugin_name", { name: Pt });
            if (q != "" && (!q.match(/^[a-zA-Z0-9.~_-]+$/) || 1024 < q.length))
              throw T("bad_plugin_tag", { tag: q });
            return Pt + (q ? "$" + q : "");
          }
          function d(Q) {
            try {
              return !!JSON.parse(Q);
            } catch (At) {
              return !1;
            }
          }
          c.error = T, c.promiser = h, c.stringify = _, c.wrap_error = g, c.make_plugin_key = S, c.boolify = d;
          const b = (0, u.default)({ length: 3, alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
          function k(Q, At) {
            At = At || "bad_jsonic";
            try {
              return Q == null ? null : o(Q);
            } catch (Pt) {
              let q = Pt.line === 1 ? Pt.column - 1 : Pt.column;
              throw T(At, { argstr: Q, syntax: Pt.message, line: Pt.line, col: q });
            }
          }
          function O(Q, At, Pt, q) {
            let G = a("{strargs:s? objargs:o? moreobjargs:o? " + (Pt || "") + "}", At);
            return G.pattern = Object.assign({}, G.moreobjargs ? G.moreobjargs : null, G.objargs ? G.objargs : null, k(G.strargs, "add_string_pattern_syntax"), q), G;
          }
          c.tagnid = b, c.parse_jsonic = k, c.parse_pattern = O;
          const A = O;
          function l(Q, At, Pt, q) {
            let G = a("{strargs:s? objargs:o? moreobjargs:o? " + (Pt || "") + "}", At);
            return G.msg = Object.assign({}, G.moreobjargs, G.objargs, k(G.strargs, "msg_jsonic_syntax"), q), G;
          }
          function E(Q) {
            if (typeof Q == "string")
              return Q;
            Q = Q || {};
            let At = [];
            return Object.keys(Q).forEach((Pt) => {
              let q = Q[Pt];
              ~Pt.indexOf("$") || typeof q == "function" || typeof q == "object" || At.push(Pt + ":" + q);
            }), At.sort(), At.join(",");
          }
          function M(Q) {
            if (typeof Q == "string")
              return E(o(Q));
            if (Array.isArray(Q)) {
              let At = Q.map(M);
              return At.sort(), At.join(";");
            }
            return E(Q);
          }
          function B() {
          }
          function X(Q, At) {
            if (Q == null)
              return Q;
            let Pt = Array.isArray(Q) ? [] : {}, q = Object.getOwnPropertyNames(Q);
            for (let G = 0; G < q.length; G++) {
              let lt = q[G];
              lt[lt.length - 1] != "$" && (Pt[lt] = Q[lt]);
            }
            return Pt;
          }
          function K(...Q) {
            return (Q = Q.reverse()).unshift({}), f.apply(null, Q);
          }
          c.parsePattern = A, c.build_message = l, c.pattern = E, c.pincanon = M, c.noop = B, c.clean = X, c.deep = K;
          const D = y.print;
          function j(Q, At) {
            return Q == null || At == null ? null : Array.isArray(Q) ? Q.forEach(At) : void Object.keys(Q).forEach((Pt) => At(Q[Pt], Pt));
          }
          function Z(Q, At) {
            At = Object.assign(At, Q.die ? Q.die.context : {});
            let Pt = 0, q = function(G) {
              let lt = Q.options(), It = lt.test, Ft = lt.debug && lt.debug.undead || G && G.undead, H = lt.debug && lt.debug.print && lt.debug.print.fatal === "full" || !1, F = lt.debug && lt.debug.print.env || !1;
              if (0 < Pt) {
                if (!Ft)
                  throw T(G, "[DEATH LOOP] die count: " + Pt);
              } else {
                Pt++;
                try {
                  G ? n.default.isError(G) || (G = new Error(typeof G == "string" ? G : ot(G))) : G = new Error("unknown"), G.fatal$ = !0;
                  let P = { kind: At.txt || "fatal", level: At.level || "fatal", plugin: At.plugin, tag: At.tag, id: At.id, code: G.code || "fatal", notice: G.message, err: G, callpoint: At.callpoint && At.callpoint() };
                  Q.log.fatal(P);
                  let U = G.stack || "";
                  U = U.substring(U.indexOf(`
`) + 5).replace(/\n\s+/g, `
               `);
                  let rt = "pid=" + p.pid + ", arch=" + p.arch + ", platform=" + p.platform + (H ? ", path=" + p.execPath : "") + ", argv=" + ot(p.argv).replace(/\n/g, "") + (H && F ? ", env=" + ot(p.env).replace(/\n/g, "") : ""), ft = /* @__PURE__ */ new Date(), Ot = null, Wt = `

=== SENECA FATAL ERROR ===
MESSAGE   :::  ` + G.message + `
CODE      :::  ` + G.code + `
INSTANCE  :::  ` + Q.toString() + `
DETAILS   :::  ` + ot(H ? G.details : (Ot = X(G.details) || {}, delete Ot.instance, Ot), { depth: lt.debug.print.depth }).replace(/\n/g, `
               `) + `
STACK     :::  ` + U + `
WHEN      :::  ` + ft.toISOString() + ", " + ft.getTime() + `
LOG       :::  ` + o.stringify(P) + `
NODE      :::  ` + p.version + ", " + p.title + (H ? ", " + ot(p.versions).replace(/\s+/g, " ") + ", " + ot(p.features).replace(/\s+/g, " ") + ", " + ot(p.moduleLoadList).replace(/\s+/g, " ") : "") + `
PROCESS   :::  ` + rt + `
FOLDER    :::  ` + p.env.PWD;
                  if (lt.errhandler && lt.errhandler.call(Q, G), Q.flags.closed)
                    return;
                  if (Ft || (Q.act("role:seneca,info:fatal,closing$:true", { err: G }), Q.close(function(ce) {
                    Ft || p.nextTick(function() {
                      ce && Q.log.fatal({ kind: "close", err: ot(ce) }), It && (ce && y.internal_err(ce), y.internal_err(Wt), y.internal_err(`
SENECA TERMINATED at ` + (/* @__PURE__ */ new Date()).toISOString() + `. See above for error report.
`)), lt.system.exit(1);
                    });
                  })), !Ft) {
                    let ce = setTimeout(function() {
                      Q.log.fatal({ kind: "close", timeout: !0 }), lt.test && (y.internal_err(Wt), y.internal_err(`

SENECA TERMINATED (on timeout) at ` + (/* @__PURE__ */ new Date()).toISOString() + `.

`)), lt.system.exit(2);
                    }, lt.death_delay);
                    ce.unref && ce.unref();
                  }
                } catch (P) {
                  if (this.log.fatal({ kind: "panic", panic: ot(P), orig: arguments[0] }), lt.test) {
                    let U = `

Seneca Panic
============

` + P.stack + `

Original Error:
` + (arguments[0] && arguments[0].stack ? arguments[0].stack : arguments[0]);
                    y.internal_err(U);
                  }
                }
              }
            };
            return q.context = At, q;
          }
          function tt(Q, At, Pt, q, G) {
            let lt = q.transport$ || {}, It = Pt || At.meta$ || {}, Ft = It.prior || {};
            return Q = Q || {}, Object.assign({ actid: It.id, msg: At, meta: Pt, entry: Ft.entry, prior: Ft.chain, gate: q.gate$, caller: q.caller$, actdef: Q, client: Q.client, listen: !!lt.origin, transport: lt }, G);
          }
          function nt(Q, At) {
            return Q ? (Q.details && At && At.caller && (Q.details.caller = At.caller), Object.assign({ notice: Q.message, code: Q.code, err: Q }, At)) : At;
          }
          function ct(Q, At) {
            return typeof Q == "function" ? Q(At) : Q;
          }
          function ut() {
            let Q = 0;
            return function() {
              return Q++;
            };
          }
          function V(Q) {
            return n.default.types.isNativeError(Q);
          }
          function ot(Q, At) {
            return n.default.inspect(Q, At);
          }
          function xt(Q) {
            return function(At) {
              return Q || At ? T.callpoint(new Error(), ["/ordu.js", "/seneca/seneca.js", "/seneca/lib/", "/lodash.js"]) : void 0;
            };
          }
          function Ut(Q) {
            return [Q.pattern, Q.id, Q.instance, Q.tag, Q.version, Q.start, Q.end, Q.sync, Q.action];
          }
          function pt(Q, At = 111) {
            let Pt = ot(X(Q)).replace(/\n/g, "");
            return Pt = Pt.substring(0, At) + (At < Pt.length ? "..." : "");
          }
          c.print = D, c.each = j, c.makedie = Z, c.make_standard_act_log_entry = tt, c.make_standard_err_log_entry = nt, c.resolve_option = ct, c.autoincr = ut, c.isError = V, c.inspect = ot, c.make_callpoint = xt, c.make_trace_desc = Ut, c.msgstr = pt, c.TRACE_PATTERN = 0, c.TRACE_ID = 1, c.TRACE_INSTANCE = 2, c.TRACE_TAG = 3, c.TRACE_VERSION = 4, c.TRACE_START = 5, c.TRACE_END = 6, c.TRACE_SYNC = 7;
          function at(Q) {
            return new bt(Q);
          }
          c.TRACE_ACTION = 8, c.history = at;
          class bt {
            constructor(At) {
              this._total = 0, this._list = [], this._map = {};
              let Pt = this;
              (At = At || {}).prune && (this._prune_interval = setInterval(function() {
                Pt.prune(Date.now());
              }, At.interval || 100), this._prune_interval.unref && this._prune_interval.unref());
            }
            stats() {
              return { total: this._total };
            }
            add(At) {
              this._map[At.id] = At;
              let Pt = this._list.length - 1;
              Pt < 0 || this._list[Pt].timelimit <= At.timelimit ? this._list.push(At) : (Pt = this.place(At.timelimit), this._list.splice(Pt, 0, At));
            }
            place(At) {
              let Pt = this._list.length, q = 0, G = Pt;
              if (this._list.length === 0)
                return 0;
              do
                if (Pt = Math.floor((q + G) / 2), At > this._list[Pt].timelimit)
                  Pt = q = Pt + 1;
                else {
                  if (!(At < this._list[Pt].timelimit)) {
                    Pt++;
                    break;
                  }
                  G = Pt;
                }
              while (q < G);
              return Pt;
            }
            prune(At) {
              let Pt = this.place(At);
              if (0 <= Pt && Pt <= this._list.length) {
                for (let q = 0; q < Pt; q++)
                  delete this._map[this._list[q].id];
                this._list = this._list.slice(Pt);
              }
            }
            get(At) {
              return this._map[At] || null;
            }
            list() {
              return this._list;
            }
            close() {
              this._prune_interval && clearInterval(this._prune_interval);
            }
            toString() {
              return ot({ total: this._total, map: this._map, list: this._list });
            }
            [n.default.inspect.custom]() {
              return this.toString();
            }
          }
        }).call(this);
      }).call(this, x("_process"));
    }, { "./errors": 171, "./print": 179, _process: 158, eraro: 51, "fast-safe-stringify": 96, jsonic: 119, "lodash.defaultsdeep": 121, nid: 131, norma: 133, util: 238 }], 171: [function(x, C, c) {
      Object.defineProperty(c, "__esModule", { value: !0 }), c.default = { test_msg: "Test message.", test_args: "Test args <%=arg0%> <%=arg1%>.", test_prop: "TESTING: exists: <%=exists%>, notfound:<%=notfound%>, str=<%=str%>, obj=<%=obj%>, arr=<%=arr%>, bool=<%=bool%>, null=<%=null$%>, delete=<%=delete$%>, undefined=<%=undefined$%>, void=<%=void$%>, NaN=<%=NaN$%>", add_string_pattern_syntax: 'Could not add action due to syntax error in pattern string: "<%=argstr%>": Line:<%=line%>, Column:<%=col%>; <%=syntax%>', act_string_args_syntax: 'Could execute action due to syntax error in argument string: "<%=argstr%>": Line:<%=line%>, Column:<%=col%>; <%=syntax%>', add_pattern_object_expected_after_string_pattern: 'Could not add action; unexpected argument; a pattern object or function should follow the pattern string; arguments were: "<%=args%>".', add_pattern_object_expected: 'Could not add action; unexpected argument; a pattern object or string should be the first argument; arguments were: "<%=args%>".', add_action_function_expected: 'Could not add action: the action function should appear after the pattern; arguments were: "<%=args%>".', add_action_metadata_not_an_object: "Could not add action: the argument after the action function should be a metadata object: <%=actdef%>.", add_empty_pattern: 'Could not add action, as the action pattern is empty: "<%=args%>"', act_if_expects_boolean: 'The method act_if expects a boolean value as its first argument, was: "<%=first%>".', act_not_found: "No matching action pattern found for <%=args%>, and no default result provided (using a default$ property).", act_default_bad: "No matching action pattern found for <%=args%>, and default result is not a plain object or an array: <%=xdefault%>.", act_no_args: 'No action pattern defined in "<%=args%>"; the first argument should be a string or object pattern.', act_invalid_msg: "Action <%=pattern%> received an invalid message; <%=message%>; message content was: <%=msg%>.", act_execute: "Action <%=pattern%> failed: <%=message%>.", act_callback: "Action <%=pattern%> callback threw: <%=message%>.", act_loop: "Action <%=pattern%> loops back on itself. Action details: <%=actdef%>, history: <%=history%>", result_not_objarr: "Action <%=pattern%> responded with result that was not an object or array: <%=result%>; Use option strict:{result:false} to allow; arguments were: <%=args%>", no_client: 'Transport client was not created; arguments were: "<%=args%>".', invalid_options: "Invalid options; <%=message%>", plugin_required: "The <%=name%> plugin depends on the <%=dependency%> plugin, which is not loaded yet.", plugin_init: "The <%=name%> plugin failed to initialize: <%=plugin_error%>.", plugin_init_timeout: 'The <%=name%> plugin failed to initialize within <%=timeout%> milliseconds (The init:<%=name%> action did not call the "done" callback in time).', export_not_found: "The export <%=key%> has not been defined by a plugin.", store_cmd_missing: 'Entity data store implementation is missing a command; "<%=cmd%>": "<%=store%>".', sub_function_catch: "Pattern subscription function threw: <%=message%> on message: <%=msg%>, result: <%=result%>.", sub_inward_action_failed: "Subscription action on inward pattern <%=pattern%> threw: <%=errmsg%> at <%=errline%> on message data: <%=msg%>. To start debugging, find the `seneca.sub` method call that defines the subscription action, and review the code of the action function.", sub_outward_action_failed: "Subscription action on outward pattern <%=pattern%> threw: <%=errmsg%> at <%=errline%> on message data: <%=msg%>. To start debugging, find the `seneca.sub` method call that defines the subscription action, and review the code of the action function.", ready_failed: "Ready function failed: <%=message%>", unknown_message_reply: "Reply for message <%=id%> failed as message is unknown: <%=args%>", maxparents: "Message has too many parent messages (<%=maxparents%>). There may be an infinite loop. Parents: <%=parents%>, Message: <%=args%>", plugin_define_failed: "The definition action for the plugin <%=fullname%> has failed: <%=message%>. This error is considered fatal as all plugins have to initialize correctly. You should test the plugin by itself to verify that it is working correctly. Also ensure that the configuration options passed to the plugin are correct. These are shown below under in the DETAILS section. There could also be a bug in the plugin. If you think that is the case, please create a github issue on the plugin's repository<%=repo%>, and include this error report.", no_transport_client: "The transport client defined by <%=config%> does not exist for message: <%=msg%>", invalid_plugin_option: "Plugin <%=name%>: option value is not valid: <%=err_msg%> in options <%=options%>", no_prior_action: "The `prior` method must be called inside an action function. Arguments were: <%=args%>", missing_plugin_name: "The plugin name string was missing or empty.", bad_plugin_name: "The plugin name string cannot be empty and must be alphanumeric (matching /^[a-zA-Z][a-zA-Z0-9_]*$/), and cannot be longer than 1024 characters. Name was '<%=name.substring(0,1032)%>'.", bad_plugin_tag: "The plugin tag string, if defined, must be alphanumeric (matching /^[a-zA-Z0-9_]+$/), and cannot be longer than 1024 characters. Name was '<%=name.substring(0,1032)%>', and tag was '<%=tag.substring(0,1032)%>'.", bad_jsonic: "Data string provided in Jsonic format (https://github.com/rjrodger/jsonic) has a syntax error: <%=syntax%> (line:<%=line%>, col:<%=col%>); original: <%=argstr%>", no_error_code: "The Seneca.error or Seneca.fail method was called without an error code string as first argument.", fail_wrong_number_of_args: "The Seneca.fail method was called with the wrong number of arguments: <%=num_args%>", fail_cond_must_be_bool: "The Seneca.fail method expected the `cond` param to be a boolean.", action_timeout: "<%=legacy_string%>Action <%=pattern%> timed out. Timeout was: <%=timeout%> (start: <%=start%>, end: <%=end%>. Message was: <%=message%>.", use_no_args: "The seneca.use method needs at least one argument to define a plugin.", act_invalid_args: "Action <%=pattern%> has invalid arguments; <%=message%>; arguments were: <%=msg%>.", deprecation: { seneca_parent: "Seneca.parent has been renamed to Seneca.prior. Seneca.parent will be removed in Seneca 4.x.", seneca_next_act: "Seneca.next_act will be removed in Seneca 3.x" } };
    }, {}], 172: [function(x, C, c) {
      Object.defineProperty(c, "__esModule", { value: !0 }), c.Inward = void 0;
      const p = x("./common"), v = {};
      function n(d) {
        const b = d.ctx, k = d.data;
        var O = k.meta;
        if (b.actdef) {
          var A = b.actdef.fixed, l = b.actdef.custom;
          A && Object.assign(k.msg, A), l && (O.custom = O.custom || {}, Object.assign(O.custom, l));
        }
      }
      function i(d) {
        const b = d.ctx, k = d.data;
        var O = b.options, A = k.meta;
        if (A.parents && O.limits.maxparents < A.parents.length)
          return { op: "stop", out: { kind: "error", code: "maxparents", info: { maxparents: O.limits.maxparents, numparents: A.parents.length, parents: A.parents.map((l) => l[p.TRACE_PATTERN] + " " + l[p.TRACE_ACTION]), args: (0, p.inspect)((0, p.clean)(k.msg)).replace(/\n/g, "") } } };
      }
      function s(d) {
        const b = d.ctx, k = d.data;
        b.actdef && (typeof b.seneca.on_act_in == "function" && b.seneca.on_act_in(b.actdef, k.msg, k.meta), b.seneca.emit("act-in", k.msg, null, k.meta));
      }
      function r(d) {
        const b = d.ctx, k = d.data;
        if (b.seneca.flags.closed && !k.meta.closing)
          return { op: "stop", out: { kind: "error", code: "closed", info: { args: (0, p.inspect)((0, p.clean)(k.msg)).replace(/\n/g, "") } } };
      }
      function o(d) {
        const b = d.ctx;
        if (b.actdef) {
          var k = b.seneca.private$;
          ++k.stats.act.calls;
          var O = b.actdef.pattern;
          ++(k.stats.actmap[O] = k.stats.actmap[O] || {}).calls;
        }
      }
      function u(d) {
        const b = d.ctx, k = d.data;
        var O = b.options, A = k.msg, l = k.meta;
        if (!b.actdef) {
          var E = l.dflt || (O.strict.find ? l.dflt : {});
          if (E != null && (typeof E == "object" || Array.isArray(E)))
            return { op: "stop", out: { kind: "result", result: E, log: { level: "debug", data: { kind: "act", case: "DEFAULT" } } } };
          if (E != null)
            return { op: "stop", out: { kind: "error", code: "act_default_bad", info: { args: (0, p.inspect)((0, p.clean)(A)).replace(/\n/g, ""), xdefault: (0, p.inspect)(E) } } };
        }
      }
      function a(d) {
        const b = d.ctx, k = d.data;
        var O = b.options, A = k.msg;
        if (!b.actdef)
          return { op: "stop", out: { kind: "error", code: "act_not_found", info: { args: (0, p.inspect)((0, p.clean)(A)).replace(/\n/g, "") }, log: { level: O.trace.unknown ? "warn" : "debug", data: { kind: "act", case: "UNKNOWN" } } } };
      }
      function f(d) {
        const b = d.ctx, k = d.data;
        var O = b.options, A = k.msg, l = null;
        if (O.valid.active && O.valid.message)
          if (b.actdef.gubu)
            try {
              k.msg = b.actdef.gubu(A);
            } catch (E) {
              l = E;
            }
          else
            typeof b.actdef.validate == "function" && b.actdef.validate(A, function(E) {
              l = E;
            });
        if (l)
          return { op: "stop", out: { kind: "error", code: O.legacy.error_codes ? "act_invalid_args" : "act_invalid_msg", info: { pattern: b.actdef.pattern, message: l.message, msg: (0, p.clean)(A), error: l }, log: { level: O.trace.invalid ? "warn" : null, data: { kind: "act", case: "INVALID" } } } };
      }
      function y(d) {
        const b = d.ctx, k = d.data;
        var O = b.options, A = k.meta.id, l = b.seneca.private$;
        if (A != null && O.history.active) {
          var E = l.history.get(A);
          if (E) {
            l.stats.act.cache++;
            var M = E.result[E.result.length - 1] || {}, B = { op: "stop", out: { kind: M.err ? "error" : "result", result: M.res || null, error: M.err || null, log: { level: "debug", data: { kind: "act", case: "CACHE", cachetime: M.when } } } };
            return b.cached$ = !0, B;
          }
        }
      }
      function T(d) {
        const b = d.ctx, k = d.data;
        var O = b.options, A = k.msg;
        O.debug.deprecation && b.actdef.deprecate && b.seneca.log.warn({ kind: "act", case: "DEPRECATED", msg: A, pattern: b.actdef.pattern, notice: b.actdef.deprecate, callpoint: b.callpoint });
      }
      function h(d) {
        const b = d.ctx, k = d.data;
        var O = k.meta;
        O.pattern = b.actdef.pattern, O.client_pattern = b.actdef.client_pattern, O.action = b.actdef.id, O.plugin = Object.assign({}, O.plugin, b.actdef.plugin), O.start = O.start == null ? b.start : O.start, O.parents = O.parents || [], O.trace = O.trace || [];
        var A = b.seneca.private$.act && b.seneca.private$.act.parent, l = A && A.custom || O.custom || {};
        A && (O.parents = O.parents.concat(A.parents || []), O.parents.unshift((0, p.make_trace_desc)(A))), O.custom = Object.assign(l, O.custom, b.seneca.fixedmeta && b.seneca.fixedmeta.custom), k.msg.explain$ && Array.isArray(k.msg.explain$) ? O.explain = k.msg.explain$ : A && A.explain && (O.explain = A.explain), b.seneca.private$.explain && (O.explain = O.explain || [], b.seneca.private$.explain.push(O.explain));
      }
      function _(d) {
        const b = d.ctx, k = d.data, O = k.meta, A = b.seneca.private$.plugins[O.plugin.fullname];
        A && (b.seneca.plugin = A, b.seneca.shared = A.shared), b.seneca.fixedargs.tx$ = k.meta.tx, k.reply = k.reply.bind(b.seneca), k.reply.seneca = b.seneca;
        const l = k.reply;
        b.seneca.good = function(E) {
          b.seneca.log.warn("seneca.good is deprecated and will be removed in 4.0.0"), l(null, E);
        }, b.seneca.bad = function(E) {
          b.seneca.log.warn("seneca.bad is deprecated and will be removed in 4.0.0"), l(E);
        }, b.seneca.reply = function(M, B) {
        }, b.seneca.explain = v.explain.bind(b.seneca, O), O.explain && b.seneca.explain({ explain$: !0, msg$: (0, p.clean)(k.msg) });
      }
      function g(d) {
        const b = d.ctx, k = d.data;
        var O = k.meta, A = b.seneca.private$;
        if (!O.prior) {
          var l = b.seneca.util.clean(k.msg), E = A.subrouter.inward.find(l, !1, !0);
          l.in$ = !0;
          for (var M = 0; M < E.length; M++)
            for (var B = E[M], X = 0; X < B.length; X++) {
              var K = B[X];
              try {
                K.call(b.seneca, l, null, k.meta);
              } catch (D) {
                return { op: "stop", out: { kind: "error", code: "sub_inward_action_failed", error: D } };
              }
            }
        }
      }
      v.explain = function(d, b) {
        var k = this.explain, O = d.explain;
        return b === !0 || b === !1 ? k.call(this, b) : (O && b != null && (b.explain$ && (b.explain$ = { start: d.start, pattern: d.pattern, action: d.action, id: d.id, instance: d.instance, tag: d.tag, seneca: d.seneca, version: d.version, gate: d.gate, fatal: d.fatal, local: d.local, closing: d.closing, timeout: d.timeout, dflt: d.dflt, custom: d.custom, plugin: d.plugin, prior: d.prior, caller: d.caller, parents: d.parents, remote: d.remote, sync: d.sync, trace: d.trace, sub: d.sub, data: d.data, err: d.err, err_trace: d.err_trace, error: d.error, empty: d.empty }), O.push(b && typeof b == "object" ? b : { content: b })), O && this.explain);
      };
      let S = { inward_msg_modify: n, inward_closed: r, inward_act_cache: y, inward_act_default: u, inward_act_not_found: a, inward_validate_msg: f, inward_warnings: T, inward_msg_meta: h, inward_limit_msg: i, inward_act_stats: o, inward_prepare_delegate: _, inward_announce: s, inward_sub: g, intern: v };
      c.Inward = S;
    }, { "./common": 170 }], 173: [function(x, C, c) {
      var p = this && this.__importDefault || function(A) {
        return A && A.__esModule ? A : { default: A };
      };
      Object.defineProperty(c, "__esModule", { value: !0 }), c.Legacy = void 0;
      const v = p(x("util")), n = p(x("./errors")), i = x("lodash.flatten"), s = x("eraro"), r = x("norma"), o = x("jsonic"), u = x("./common"), a = { error: s({ package: "seneca", msgmap: n.default, override: !0 }) };
      function f(A, l) {
        for (var E = []; A != null && 0 < A.length; ) {
          var M = u.deep(A[0]);
          delete M.prop, E.push(M), A = A[0][l];
        }
        return E;
      }
      function y() {
        for (var A = 0; A < arguments.length; A++)
          if (typeof arguments[A] == "function")
            return arguments[A]();
      }
      function T(A) {
        var l;
        if (A === null || typeof A != "object")
          return A;
        if (v.default.types.isNativeError(A))
          return l = {}, Object.getOwnPropertyNames(A).forEach(function(X) {
            l[X] = A[X];
          }), l;
        if (A.constructor && A.constructor.name === "Date")
          return (l = /* @__PURE__ */ new Date()).setTime(A.getTime()), l;
        if (Array.isArray(A)) {
          l = [];
          for (var E = 0, M = A.length; E < M; ++E)
            l[E] = T(A[E]);
          return l;
        }
        for (var B in l = {}, A)
          Object.prototype.hasOwnProperty.call(A, B) && (l[B] = T(A[B]));
        return l;
      }
      function h(A, l, E) {
        var M = this;
        A = typeof A == "number" ? Array.from({ length: A }, (B, X) => X) : [...A], function B(X, K) {
          if (X)
            return E(X, K);
          var D = A.shift();
          D !== void 0 ? l.call(M, D, B) : E.call(M, X, K);
        }.call(M);
      }
      function _(A, l, E, M) {
        M = Array.isArray(M) ? M : M && typeof M == "object" ? Object.keys(M) : typeof M == "string" ? M.split(/\s*,\s*/) : "" + M;
        var B = u.clean(Object.assign({}, l));
        return B = u.deep(A, B, E), M.forEach((X) => delete B[X]), B;
      }
      function g() {
        for (var A = new Array(arguments.length), l = 0; l < A.length; ++l)
          A[l] = arguments[l];
        var E = this;
        return E.log.warn({ kind: "notice", case: "DEPRECATION", notice: n.default.deprecation.seneca_next_act }), function(M) {
          A.push(M), E.act.apply(E, A);
        };
      }
      function S() {
        for (var A = this, l = new Array(arguments.length), E = 0; E < l.length; ++E)
          l[E] = arguments[E];
        var M = [];
        return i(l).forEach(function(B) {
          B = typeof B == "string" ? o(B) : B, M = M.concat(A.private$.actrouter.list(B).map(function(X) {
            return X.match;
          }));
        }), M;
      }
      function d() {
        var A = r("{execute:b actargs:.*}", arguments);
        return A.execute ? this.act.apply(this, A.actargs) : this;
      }
      function b(A) {
        return !!this.find(A, { exact: !1 });
      }
      function k(A) {
        return function() {
          for (var l, E = new Array(arguments.length), M = 0; M < E.length; ++M)
            E[M] = arguments[M];
          var B = typeof E[E.length - 1] == "function" ? E[E.length - 1] : null;
          if (B && E.pop(), E[0] && typeof E[0] == "object") {
            var X = E[0].code;
            typeof X == "string" && E.unshift(X);
          }
          var K = a.error.apply(null, E);
          return K.callpoint = (((l = new Error().stack) === null || l === void 0 ? void 0 : l.match(/^.*\n.*\n\s*(.*)/)) || [])[1], K.seneca = { code: K.code, valmap: K.details }, this.log.error(u.make_standard_err_log_entry(K)), A.errhandler && A.errhandler.call(this, K), B && B.call(this, K), K;
        };
      }
      const O = { flatten: f, nil: y, copydata: T, recurse: h, argprops: _, next_act: g, findpins: S, act_if: d, hasact: b, make_legacy_fail: k };
      c.Legacy = O;
    }, { "./common": 170, "./errors": 171, eraro: 51, jsonic: 119, "lodash.flatten": 122, norma: 133, util: 238 }], 174: [function(x, C, c) {
      var p = this && this.__importDefault || function(d) {
        return d && d.__esModule ? d : { default: d };
      };
      Object.defineProperty(c, "__esModule", { value: !0 }), c.make_logging = void 0;
      const v = p(x("util")), n = x("./common"), i = { level: "info", default_level: "debug", level_text: { 100: "all", 200: "debug", 300: "info", 400: "warn", 500: "error", 600: "fatal", 999: "none" }, logger: a }, s = { quiet: "none", silent: "none", any: "all", all: "all", print: "debug", standard: "info", test: "warn" }, r = { flat_logger: u, test_logger: f, json_logger: a };
      function o() {
        return { default_logspec: n.deep(i), level_abbrev: n.deep(s), load_logger: y, build_log_spec: T, build_log: h, flat_logger: u, test_logger: f, json_logger: a };
      }
      function u(d) {
        let b = this.options();
        var k = b.debug.datalen || 111, O = (d.level_name + "").toUpperCase();
        O.length < 5 && (O += "_".repeat(5 - O.length)), O = O.substring(0, 5);
        for (var A = d.err != null ? [d.err.message, d.err.callpoint, d.err.plugin || "", d.err.plugin_callpoint || ""] : d.res != null ? [d.res] : d.msg != null ? [d.msg] : Array.isArray(d.data) ? d.data : d.data != null ? [d.data] : [], l = new Array(A.length), E = 0; E < A.length; E++)
          l[E] = A[E] && typeof A[E] == "object" ? n.clean(A[E]) : A[E], l[E] = v.default.inspect(l[E], { compact: !0, depth: d.depth$ || b.debug.print.depth, breakLength: 1 / 0 });
        var M = l.join(" ");
        M = M.substring(0, k) + (k < M.length ? "..." : "");
        var B = d.plugin_name == null ? "" : d.plugin_name + (d.plugin_tag == null || d.plugin_tag == "-" ? "" : "$" + d.plugin_tag), X = [d.isot, typeof d.seneca_id == "string" ? d.seneca_id.substring(0, 5) : "-----", O, d.kind == null ? "log" : d.kind, d.case == null ? "LOG" : d.case, B, d.pattern == null ? "" : d.pattern, d.action == null ? "" : d.action, d.idpath == null ? "" : d.idpath, M, d.callpoint ? v.default.inspect(d.callpoint) : ""];
        this.private$.print.log(X.join("	").substring(0, d.maxlen$ || 11111)), d.err && b.debug.print.err && this.private$.print.err(d.err);
      }
      function a(d) {
        var b = n.stringify(d);
        this.private$.print.log(b);
      }
      function f(d) {
        try {
          var b = g(this, d);
          this.private$.print.log(b);
        } catch (k) {
          this.private$.print.log(k, d);
        }
      }
      function y(d, b) {
        var k = b = b || a;
        if (typeof k == "string" && (k = r[k + "_logger"]), b.preload && ((k = b.preload.call(d).extend.logger).from_options$ = b.from_options$), k.length == 2) {
          var O = function(A) {
            return k(this, A);
          };
          return O.from_options$ = k.from_options$, O;
        }
        return k;
      }
      function T(d) {
        var b = d.options(), k = b.log, O = n.deep({ text_level: {} }, i, k && typeof k == "object" ? k : {});
        Object.keys(O.level_text).forEach((B) => {
          O.text_level[O.level_text[B]] = parseInt(B, 10);
        });
        var A = O.text_level, l = O.level_text, E = b.internal && b.internal.logger || b.logger || O.logger;
        if (typeof k == "string") {
          let B = null, X = null;
          if (A[k])
            O.level = k;
          else if (s[k])
            O.level = s[k];
          else if (isNaN(B = parseInt(k, 10))) {
            if (typeof (X = r[k + "_logger"]) != "function")
              throw n.error("bad_logspec_string", { logspec: k });
            E = X;
          } else
            O.level = B;
        } else if (typeof k == "number")
          O.level = parseInt(k, 10);
        else if (typeof k == "function")
          E = k;
        else if (k && typeof k != "object" && k != null)
          throw n.error("bad_logspec", { logspec: k });
        O.level = l[O.level] || "" + O.level;
        var M = A[O.level] || parseInt(O.level, 10);
        return M = M < 100 ? 100 : 999 < M ? 999 : M, O.live_level = M, E && (O.logger = E), O;
      }
      function h(d) {
        var b = T(d);
        d.private$.logspec = b;
        var k = y(d, b.logger);
        return d.private$.logger = k, d.log = function(O) {
          var A = this;
          A.entity$ ? (A = A.private$.get_instance(), O = { data: Array.prototype.slice.call(arguments) }) : typeof O == "string" && (O = { data: Array.prototype.slice.call(arguments) });
          var l = A.private$.logspec;
          O.level = O.level || l.default_level, typeof O.level != "number" && (O.level = l.text_level[O.level] || l.text_level[l.default_level]);
          var E = /* @__PURE__ */ new Date();
          return O.isot = O.isot || E.toISOString(), O.when = O.when || E.getTime(), O.level_name = O.level_name || l.level_text[O.level], O.seneca_id = O.seneca_id || A.id, A.did && (O.seneca_did = O.seneca_did || A.did), A.fixedargs.plugin$ && (O.plugin_name = O.plugin_name || A.fixedargs.plugin$.name, O.plugin_tag = O.plugin_tag || A.fixedargs.plugin$.tag), A.private$.act && S.build_act_entry(A.private$.act, O), A.emit("log", O), l.live_level <= O.level && A.private$.logger.call(this, O), this;
        }, d.log.self = () => d, Object.keys(b.text_level).forEach((O) => {
          d.log[O] = _(O, b);
        }), b;
      }
      function _(d, b) {
        var k = b.text_level[d], O = function(A) {
          var l = this.self();
          return A && typeof A != "object" && (A = { data: Array.prototype.slice.call(arguments) }), A.level = k, l.log(A);
        };
        return Object.defineProperty(O, "name", { value: "log_" + d }), O;
      }
      function g(d, b) {
        var k = b.when - d.start_time, O = d.private$.exports, A = O && O.options && O.options.debug, l = A && A.datalen || 111, E = [k + "/" + d.id.substring(0, 2) + "/" + d.tag + " " + (b.level_name + "").toUpperCase(), (b.kind || "data") + (b.case ? "/" + b.case : "") + (b.meta ? b.meta.sync ? "/s" : "/a" : "")];
        if (b.kind === "act") {
          if (b.meta && (E.push(b.meta.id.split("/").map(function(B) {
            return B.substring(0, 2);
          }).join("/")), E.push(b.meta.pattern)), b.res || b.result || b.msg) {
            let B = b.res || b.result || b.msg || {}, X = v.default.inspect(d.util.clean(B)).replace(/\s+/g, "").substring(0, l);
            X.length <= 22 || !B.$$logged$$ && (!b.err || !b.err.$$logged$$) ? (E.push(X), typeof B == "object" && (B.$$logged$$ = () => {
            })) : E.push(X.substring(0, 22));
          }
          b.actdef && E.push(b.actdef.id), b.notice && E.push(b.notice), b.data && E.push(b.data), b.case === "ERR" && b.err && !b.err.$$logged$$ && (E.push((b.err.code ? `

` + b.err.code : "") + `

` + b.err.stack + `
` + b.caller + `
`), typeof b.err == "object" && (b.err.$$logged$$ = () => {
          }));
        } else if (b.kind === "add")
          E.push(b.pattern), E.push(b.name);
        else if (b.kind === "ready")
          E.push(b.name);
        else if (b.kind === "plugin")
          E.push(b.plugin_name + (b.plugin_tag ? "$" + b.plugin_tag : ""));
        else if (b.kind !== "options")
          if (b.kind === "notice")
            E.push(b.notice);
          else if (b.kind === "fatal")
            E.push(b.notice), E.push(b.err && b.err.stack);
          else if (b.kind === "listen" || b.kind === "client") {
            var M = (b.options ? b.options[0] : b.data ? b.data[0] : {}) || {};
            E.push([M.type, M.pin, M.host, typeof M.port == "function" ? "" : M.port].join(";"));
          } else
            b.$$logged$$ || (E.push(v.default.inspect(b).replace(/\n/g, " ").substring(0, l)), typeof b == "object" && (b.$$logged$$ = () => {
            }));
        return b.did && E.push(b.did), E.join("	");
      }
      c.make_logging = o;
      const S = { build_act_entry: function(d, b) {
        if (b.kind = b.kind || "act", b.actid = b.actid || d.meta.id, b.pattern = b.pattern || d.meta.pattern, b.action = b.action || d.def.id, b.idpath = ("" + d.meta.tx).substring(0, 5), d.meta.parents)
          for (var k = 0; k < d.meta.parents.length; k++)
            b.idpath += ("." + ((d.meta.parents[k] || [])[1] || "-").split("/")[0]).substring(0, 6);
        b.idpath += ("." + d.meta.mi).substring(0, 6);
      } };
      o.intern = S;
    }, { "./common": 170, util: 238 }], 175: [function(x, C, c) {
      Object.defineProperty(c, "__esModule", { value: !0 }), c.Meta = void 0;
      class p {
        constructor(n, i, s, r) {
          this.start = Date.now(), this.mi = "", this.tx = "", this.id = "", this.version = "0.1.0", this.gate = !1, this.fatal = !1, this.closing = !1, this.sync = !0, this.local = !0, this.remote = !1, this.timeout = 0;
          let o = p.resolve_msg_id_tx(n, s), u = s.meta$, a = n.fixedmeta || {};
          this.mi = o[0], this.tx = o[1], this.id = o[0] + "/" + o[1], this.instance = n.id, this.tag = n.tag, this.seneca = n.version, this.gate = !!s.gate$ || a.gate, this.fatal = !!s.fatal$ || a.fatal, this.local = !!s.local$ || a.local, this.closing = !!s.closing$ || u && u.closing, this.timeout = Math.max(0, typeof s.timeout$ == "number" ? s.timeout$ : i.timeout), this.dflt = s.default$ || u && u.dflt, this.custom = s.custom$ || u && u.custom || null, this.plugin = s.plugin$, this.prior = s.prior$, this.caller = s.caller$, this.parents = s.parents$, this.remote = !!s.remote$, this.sync = s.sync$ != null ? !!s.sync$ : u && u.sync != null ? !!u.sync : typeof r == "function", this.trace = null, this.sub = null, this.data = null, this.err = null, this.err_trace = null, this.error = null, this.empty = null;
        }
        static resolve_msg_id_tx(n, i) {
          let s = (i.id$ || i.actid$ || n.idgen()).split("/");
          return s[1] = s[1] || i.tx$ || n.fixedargs.tx$ || n.idgen(), s[0] = s[0] || n.idgen(), s;
        }
      }
      c.Meta = p;
    }, {}], 176: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = this && this.__importDefault || function(_) {
            return _ && _.__esModule ? _ : { default: _ };
          };
          Object.defineProperty(c, "__esModule", { value: !0 }), c.resolve_options = void 0;
          const n = v(x("fs")), i = v(x("path")), s = x("eraro"), r = x("jsonic"), o = x("minimist"), { Gubu: u } = x("gubu"), a = x("./common"), f = s({ package: "seneca", msgmap: h() });
          function y(_, g, S) {
            let d = u(g);
            var b, k = { argv: {}, env: {}, default_file: {}, loaded: {} }, O = {};
            function A(E, M, B) {
              var X, K, D = B.from;
              typeof B == "string" && (D = B, B = {}), typeof D == "string" && (k.loaded = l(D));
              var j = o((B && B.debug && B.debug.argv || p.argv).slice(2)), Z = B && B.debug && B.debug.env || p.env;
              if (n.default.existsSync && n.default.existsSync("./options.seneca.js"))
                throw f("inverted_file_name", { from: "./options.seneca.js", module: E });
              try {
                k.default_file = E.require && E.require("./seneca.options.js");
              } catch (V) {
                if (V.code !== "MODULE_NOT_FOUND") {
                  var tt = { errmsg: V.message, from: "./seneca.options.js", module: E };
                  throw f(V, "require_default_options", tt);
                }
              }
              Z.SENECA_OPTIONS && (k.env = a.deep({}, k.env, r(Z.SENECA_OPTIONS))), Z.SENECA_TEST && (k.env.test = a.boolify(Z.SENECA_TEST)), Z.SENECA_QUIET && (k.env.quiet = a.boolify(Z.SENECA_QUIET)), j.seneca && (j.seneca.options && typeof j.seneca.options == "object" ? k.argv = j.seneca.options : typeof j.seneca.options == "string" && (j.seneca.options === "print" ? k.argv = { debug: { print: { options: !0 } } } : k.argv = r(j.seneca.options)), typeof k.argv.from == "string" && (k.argv = a.deep(l(k.argv.from), k.argv)), T(k.argv), j.seneca.tag != null && (k.argv.tag = "" + j.seneca.tag), j.seneca.log && (k.argv.log = k.argv.log || {}, function(V, ot) {
                var xt = Array.isArray(V) ? V[0] : V;
                if (typeof xt == "string")
                  try {
                    ot.log = r(xt);
                  } catch (pt) {
                    ot.log = xt;
                  }
                else if (xt && typeof xt == "object") {
                  ot.log = {};
                  var Ut = Object.keys(xt.level || xt);
                  Ut.length > 0 && (ot.log = { level: Ut[0] });
                }
              }(j.seneca.log, k.argv)), j.seneca.test && (k.argv.test = j.seneca.test), j.seneca.quiet && (k.argv.quiet = j.seneca.quiet));
              var nt = {};
              B.legacy === !1 ? nt.legacy = { actdef: !1, action_signature: !1, error: !1, error_codes: !1, fail: !1, logging: !1, meta: !1, meta_arg_remove: !1, transport: !1, timeout_string: !1, rules: !1, options: !1 } : B.legacy === !0 && (nt.legacy = {});
              const ct = ((X = B.valid) === null || X === void 0 ? void 0 : X.active) !== !1 && ((K = B.valid) === null || K === void 0 ? void 0 : K.option) !== !1;
              var ut = a.deep(ct ? {} : M(), k.default_file, O, k.loaded, B, nt, k.env, k.argv);
              return ct && (ut = M(ut)), ut.log = ut.log || ut.logger || ut.logging || {}, ut.legacy.logging = a.boolify(ut.legacy.logging), ut;
            }
            function l(E) {
              var M = {}, B = i.default.basename(E) !== E ? E : i.default.join(p.cwd(), E);
              if (B.match(/\.json$/i)) {
                var X = n.default.readFileSync && n.default.readFileSync(B).toString() || "";
                M = r(X);
              } else if (B.match(/\.js$/i))
                try {
                  M = b.require(B);
                } catch (K) {
                  if (K.code !== "MODULE_NOT_FOUND")
                    throw f(K, "require_options", { from: B, module: b });
                }
              return M;
            }
            return b = S.module && S.module.require ? S.module : _.parent && _.parent.require ? _.parent : _, delete (O = A(b, d, S)).module, { set: function(E) {
              if (E == null)
                throw f("no_options");
              return O = typeof E == "string" || E.reload$ ? A(b, d, E) : a.deep(O, E);
            }, get: function() {
              return O;
            } };
          }
          function T(_) {
            return Object.keys(_).forEach(function(g) {
              _[g] = _[g] === "true" || _[g] !== "false" && (_[g] && typeof _[g] == "object" ? T(_[g]) : _[g]);
            }), _;
          }
          function h() {
            return { inverted_file_name: "Please use seneca.options.js as the default options file name. The alternate name options.seneca.js is not supported.", require_default_options: "Call to require failed for <%=from%>: <%=errmsg%>." };
          }
          c.resolve_options = y;
        }).call(this);
      }).call(this, x("_process"));
    }, { "./common": 170, _process: 158, eraro: 51, fs: 45, gubu: 102, jsonic: 119, minimist: 130, path: 156 }], 177: [function(x, C, c) {
      Object.defineProperty(c, "__esModule", { value: !0 }), c.Outward = void 0;
      var p = x("util"), v = x("./common"), n = {};
      function i(g) {
        const S = g.ctx, d = g.data;
        if (!S.options.legacy.error && d.res && !d.meta.error && d.res.meta$ && d.res.meta$.err) {
          var b = new Error(d.res.message);
          for (var k in d.res)
            b[k] = d.res[k];
          d.res = b;
        }
      }
      function s(g) {
        const S = g.ctx, d = g.data;
        var b = S.options, k = d.res, O = d.meta.id, A = S.seneca.private$;
        if (O != null && b.history.active) {
          var l = A.history.get(O);
          l && l.result.push({ when: Date.now(), res: k });
        }
      }
      function r(g) {
        const S = g.ctx, d = g.data;
        if (S.actdef && !S.cached$) {
          var b = S.seneca.private$, k = b.stats.act, O = d.meta;
          ++k.done, O && O.prior == null && b.timestats.point(S.duration, S.actdef.pattern);
          var A = S.actdef.pattern, l = b.stats.actmap[A] = b.stats.actmap[A] || {};
          O && O.error ? (++k.fails, ++l.fails) : ++l.done;
        }
      }
      function o(g) {
        const S = g.ctx, d = g.data;
        var b = S.options, k = d.msg, O = d.res;
        d.res === void 0 && (d.res = null);
        var A = O != null && !(O && typeof O == "object" || O instanceof Error || O.meta$ || O.entity$ || O.force$);
        d.out instanceof Error && (A = !0);
        var l = !(k.cmd === "generate_id" || k.note === !0 || k.cmd === "native" || k.cmd === "quickcode");
        b.strict.result && l && A && (d.res = S.seneca.private$.error("result_not_objarr", { pattern: S.actdef.pattern, args: p.inspect(v.clean(k)).replace(/\n/g, ""), result: O }), d.meta.error = !0);
      }
      function u(g) {
        const S = g.ctx, d = g.data;
        d.meta.error || (typeof S.seneca.on_act_out == "function" && S.seneca.on_act_out(S.actdef, d.res, d.meta), S.seneca.emit("act-out", d.msg, d.res, d.meta), S.seneca.log.debug(S.actlog(S.actdef, d.msg, d.meta, S.origmsg, { kind: "act", case: "OUT", duration: S.duration, res: d.res, did: S.seneca.did })));
      }
      function a(g) {
        const S = g.ctx, d = g.data;
        var b = S.seneca.private$, k = d.meta, O = d.reply_meta;
        k && O && (k.trace = k.trace || [], k.trace.push({ desc: v.make_trace_desc(O), trace: O.trace || [] }));
        var A = b.act && b.act.parent;
        A && (A.trace = A.trace || [], A.trace.push({ desc: v.make_trace_desc(k), trace: k.trace || [] }));
      }
      function f(g) {
        const S = g.data;
        var d = S.meta, b = S.reply_meta;
        d && b && (d.custom = Object.assign(d.custom, b.custom));
      }
      function y(g) {
        const S = g.ctx, d = g.data;
        var b = S.seneca, k = S.actdef, O = d.meta;
        if (O.error) {
          if (d.error_desc = n.act_error(b, S, d), O.fatal)
            return b.die(d.error_desc.err);
          d.has_callback = d.error_desc.call_cb, b && typeof b.on_act_err == "function" && b.on_act_err(k, d.res, O), d.err = d.error_desc.err, delete d.err.meta$, d.res = null, d.meta = d.error_desc.err.meta$ || d.meta;
        } else
          d.err = null;
      }
      function T(g) {
        const S = g.ctx, d = g.data;
        var b = S.seneca;
        d.res && d.res.entity$ && b.make$ && (d.res = b.make$(d.res));
      }
      function h(g) {
        const S = g.ctx, d = g.data;
        var b = d.meta, k = S.seneca.private$;
        if (!b.prior) {
          var O = S.seneca.util.clean(d.msg), A = k.subrouter.outward.find(O, !1, !0);
          O.out$ = !0;
          for (var l = d.res || d.err || null, E = 0; E < A.length; E++)
            for (var M = A[E], B = 0; B < M.length; B++) {
              var X = M[B];
              try {
                X.call(S.seneca, O, l, d.meta);
              } catch (K) {
                return { op: "stop", out: { kind: "error", code: "sub_outward_action_failed", error: K } };
              }
            }
        }
      }
      n.act_error = function(g, S, d) {
        var b = S.duration, k = S.callpoint, O = S.actdef || {}, A = S.origmsg, l = S.reply, E = d.meta, M = d.msg, B = g.options(), X = !0, K = d.res || d.err;
        if (K.seneca)
          K.orig && typeof K.orig.code == "string" && K.orig.code.indexOf("perm/") === 0 && (K = K.orig);
        else {
          var D = Object.assign({}, K.details, { message: K.eraro && K.orig ? K.orig.message : K.message, pattern: O.pattern, fn: O.func, callback: l, instance: g.toString(), callpoint: k });
          if (B.legacy.error)
            K = S.error(K, "act_execute", D);
          else {
            var j = S.error("act_execute", { pattern: O.pattern, message: K.message, callpoint: k });
            if (delete j.stack, K.meta$ = K.meta$ || E || {}, K.meta$.data = g.util.clean(A), K.meta$.err) {
              var Z = Object.assign({}, E);
              Z.err = j, K.meta$.err_trace = K.meta$.err_trace || [], K.meta$.err_trace.push(Z);
            } else
              K.meta$.err = j;
          }
        }
        B.legacy.error && (K.details = K.details || {}, K.details.plugin = K.details.plugin || {});
        var tt = S.actlog(O, M, E, A, { kind: "act", case: "ERR", duration: b });
        return tt = S.errlog(K, tt), K.callpoint == null && (K.callpoint = v.error.callpoint(K)), g.log.error(tt), g.emit("act-err", M, K), typeof B.errhandler != "function" || M && E.fatal || (X = !B.errhandler.call(g, K, K.meta$ || E)), { call_cb: X, err: K };
      };
      const _ = { test$: { intern: n }, outward_act_cache: s, outward_res_object: o, outward_act_stats: r, outward_make_error: i, outward_announce: u, outward_trace: a, outward_act_error: y, outward_res_entity: T, outward_msg_meta: f, outward_sub: h };
      c.Outward = _;
    }, { "./common": 170, util: 238 }], 178: [function(x, C, c) {
      var p = this && this.__importDefault || function(_) {
        return _ && _.__esModule ? _ : { default: _ };
      };
      Object.defineProperty(c, "__esModule", { value: !0 }), c.Plugin = void 0;
      const v = x("lodash.uniq"), n = x("eraro"), i = p(x("nua")), s = x("ordu"), r = x("./common"), { Print: o } = x("./print"), u = T();
      function a(_, g) {
        const S = y(), d = new s.Ordu({ debug: g.debug });
        return d.operator("seneca_plugin", u.op.seneca_plugin), d.operator("seneca_export", u.op.seneca_export), d.operator("seneca_options", u.op.seneca_options), d.operator("seneca_complete", u.op.seneca_complete), d.add([S.args, S.load, S.normalize, S.preload, { name: "pre_meta", exec: S.meta }, { name: "pre_legacy_extend", exec: S.legacy_extend }, S.delegate, S.call_define, S.options, S.define, { name: "post_meta", exec: S.meta }, { name: "post_legacy_extend", exec: S.legacy_extend }, S.call_prepare, S.complete]), { use: f(d, _), ordu: d, tasks: S };
      }
      function f(_, g) {
        let S = { index: 0 };
        return function() {
          let d = this, b = [...arguments];
          if (b.length === 0)
            throw d.error("use_no_args");
          let k = { seq: S, args: b, seneca: this, callpoint: g(!0) }, O = { seq: -1, args: [], plugin: null, meta: null, delegate: null, plugin_done: null, exports: {}, prepare: {} };
          return function() {
            return sn(this, null, function* () {
              yield _.exec(k, O, { done: function(A) {
                if (A.err) {
                  var l = A.err.seneca ? A.err : d.private$.error(A.err, A.err.code);
                  l.plugin = l.plugin || (O.plugin ? O.plugin.fullname || O.plugin.name : b.join(" ")), l.plugin_callpoint = l.plugin_callpoint || k.callpoint, d.die(l);
                }
              } });
            });
          }(), d;
        };
      }
      function y() {
        return { args: (_) => {
          let g = [..._.ctx.args];
          return g[0] === "options" ? (_.ctx.seneca.options(g[1]), { op: "stop", why: "legacy-options" }) : (g[0] != null && typeof g[0] == "object" && (g[0].init = g[0].define || g[0].init), { op: "merge", out: { plugin: { args: g } } });
        }, load: (_) => {
          let g = _.data.plugin.args, S = _.ctx.seneca, d = S.private$, b = d.use.build_plugin_desc(...g);
          return b.callpoint = _.ctx.callpoint, d.ignore_plugins[b.full] ? (S.log.info({ kind: "plugin", case: "ignore", plugin_full: b.full, plugin_name: b.name, plugin_tag: b.tag }), { op: "stop", why: "ignore" }) : { op: "merge", out: { plugin: d.use.use_plugin_desc(b) } };
        }, normalize: (_) => {
          let g = _.data.plugin, S = {};
          return S.define = g.define || g.init, S.fullname = r.make_plugin_key(g), S.loading = !0, { op: "merge", out: { plugin: S } };
        }, preload: (_) => {
          let g = _.ctx.seneca, S = _.data.plugin;
          if (g.options().system.plugin.load_once && g.has_plugin(S))
            return { op: "stop", why: "already-loaded", out: { plugin: { loading: !1 } } };
          let d = {};
          typeof S.define.preload == "function" && (d = S.define.preload.call(g, S) || {});
          let b = d.name || S.name;
          return { op: "seneca_plugin", out: { merge: { meta: d, plugin: { name: b, fullname: r.make_plugin_key(b, S.tag) } }, plugin: S } };
        }, meta: (_) => {
          let g = _.ctx.seneca, S = _.data.plugin, d = _.data.meta, b = {};
          b[S.name] = d.export || S, b[S.fullname] = d.export || S;
          let k = d.exportmap || d.exports || {};
          if (Object.keys(k).forEach((O) => {
            let A = k[O];
            if (A !== void 0) {
              let l = S.fullname + "/" + O;
              b[l] = A;
              let E = S.name + "/" + O;
              b[E] = A;
            }
          }), d.order && d.order.plugin) {
            let O = Array.isArray(d.order.plugin) ? d.order.plugin : [d.order.plugin];
            g.order.plugin.add(O), delete d.order.plugin;
          }
          return { op: "seneca_export", out: { exports: b } };
        }, legacy_extend: (_) => {
          let g = _.ctx.seneca, S = _.data.meta;
          S.extend && typeof S.extend == "object" && (typeof S.extend.action_modifier == "function" && g.private$.action_modifiers.push(S.extend.action_modifier), typeof S.extend.logger == "function" && (S.extend.logger.replace || typeof g.private$.logger.add != "function" ? g.private$.logger = S.extend.logger : g.private$.logger.add(S.extend.logger)));
        }, delegate: (_) => {
          let g = _.ctx.seneca, S = _.data.plugin, d = g.delegate({ plugin$: { name: S.name, tag: S.tag }, fatal$: !0 });
          S.shared = /* @__PURE__ */ Object.create(null), d.shared = S.shared, d.plugin = S, d.private$ = Object.create(g.private$), d.private$.ge = d.private$.ge.gate(), d.die = r.makedie(d, { type: "plugin", plugin: S.name });
          let b = [];
          return d.add = function() {
            let k = [...arguments], O = k[k.length - 1] || {};
            return typeof O == "function" && (O = {}, k.push(O)), O.plugin_name = S.name || "-", O.plugin_tag = S.tag || "-", O.plugin_fullname = S.fullname, O.log = d.log, b.push(O), g.add.apply(d, k), this;
          }, d.__update_plugin__ = function(k) {
            d.context.name = k.name || "-", d.context.tag = k.tag || "-", d.context.full = k.fullname || "-", b.forEach(function(O) {
              O.plugin_name = k.name || O.plugin_name || "-", O.plugin_tag = k.tag || O.plugin_tag || "-", O.plugin_fullname = k.fullname || O.plugin_fullname || "-";
            });
          }, d.init = function(k) {
            let O = { role: "seneca", plugin: "init", init: S.name };
            S.tag != null && S.tag != "-" && (O.tag = S.tag), d.add(O, function(A, l) {
              k.call(this, l);
            });
          }, d.context.plugin = S, d.context.plugin.mark = Math.random(), { op: "merge", out: { delegate: d } };
        }, call_define: (_) => {
          let g = _.data.plugin, S = _.data.delegate, d = _.ctx.seq.index++, b = { role: "seneca", plugin: "define", name: g.name, seq: d };
          return g.tag !== null && (b.tag = g.tag), new Promise((k) => {
            S.add(b, (O, A) => {
              k({ op: "merge", out: { seq: d, plugin_done: A } });
            }), S.act({ role: "seneca", plugin: "define", name: g.name, tag: g.tag, seq: d, default$: {}, fatal$: !0, local$: !0 });
          });
        }, options: (_) => {
          let g = _.data.plugin, S = _.data.delegate, d = S.options(), b = g.fullname, k = g.defaults, O = Object.assign({}, d[b], d.plugin[b], d[b + "$" + g.tag], d.plugin[b + "$" + g.tag]), A = b !== g.name ? g.name : null;
          A || b.indexOf("seneca-") !== 0 || (A = b.substring(7));
          let l = Object.assign({}, d[A], d.plugin[A], d[A + "$" + g.tag], d.plugin[A + "$" + g.tag]), E = {}, M = g.errors || g.define && g.define.errors;
          M && (E.errors = M);
          let B = Object.assign(E, l, O, g.options || {}), X = {}, K = S.valid, D, j = S.util.Joi, Z = typeof k != "function" || k.gubu ? k : k({ valid: K, Joi: j });
          if (Z != null && Object.keys(Z).length !== 0 && d.valid.active && d.valid.plugin)
            if (d.legacy.options || Z.$_root)
              X = S.util.deep(Z, B);
            else {
              let tt = Z.gubu && Z.gubu.gubu$;
              tt || Z.errors != null || M == null || (Z.errors = {});
              let nt = [];
              X = (tt ? Z : S.valid(Z))(B, { err: nt }), 0 < nt.length && (D = S.error("invalid_plugin_option", { name: b, err_msg: nt.map((ct) => ct.t).join("; "), options: B }));
            }
          else
            X = B;
          return { op: "seneca_options", err: D, out: { plugin: { options: X, options_schema: null } } };
        }, define: (_) => {
          let g, S = _.ctx.seneca, d = _.data.plugin, b = _.data.delegate, k = _.data.plugin.options;
          return b.log.debug({ kind: "plugin", case: "DEFINE", name: d.name, tag: d.tag, options: k, callpoint: _.ctx.callpoint }), (g = u.define_plugin(b, d, S.util.clean(k))) instanceof Promise ? g.then(O) : O(g);
          function O(A) {
            return d.meta = A, typeof A == "function" && (A = { service: A }), d.name = A.name || d.name, d.tag = A.tag || d.tag || d.options && d.options.tag$, d.fullname = r.make_plugin_key(d), d.service = A.service || d.service, b.__update_plugin__(d), S.private$.plugins[d.fullname] = d, S.private$.plugin_order.byname.push(d.name), S.private$.plugin_order.byname = v(S.private$.plugin_order.byname), S.private$.plugin_order.byref.push(d.fullname), d.name === "amqp-transport" && S.options({ legacy: { meta: !0 } }), typeof k.defined$ == "function" && k.defined$(d), { op: "merge", out: { meta: A } };
          }
        }, call_prepare: (_) => {
          let g = _.data.plugin, S = _.data.plugin.options, d = _.data.delegate;
          if (S.init$ === !1)
            return;
          let b = _.data.exports;
          return d.log.debug({ kind: "plugin", case: "INIT", name: g.name, tag: g.tag, exports: b }), new Promise((k) => {
            d.act({ role: "seneca", plugin: "init", seq: _.data.seq, init: g.name, tag: g.tag, default$: {}, fatal$: !0, local$: !0 }, function(O, A) {
              k({ op: "merge", out: { prepare: { err: O, res: A } } });
            });
          });
        }, complete: (_) => {
          let g = _.data.prepare, S = _.data.plugin, d = _.data.plugin_done, b = _.data.plugin.options, k = _.data.delegate, O = k.options();
          if (g) {
            if (g.err) {
              let l = { err_code: "plugin_init" };
              return l.plugin_error = g.err.message, g.err.code === "action-timeout" && (l.err_code = "plugin_init_timeout", l.timeout = O.timeout), { op: "seneca_complete", out: { plugin: l } };
            }
            let A = S.name + (S.tag ? "$" + S.tag : "");
            O.debug.print && O.debug.print.options && o.plugin_options(k, A, b), k.log.info({ kind: "plugin", case: "READY", name: S.name, tag: S.tag }), typeof b.inited$ == "function" && b.inited$(S);
          }
          return d(), { op: "seneca_complete", out: { plugin: { loading: !1 } } };
        } };
      }
      function T() {
        return { op: { seneca_plugin: (_, g, S) => ((0, i.default)(S, _.out.merge, { preserve: !0 }), g.seneca.private$.plugins[S.plugin.fullname] = _.out.plugin, { stop: !1 }), seneca_export: (_, g, S) => (Object.assign(S.exports, _.out.exports), Object.assign(g.seneca.private$.exports, _.out.exports), { stop: !1 }), seneca_options: (_, g, S) => {
          (0, i.default)(S.plugin, _.out.plugin, { preserve: !0 });
          let d = S.plugin.fullname, b = S.plugin.options, k = { plugin: {} };
          return k.plugin[d] = b, g.seneca.options(k), { stop: !1 };
        }, seneca_complete: (_, g, S) => ((0, i.default)(S.plugin, _.out.plugin, { preserve: !0 }), S.prepare.err && S.delegate.die(S.delegate.error(S.prepare.err, S.plugin.err_code, S.plugin)), { stop: !0 }) }, define_plugin: function(_, g, S) {
          if (g.define.length > 1) {
            let k = g.define.toString();
            throw g.init_func_sig = (k.match(/^(.*)\r*\n/) || [])[1], _.error("unsupported_legacy_plugin", g);
          }
          let d;
          S.errors && (g.eraro = n({ package: "seneca", msgmap: S.errors, override: !0 }));
          try {
            d = g.define.call(_, S) || {};
          } catch (k) {
            r.wrap_error(k, "plugin_define_failed", { fullname: g.fullname, message: (k.message + (" (" + k.stack.match(/\n.*?\n/)).replace(/\n.*\//g, "")).replace(/\n/g, ""), options: S, repo: g.repo ? " " + g.repo + "/issues" : "" });
          }
          return d instanceof Promise ? d.then(b) : b(d);
          function b(k) {
            const O = typeof k == "string" ? { name: k } : k;
            return O.options = O.options || S, O;
          }
        } };
      }
      const h = { api_use: a, intern: u };
      c.Plugin = h;
    }, { "./common": 170, "./print": 179, eraro: 51, "lodash.uniq": 129, nua: 134, ordu: 144 }], 179: [function(x, C, c) {
      Object.defineProperty(c, "__esModule", { value: !0 }), c.Print = void 0;
      var p = x("util"), v = x("minimist");
      function n(a, f) {
        var y = v(f.slice(2)), T = y.seneca;
        a.root.argv = T, y.seneca && T.print && T.print.options && a.options({ debug: { print: { options: !0 } } });
      }
      function i(a, f) {
        f.debug.print.options && (a.private$.print.log(`
Seneca Options (` + a.id + `): before plugins
===
`), a.private$.print.log(p.inspect(f, { depth: f.debug.print.depth })), a.private$.print.log(""));
      }
      function s(a, f) {
        a ? o("ERROR: " + a.message) : r(p.inspect(f, { depth: this && this.options ? this.options().debug.print.depth : null }));
      }
      function r(...a) {
        var f = console.log;
        f.apply(f, a);
      }
      function o(...a) {
        console.error.apply(console.error, a);
      }
      function u(a, f, y) {
        a.private$.print.log(`
Seneca Options (` + a.id + "): plugin: " + f + `
===
`), a.private$.print.log(p.inspect(y, { depth: a.options().debug.print.depth })), a.private$.print.log("");
      }
      c.Print = n, Object.assign(n, { print_options: i, internal_log: r, internal_err: o, plugin_options: u, print: s });
    }, { minimist: 130, util: 238 }], 180: [function(x, C, c) {
      var p = this && this.__importDefault || function(y) {
        return y && y.__esModule ? y : { default: y };
      };
      Object.defineProperty(c, "__esModule", { value: !0 }), c.Prior = void 0;
      const v = p(x("util")), { Ordu: n } = x("ordu"), i = x("./common"), { Inward: s } = x("./inward"), r = x("./act"), { Meta: o } = x("./meta"), u = new n({ name: "prior_inward" }).add(s.inward_msg_modify).add(s.inward_act_default).add(s.inward_msg_meta).add(s.inward_prepare_delegate);
      function a() {
        const y = this.options();
        if (this.private$.act == null)
          throw this.util.error("no_prior_action", { args: arguments });
        var T = this.private$.act.def.priordef, h = i.build_message(this, arguments, "reply:f?", this.fixedargs), _ = h.msg, g = h.reply;
        if (!T) {
          var S = _.meta$ || {}, d = _.default$ || S.dflt || null;
          return d = d == null ? d : Object.assign({}, d), y.legacy.meta_arg_remove ? g.call(this, null, d) : g.call(this, null, d, S);
        }
        if (y.prior.direct) {
          let b = function(X, K, D) {
            let j = v.default.types.isNativeError(X) ? X : null, Z = [j, K == null ? j ? null : X : K];
            return y.legacy.meta_arg_remove || Z.push(D), g.apply(O, Z);
          };
          const k = new o(this, y, _, b), O = r.intern.make_act_delegate(this, y, k, T);
          b.seneca = O;
          const A = { seneca: O, origmsg: _, reply: b, options: y, callpoint: this.private$.callpoint(), actdef: T }, l = { meta: k, msg: _, reply: b }, E = u.execSync(A, l);
          if (E.err)
            throw E.err;
          let M = T.func, B = [_, b];
          y.legacy.meta_arg_remove || B.push(l.meta), M.apply(O, B);
        } else
          _.prior$ = T.id, this.act(_, g);
      }
      const f = { api_prior: a };
      c.Prior = f;
    }, { "./act": 166, "./common": 170, "./inward": 172, "./meta": 175, ordu: 144, util: 238 }], 181: [function(x, C, c) {
      Object.defineProperty(c, "__esModule", { value: !0 }), c.make_ready = void 0;
      const p = x("./common");
      function v(r) {
        var o = r.private$;
        return o.next_ready_id = p.autoincr(), o.ready_list = [], { api_ready: n, clear_ready: i.bind(r), execute_ready: s };
      }
      function n(r) {
        var o = this;
        return setTimeout(function() {
          if (typeof r == "function") {
            var u = o.root.private$, a = function() {
              r.call(o);
            }, f = (r.name == null || r.name === "" || r.name === "ready" ? "ready_" : r.name + "_ready_") + u.next_ready_id();
            Object.defineProperty(a, "name", { value: f }), u.ge.isclear() ? s(o, a) : u.ready_list.push(a);
          }
        }, o.private$.ge.options.interval), o;
      }
      function i() {
        const r = this;
        var o = r.private$;
        if (r.emit("ready"), s(r, o.ready_list.shift()), o.ge.isclear())
          for (; 0 < o.ready_list.length; )
            s(r, o.ready_list.shift());
      }
      function s(r, o) {
        if (o != null) {
          var u = r.options();
          try {
            r.log.debug({ kind: "ready", case: "call", name: o.name }), o();
          } catch (f) {
            var a = r.error(f, "ready_failed", { message: f.message });
            u.errhandler ? u.errhandler.call(r, a) : r.die(a);
          }
        }
      }
      c.make_ready = v;
    }, { "./common": 170 }], 182: [function(x, C, c) {
      Object.defineProperty(c, "__esModule", { value: !0 }), c.api_sub = void 0;
      const p = x("./common");
      function v() {
        const n = p.parsePattern(this, arguments, "action:f"), i = n.pattern, s = n.action;
        let r = !!i.in$, o = !!i.out$;
        o || (r = !0);
        const u = this.util.clean(i);
        return [r ? this.private$.subrouter.inward : null, o ? this.private$.subrouter.outward : null].filter((a) => a).forEach((a) => {
          let f = a.find(u, !0);
          f || (a.add(u, f = []), f.pattern = p.pattern(u)), f.push(s);
        }), this;
      }
      c.api_sub = v;
    }, { "./common": 170 }], 183: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = this && this.__importDefault || function(j) {
            return j && j.__esModule ? j : { default: j };
          };
          Object.defineProperty(c, "__esModule", { value: !0 }), c.transport = void 0;
          const n = v(x("util")), i = v(x("http")), s = x("https"), r = x("qs"), o = x("url"), u = x("jsonic"), a = x("@hapi/wreck"), f = x("./common"), y = x("./legacy");
          function T(j) {
            j.add("role:transport,cmd:listen", l), j.add("role:transport,cmd:client", E), j.add("role:transport,hook:listen,type:web", M), j.add("role:transport,hook:client,type:web", K);
            const Z = {};
            Z.stringifyJSON = d, Z.parseJSON = b, Z.externalize_msg = h, Z.externalize_reply = _, Z.internalize_msg = g, Z.internalize_reply = S, Z.close = A, Z.info = function() {
              const tt = j.list(), nt = { local: {}, remote: {} };
              return tt.forEach(function(ct) {
                const ut = j.find(ct, { exact: !0 });
                ut.client ? nt.remote[ut.pattern] = ut.id : nt.local[ut.pattern] = ut.id;
              }), nt;
            }, j.private$.exports["transport/utils"] = Z;
          }
          function h(j, Z, tt) {
            if (Z)
              return Z instanceof Error && (Z = y.Legacy.copydata(Z)), Z.meta$ = tt, Z;
          }
          function _(j, Z, tt, nt) {
            let ct = Z || tt;
            return ct || (ct = {}, nt.empty = !0), ct.meta$ = nt, n.default.types.isNativeError(ct) && ((ct = y.Legacy.copydata(ct)).meta$.error = !0), ct;
          }
          function g(j, Z) {
            if (!Z)
              return;
            const tt = (Z = k(j, Z)).meta$ || {};
            return delete Z.meta$, delete Z.fatal$, Z.id$ = tt.id, Z.sync$ = tt.sync, Z.custom$ = tt.custom, Z.explain$ = tt.explain, Z.parents$ = tt.parents || [], Z.parents$.unshift(f.make_trace_desc(tt)), Z.remote$ = !0, Z;
          }
          function S(j, Z) {
            let tt = {}, nt = null, ct = null;
            return Z && (tt = Z.meta$) && (delete Z.meta$, tt.remote = !0, tt.error ? (nt = new Error(Z.message), Object.assign(nt, Z)) : tt.empty || (ct = k(j, Z))), { err: nt, out: ct, meta: tt };
          }
          function d(j) {
            if (j)
              return f.stringify(j);
          }
          function b(j) {
            if (!j)
              return;
            const Z = j.toString();
            try {
              return JSON.parse(Z);
            } catch (tt) {
              return tt.input = Z, tt;
            }
          }
          function k(j, Z) {
            return j.make$ && (Z.entity$ && (Z = j.make$(Z)), Object.keys(Z).forEach(function(tt) {
              const nt = Z[tt];
              nt && typeof nt == "object" && nt.entity$ && (Z[tt] = j.make$(nt));
            })), Z;
          }
          function O(j, Z) {
            return function(tt, nt) {
              this.private$.transport.register.push({ when: Date.now(), config: j, err: tt, res: nt }), Z(tt, nt);
            };
          }
          function A(j, Z) {
            j.add("role:seneca,cmd:close", function(tt, nt) {
              const ct = this;
              Z.call(ct, function(ut) {
                ut && ct.log.error(ut), ct.prior(tt, nt);
              });
            });
          }
          function l(j, Z) {
            const tt = Object.assign({}, j.config, { role: "transport", hook: "listen" });
            delete tt.cmd;
            const nt = this.util.clean(tt);
            this.act(nt, O(nt, Z));
          }
          function E(j, Z) {
            const tt = Object.assign({}, j.config, { role: "transport", hook: "client" });
            delete tt.cmd;
            const nt = this.util.clean(tt);
            this.act(nt, O(nt, Z));
          }
          function M(j, Z) {
            const tt = this.root.delegate(), nt = tt.options().transport, ct = tt.util.deep(j);
            ct.port = ct.port == null ? nt.port : ct.port, ct.modify_response = ct.modify_response || B;
            const ut = ct.protocol === "https" ? s.createServer(ct.custom || ct.serverOptions) : i.default.createServer();
            ut.on("request", function(ot, xt) {
              ot.setEncoding("utf8"), ot.query = r.parse(o.parse(ot.url).query);
              const Ut = [];
              ot.on("data", function(pt) {
                Ut.push(pt);
              }), ot.on("end", function() {
                let pt;
                const at = Ut.join(""), bt = b(at);
                let Q;
                const At = !(pt = n.default.types.isNativeError(bt) ? { json: at, role: "seneca", make: "error", code: "parseJSON", err: bt } : Object.assign(bt, ot.query && ot.query.msg$ ? u(ot.query.msg$) : {}, ot.query || {})).meta$ && ot.headers["seneca-id"];
                At && (pt.meta$ = { id: ot.headers["seneca-id"] }, Q = ot.headers["seneca-origin"]), pt = g(tt, pt), tt.act(pt, function(Pt, q, G) {
                  let lt = { err: Pt, out: q, meta: G, config: ct, headers: { "Content-Type": "application/json", "Cache-Control": "private, max-age=0, no-cache, no-store" } };
                  lt.status = Pt ? 500 : 200, lt = ct.modify_response(tt, lt), At && (lt.headers["seneca-id"] = At, lt.headers["seneca-origin"] = Q), xt.writeHead(lt.status, lt.headers), xt.end(lt.body);
                });
              });
            }), ut.on("error", Z), ut.on("listening", function() {
              ct.port = ut.address().port, Z(ct);
            });
            const V = function() {
              const ot = ct.port = tt.util.resolve_option(ct.port, ct), xt = ct.host = tt.util.resolve_option(ct.host, ct);
              return tt.log.debug("transport web listen", ct), ut.listen(ot, xt);
            }();
            A(tt, function(ot) {
              V && V.close(), ot();
            });
          }
          function B(j, Z) {
            return Array.isArray(Z.out) && (Z.out = { array$: Z.out, meta$: Z.out.meta$ }), Z.body = d(_(j, Z.err, Z.out, Z.meta)), Z.headers["Content-Length"] = p.byteLength(Z.body), Z;
          }
          function X() {
            return a.defaults({ agents: { http: new i.default.Agent({ keepAlive: !0, maxFreeSockets: 1 / 0 }), https: new s.Agent({ keepAlive: !0, maxFreeSockets: 1 / 0 }), httpsAllowUnauthorized: new s.Agent({ keepAlive: !0, maxFreeSockets: 1 / 0, rejectUnauthorized: !1 }) } });
          }
          function K(j, Z) {
            const tt = this.root.delegate(), nt = tt.options().transport, ct = tt.util.deep(j);
            ct.port = ct.port == null ? nt.port : ct.port, ct.modify_request = ct.modify_request || D, ct.port = tt.util.resolve_option(ct.port, ct), ct.host = tt.util.resolve_option(ct.host, ct), ct.wreck = tt.util.resolve_option(ct.wreck || X, ct), Z({ config: ct, send: function(ut, V, ot) {
              const xt = this;
              let Ut = { msg: ut, meta: ot, url: ct.protocol + "://" + ct.host + ":" + ct.port + ct.path, method: "POST", headers: { Accept: "application/json", "Content-Type": "application/json" } };
              Ut = ct.modify_request(tt, Ut), ct.wreck.request(Ut.method, Ut.url, Ut.wreck).then(function(pt) {
                const at = function(bt) {
                  bt.meta$ || (bt.meta$ = { id: ot.id });
                  let Q = S(xt, bt);
                  V(Q.err, Q.out, Q.meta);
                };
                a.read(pt, Ut.wreck.read).then(function(bt) {
                  let Q = b(bt);
                  if (Array.isArray(Q.array$)) {
                    const At = Q.array$;
                    At.meta$ = Q.meta$, Q = At;
                  }
                  at(Q);
                }).catch(at);
              }).catch(function(pt) {
                return V(pt);
              });
            } });
          }
          function D(j, Z) {
            return Z.body = d(h(j, Z.msg, Z.meta)), Z.headers["Content-Length"] = p.byteLength(Z.body), Z.wreck = { json: !1, headers: Z.headers, payload: Z.body, read: {} }, Z;
          }
          c.transport = T;
        }).call(this);
      }).call(this, x("buffer").Buffer);
    }, { "./common": 170, "./legacy": 173, "@hapi/wreck": 28, buffer: 46, http: 208, https: 108, jsonic: 119, qs: 185, url: 229, util: 238 }], 184: [function(x, C, c) {
      var p = String.prototype.replace, v = /%20/g, n = { RFC1738: "RFC1738", RFC3986: "RFC3986" };
      C.exports = { default: n.RFC3986, formatters: { RFC1738: function(i) {
        return p.call(i, v, "+");
      }, RFC3986: function(i) {
        return String(i);
      } }, RFC1738: n.RFC1738, RFC3986: n.RFC3986 };
    }, {}], 185: [function(x, C, c) {
      var p = x("./stringify"), v = x("./parse"), n = x("./formats");
      C.exports = { formats: n, parse: v, stringify: p };
    }, { "./formats": 184, "./parse": 186, "./stringify": 187 }], 186: [function(x, C, c) {
      var p = x("./utils"), v = Object.prototype.hasOwnProperty, n = Array.isArray, i = { allowDots: !1, allowPrototypes: !1, allowSparse: !1, arrayLimit: 20, charset: "utf-8", charsetSentinel: !1, comma: !1, decoder: p.decode, delimiter: "&", depth: 5, ignoreQueryPrefix: !1, interpretNumericEntities: !1, parameterLimit: 1e3, parseArrays: !0, plainObjects: !1, strictNullHandling: !1 }, s = function(h) {
        return h.replace(/&#(\d+);/g, function(_, g) {
          return String.fromCharCode(parseInt(g, 10));
        });
      }, r = function(h, _) {
        return h && typeof h == "string" && _.comma && h.indexOf(",") > -1 ? h.split(",") : h;
      }, o = "utf8=%26%2310003%3B", u = "utf8=%E2%9C%93", a = function(h, _) {
        var g, S = {}, d = _.ignoreQueryPrefix ? h.replace(/^\?/, "") : h, b = _.parameterLimit === 1 / 0 ? void 0 : _.parameterLimit, k = d.split(_.delimiter, b), O = -1, A = _.charset;
        if (_.charsetSentinel)
          for (g = 0; g < k.length; ++g)
            k[g].indexOf("utf8=") === 0 && (k[g] === u ? A = "utf-8" : k[g] === o && (A = "iso-8859-1"), O = g, g = k.length);
        for (g = 0; g < k.length; ++g)
          if (g !== O) {
            var l, E, M = k[g], B = M.indexOf("]="), X = B === -1 ? M.indexOf("=") : B + 1;
            X === -1 ? (l = _.decoder(M, i.decoder, A, "key"), E = _.strictNullHandling ? null : "") : (l = _.decoder(M.slice(0, X), i.decoder, A, "key"), E = p.maybeMap(r(M.slice(X + 1), _), function(K) {
              return _.decoder(K, i.decoder, A, "value");
            })), E && _.interpretNumericEntities && A === "iso-8859-1" && (E = s(E)), M.indexOf("[]=") > -1 && (E = n(E) ? [E] : E), v.call(S, l) ? S[l] = p.combine(S[l], E) : S[l] = E;
          }
        return S;
      }, f = function(h, _, g, S) {
        for (var d = S ? _ : r(_, g), b = h.length - 1; b >= 0; --b) {
          var k, O = h[b];
          if (O === "[]" && g.parseArrays)
            k = [].concat(d);
          else {
            k = g.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
            var A = O.charAt(0) === "[" && O.charAt(O.length - 1) === "]" ? O.slice(1, -1) : O, l = parseInt(A, 10);
            g.parseArrays || A !== "" ? !isNaN(l) && O !== A && String(l) === A && l >= 0 && g.parseArrays && l <= g.arrayLimit ? (k = [])[l] = d : A !== "__proto__" && (k[A] = d) : k = { 0: d };
          }
          d = k;
        }
        return d;
      }, y = function(h, _, g, S) {
        if (h) {
          var d = g.allowDots ? h.replace(/\.([^.[]+)/g, "[$1]") : h, b = /(\[[^[\]]*])/g, k = g.depth > 0 && /(\[[^[\]]*])/.exec(d), O = k ? d.slice(0, k.index) : d, A = [];
          if (O) {
            if (!g.plainObjects && v.call(Object.prototype, O) && !g.allowPrototypes)
              return;
            A.push(O);
          }
          for (var l = 0; g.depth > 0 && (k = b.exec(d)) !== null && l < g.depth; ) {
            if (l += 1, !g.plainObjects && v.call(Object.prototype, k[1].slice(1, -1)) && !g.allowPrototypes)
              return;
            A.push(k[1]);
          }
          return k && A.push("[" + d.slice(k.index) + "]"), f(A, _, g, S);
        }
      }, T = function(h) {
        if (!h)
          return i;
        if (h.decoder !== null && h.decoder !== void 0 && typeof h.decoder != "function")
          throw new TypeError("Decoder has to be a function.");
        if (h.charset !== void 0 && h.charset !== "utf-8" && h.charset !== "iso-8859-1")
          throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var _ = h.charset === void 0 ? i.charset : h.charset;
        return { allowDots: h.allowDots === void 0 ? i.allowDots : !!h.allowDots, allowPrototypes: typeof h.allowPrototypes == "boolean" ? h.allowPrototypes : i.allowPrototypes, allowSparse: typeof h.allowSparse == "boolean" ? h.allowSparse : i.allowSparse, arrayLimit: typeof h.arrayLimit == "number" ? h.arrayLimit : i.arrayLimit, charset: _, charsetSentinel: typeof h.charsetSentinel == "boolean" ? h.charsetSentinel : i.charsetSentinel, comma: typeof h.comma == "boolean" ? h.comma : i.comma, decoder: typeof h.decoder == "function" ? h.decoder : i.decoder, delimiter: typeof h.delimiter == "string" || p.isRegExp(h.delimiter) ? h.delimiter : i.delimiter, depth: typeof h.depth == "number" || h.depth === !1 ? +h.depth : i.depth, ignoreQueryPrefix: h.ignoreQueryPrefix === !0, interpretNumericEntities: typeof h.interpretNumericEntities == "boolean" ? h.interpretNumericEntities : i.interpretNumericEntities, parameterLimit: typeof h.parameterLimit == "number" ? h.parameterLimit : i.parameterLimit, parseArrays: h.parseArrays !== !1, plainObjects: typeof h.plainObjects == "boolean" ? h.plainObjects : i.plainObjects, strictNullHandling: typeof h.strictNullHandling == "boolean" ? h.strictNullHandling : i.strictNullHandling };
      };
      C.exports = function(h, _) {
        var g = T(_);
        if (h === "" || h == null)
          return g.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        for (var S = typeof h == "string" ? a(h, g) : h, d = g.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, b = Object.keys(S), k = 0; k < b.length; ++k) {
          var O = b[k], A = y(O, S[O], g, typeof h == "string");
          d = p.merge(d, A, g);
        }
        return g.allowSparse === !0 ? d : p.compact(d);
      };
    }, { "./utils": 188 }], 187: [function(x, C, c) {
      var p = x("side-channel"), v = x("./utils"), n = x("./formats"), i = Object.prototype.hasOwnProperty, s = { brackets: function(d) {
        return d + "[]";
      }, comma: "comma", indices: function(d, b) {
        return d + "[" + b + "]";
      }, repeat: function(d) {
        return d;
      } }, r = Array.isArray, o = String.prototype.split, u = Array.prototype.push, a = function(d, b) {
        u.apply(d, r(b) ? b : [b]);
      }, f = Date.prototype.toISOString, y = n.default, T = { addQueryPrefix: !1, allowDots: !1, charset: "utf-8", charsetSentinel: !1, delimiter: "&", encode: !0, encoder: v.encode, encodeValuesOnly: !1, format: y, formatter: n.formatters[y], indices: !1, serializeDate: function(d) {
        return f.call(d);
      }, skipNulls: !1, strictNullHandling: !1 }, h = function(d) {
        return typeof d == "string" || typeof d == "number" || typeof d == "boolean" || typeof d == "symbol" || typeof d == "bigint";
      }, _ = {}, g = function d(b, k, O, A, l, E, M, B, X, K, D, j, Z, tt, nt, ct) {
        for (var ut = b, V = ct, ot = 0, xt = !1; (V = V.get(_)) !== void 0 && !xt; ) {
          var Ut = V.get(b);
          if (ot += 1, Ut !== void 0) {
            if (Ut === ot)
              throw new RangeError("Cyclic object value");
            xt = !0;
          }
          V.get(_) === void 0 && (ot = 0);
        }
        if (typeof B == "function" ? ut = B(k, ut) : ut instanceof Date ? ut = D(ut) : O === "comma" && r(ut) && (ut = v.maybeMap(ut, function(P) {
          return P instanceof Date ? D(P) : P;
        })), ut === null) {
          if (l)
            return M && !tt ? M(k, T.encoder, nt, "key", j) : k;
          ut = "";
        }
        if (h(ut) || v.isBuffer(ut)) {
          if (M) {
            var pt = tt ? k : M(k, T.encoder, nt, "key", j);
            if (O === "comma" && tt) {
              for (var at = o.call(String(ut), ","), bt = "", Q = 0; Q < at.length; ++Q)
                bt += (Q === 0 ? "" : ",") + Z(M(at[Q], T.encoder, nt, "value", j));
              return [Z(pt) + (A && r(ut) && at.length === 1 ? "[]" : "") + "=" + bt];
            }
            return [Z(pt) + "=" + Z(M(ut, T.encoder, nt, "value", j))];
          }
          return [Z(k) + "=" + Z(String(ut))];
        }
        var At, Pt = [];
        if (ut === void 0)
          return Pt;
        if (O === "comma" && r(ut))
          At = [{ value: ut.length > 0 ? ut.join(",") || null : void 0 }];
        else if (r(B))
          At = B;
        else {
          var q = Object.keys(ut);
          At = X ? q.sort(X) : q;
        }
        for (var G = A && r(ut) && ut.length === 1 ? k + "[]" : k, lt = 0; lt < At.length; ++lt) {
          var It = At[lt], Ft = typeof It == "object" && It.value !== void 0 ? It.value : ut[It];
          if (!E || Ft !== null) {
            var H = r(ut) ? typeof O == "function" ? O(G, It) : G : G + (K ? "." + It : "[" + It + "]");
            ct.set(b, ot);
            var F = p();
            F.set(_, ct), a(Pt, d(Ft, H, O, A, l, E, M, B, X, K, D, j, Z, tt, nt, F));
          }
        }
        return Pt;
      }, S = function(d) {
        if (!d)
          return T;
        if (d.encoder !== null && d.encoder !== void 0 && typeof d.encoder != "function")
          throw new TypeError("Encoder has to be a function.");
        var b = d.charset || T.charset;
        if (d.charset !== void 0 && d.charset !== "utf-8" && d.charset !== "iso-8859-1")
          throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var k = n.default;
        if (d.format !== void 0) {
          if (!i.call(n.formatters, d.format))
            throw new TypeError("Unknown format option provided.");
          k = d.format;
        }
        var O = n.formatters[k], A = T.filter;
        return (typeof d.filter == "function" || r(d.filter)) && (A = d.filter), { addQueryPrefix: typeof d.addQueryPrefix == "boolean" ? d.addQueryPrefix : T.addQueryPrefix, allowDots: d.allowDots === void 0 ? T.allowDots : !!d.allowDots, charset: b, charsetSentinel: typeof d.charsetSentinel == "boolean" ? d.charsetSentinel : T.charsetSentinel, delimiter: d.delimiter === void 0 ? T.delimiter : d.delimiter, encode: typeof d.encode == "boolean" ? d.encode : T.encode, encoder: typeof d.encoder == "function" ? d.encoder : T.encoder, encodeValuesOnly: typeof d.encodeValuesOnly == "boolean" ? d.encodeValuesOnly : T.encodeValuesOnly, filter: A, format: k, formatter: O, serializeDate: typeof d.serializeDate == "function" ? d.serializeDate : T.serializeDate, skipNulls: typeof d.skipNulls == "boolean" ? d.skipNulls : T.skipNulls, sort: typeof d.sort == "function" ? d.sort : null, strictNullHandling: typeof d.strictNullHandling == "boolean" ? d.strictNullHandling : T.strictNullHandling };
      };
      C.exports = function(d, b) {
        var k, O = d, A = S(b);
        typeof A.filter == "function" ? O = (0, A.filter)("", O) : r(A.filter) && (k = A.filter);
        var l, E = [];
        if (typeof O != "object" || O === null)
          return "";
        l = b && b.arrayFormat in s ? b.arrayFormat : b && "indices" in b ? b.indices ? "indices" : "repeat" : "indices";
        var M = s[l];
        if (b && "commaRoundTrip" in b && typeof b.commaRoundTrip != "boolean")
          throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var B = M === "comma" && b && b.commaRoundTrip;
        k || (k = Object.keys(O)), A.sort && k.sort(A.sort);
        for (var X = p(), K = 0; K < k.length; ++K) {
          var D = k[K];
          A.skipNulls && O[D] === null || a(E, g(O[D], D, M, B, A.strictNullHandling, A.skipNulls, A.encode ? A.encoder : null, A.filter, A.sort, A.allowDots, A.serializeDate, A.format, A.formatter, A.encodeValuesOnly, A.charset, X));
        }
        var j = E.join(A.delimiter), Z = A.addQueryPrefix === !0 ? "?" : "";
        return A.charsetSentinel && (A.charset === "iso-8859-1" ? Z += "utf8=%26%2310003%3B&" : Z += "utf8=%E2%9C%93&"), j.length > 0 ? Z + j : "";
      };
    }, { "./formats": 184, "./utils": 188, "side-channel": 191 }], 188: [function(x, C, c) {
      var p = x("./formats"), v = Object.prototype.hasOwnProperty, n = Array.isArray, i = function() {
        for (var S = [], d = 0; d < 256; ++d)
          S.push("%" + ((d < 16 ? "0" : "") + d.toString(16)).toUpperCase());
        return S;
      }(), s = function(S) {
        for (; S.length > 1; ) {
          var d = S.pop(), b = d.obj[d.prop];
          if (n(b)) {
            for (var k = [], O = 0; O < b.length; ++O)
              b[O] !== void 0 && k.push(b[O]);
            d.obj[d.prop] = k;
          }
        }
      }, r = function(S, d) {
        for (var b = d && d.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, k = 0; k < S.length; ++k)
          S[k] !== void 0 && (b[k] = S[k]);
        return b;
      }, o = function S(d, b, k) {
        if (!b)
          return d;
        if (typeof b != "object") {
          if (n(d))
            d.push(b);
          else {
            if (!d || typeof d != "object")
              return [d, b];
            (k && (k.plainObjects || k.allowPrototypes) || !v.call(Object.prototype, b)) && (d[b] = !0);
          }
          return d;
        }
        if (!d || typeof d != "object")
          return [d].concat(b);
        var O = d;
        return n(d) && !n(b) && (O = r(d, k)), n(d) && n(b) ? (b.forEach(function(A, l) {
          if (v.call(d, l)) {
            var E = d[l];
            E && typeof E == "object" && A && typeof A == "object" ? d[l] = S(E, A, k) : d.push(A);
          } else
            d[l] = A;
        }), d) : Object.keys(b).reduce(function(A, l) {
          var E = b[l];
          return v.call(A, l) ? A[l] = S(A[l], E, k) : A[l] = E, A;
        }, O);
      }, u = function(S, d) {
        return Object.keys(d).reduce(function(b, k) {
          return b[k] = d[k], b;
        }, S);
      }, a = function(S, d, b) {
        var k = S.replace(/\+/g, " ");
        if (b === "iso-8859-1")
          return k.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
          return decodeURIComponent(k);
        } catch (O) {
          return k;
        }
      }, f = function(S, d, b, k, O) {
        if (S.length === 0)
          return S;
        var A = S;
        if (typeof S == "symbol" ? A = Symbol.prototype.toString.call(S) : typeof S != "string" && (A = String(S)), b === "iso-8859-1")
          return escape(A).replace(/%u[0-9a-f]{4}/gi, function(B) {
            return "%26%23" + parseInt(B.slice(2), 16) + "%3B";
          });
        for (var l = "", E = 0; E < A.length; ++E) {
          var M = A.charCodeAt(E);
          M === 45 || M === 46 || M === 95 || M === 126 || M >= 48 && M <= 57 || M >= 65 && M <= 90 || M >= 97 && M <= 122 || O === p.RFC1738 && (M === 40 || M === 41) ? l += A.charAt(E) : M < 128 ? l += i[M] : M < 2048 ? l += i[192 | M >> 6] + i[128 | 63 & M] : M < 55296 || M >= 57344 ? l += i[224 | M >> 12] + i[128 | M >> 6 & 63] + i[128 | 63 & M] : (E += 1, M = 65536 + ((1023 & M) << 10 | 1023 & A.charCodeAt(E)), l += i[240 | M >> 18] + i[128 | M >> 12 & 63] + i[128 | M >> 6 & 63] + i[128 | 63 & M]);
        }
        return l;
      }, y = function(S) {
        for (var d = [{ obj: { o: S }, prop: "o" }], b = [], k = 0; k < d.length; ++k)
          for (var O = d[k], A = O.obj[O.prop], l = Object.keys(A), E = 0; E < l.length; ++E) {
            var M = l[E], B = A[M];
            typeof B == "object" && B !== null && b.indexOf(B) === -1 && (d.push({ obj: A, prop: M }), b.push(B));
          }
        return s(d), S;
      }, T = function(S) {
        return Object.prototype.toString.call(S) === "[object RegExp]";
      }, h = function(S) {
        return !(!S || typeof S != "object") && !!(S.constructor && S.constructor.isBuffer && S.constructor.isBuffer(S));
      }, _ = function(S, d) {
        return [].concat(S, d);
      }, g = function(S, d) {
        if (n(S)) {
          for (var b = [], k = 0; k < S.length; k += 1)
            b.push(d(S[k]));
          return b;
        }
        return d(S);
      };
      C.exports = { arrayToObject: r, assign: u, combine: _, compact: y, decode: a, encode: f, isBuffer: h, isRegExp: T, maybeMap: g, merge: o };
    }, { "./formats": 184 }], 189: [function(x, C, c) {
      C.exports = {
        name: "seneca",
        description: "A Microservices Framework for Node.js",
        version: "4.0.0-t.1.p.1",
        license: "MIT",
        homepage: "http://senecajs.org",
        keywords: [
          "micro",
          "service",
          "microservice",
          "micro-service",
          "microservices",
          "micro-services",
          "services",
          "micro services",
          "micro service",
          "framework",
          "minimum",
          "viable",
          "product",
          "toolkit",
          "startup"
        ],
        author: "Richard Rodger (http://richardrodger.com/)",
        contributors: [
          "Adrien Becchis (https://github.com/AdrieanKhisbe)",
          "Alexandru Mircea (https://github.com/mirceaalexandru)",
          "Adrian Rossouw (http://daemon.co.za)",
          "Colin Ihrig (https://github.com/cjihrig)",
          "Cristian Ianto (https://github.com/iantocristian)",
          "Cristian Kiss (https://github.com/ckiss)",
          "David Mark Clements (https://github.com/davidmarkclements)",
          "Dean McDonnell (https://github.com/mcdonnelldean)",
          "Dominic Tarr (https://github.com/dominictarr)",
          "Dustin Deus (https://github.com/StarpTech)",
          "Glen Keane (https://github.com/thekemkid)",
          "Gege Pincin (https://github.com/Georgette)",
          "Jake Pruitt (https://github.com/jakepruitt)",
          "Maciej Małecki (http://mmalecki.com)",
          "Matteo Collina (https://github.com/mcollina)",
          "Marian Radulescu (https://github.com/marianr)",
          "Marius Ursache (https://github.com/bamse16)",
          "Martin Betak (https://github.com/matobet)",
          "Maxence Dalmais (https://github.com/maxired)",
          "Mihai Dima (https://github.com/mihaidma)",
          "Naomi Feehan (https://github.com/naomifeehan)",
          "Paolo Chiodi (https://github.com/paolochiodi)",
          "Peter Elger (https://github.com/pelger)",
          "Reto Inderbitzin (https://github.com/indr)",
          "Reid Rankin (https://github.com/reidrankin)",
          "Tane Piper (https://github.com/tanepiper)",
          "Wyatt Preul (https://github.com/geek)",
          "Vald Houbiev (https://github.com/vladgolubev)",
          "Vito Tardia (https://github.com/vtardia)"
        ],
        repository: {
          type: "git",
          url: "https://github.com/senecajs/seneca.git"
        },
        files: [
          "LICENSE",
          "README.md",
          "CHANGES.md",
          "lib",
          "seneca.js"
        ],
        engines: {
          node: ">=14"
        },
        main: "seneca.js",
        scripts: {
          watch: "tsc -w -d",
          build: "tsc -d",
          test: "lab -v -P test -L -t 90 --sourcemaps --transform node_modules/lab-transform-typescript -I AggregateError,atob,btoa,AbortController,AbortSignal,EventTarget,Event,MessageChannel,MessagePort,MessageEvent,performance -r console -o stdout -r html -o test/coverage.html",
          "test-some": "lab -v -P test --sourcemaps --transform node_modules/lab-transform-typescript -g",
          coveralls: "lab -s -P test -I AggregateError,atob,btoa,DOMException,AbortController,AbortSignal,EventTarget,Event,MessageChannel,MessagePort,MessageEvent,performance,structuredClone -r lcov > ./coverage/lcov.info",
          coverage: "lab -v -P test -L -t 90 -r html > docs/coverage.html",
          smoke: "node test/stubs/launch.js",
          prettier: "prettier --write *.js lib/*.js test/*.js",
          clean: "rm -rf node_modules package-lock.json yarn.lock",
          reset: "npm run clean && npm i && npm run build && npm test",
          "repo-tag": "REPO_VERSION=`node -e \"console.log(require('./package').version)\"` && echo TAG: v$REPO_VERSION && git commit -a -m v$REPO_VERSION && git push && git tag v$REPO_VERSION && git push --tags;",
          "repo-publish": "npm run clean && npm i && npm run repo-publish-quick",
          "repo-publish-quick": "npm run prettier && npm run build && npm run test && npm run repo-tag && npm publish --access public --registry https://registry.npmjs.org"
        },
        dependencies: {
          eraro: "^2.1.0",
          "fast-safe-stringify": "^2.1.1",
          "gate-executor": "^3.1.1",
          gubu: "^3.1.0",
          jsonic: "^1.0.1",
          "lodash.defaultsdeep": "^4.6.1",
          "lodash.flatten": "^4.4.0",
          "lodash.uniq": "^4.5.0",
          minimist: "^1.2.6",
          nid: "^2.0.0",
          norma: "^2.0.2",
          ordu: "^2.2.0",
          patrun: "^7.2.4",
          qs: "^6.10.5",
          "rolling-stats": "^0.2.1",
          "use-plugin": "^10.0.0"
        },
        devDependencies: {
          "@hapi/code": "^9.0.1",
          "@hapi/lab": "^25.0.1",
          "@seneca/test-plugin": "0.1.0",
          "@types/node": "^18.0.0",
          async: "^3.2.4",
          bench: "^0.3.6",
          coveralls: "^3.1.1",
          gex: "^4.0.1",
          handlebars: "^4.7.7",
          "lab-transform-typescript": "^3.0.1",
          lolex: "^6.0.0",
          prettier: "^2.7.1",
          "seneca-entity": "^17.0.1",
          "seneca-error-test": "^0.2.2",
          "seneca-promisify": "^2.4.1",
          summary: "^2.1.0",
          typescript: "^4.7.4"
        }
      };
    }, {}], 190: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = this && this.__importDefault || function(Pt) {
            return Pt && Pt.__esModule ? Pt : { default: Pt };
          };
          Object.defineProperty(c, "__esModule", { value: !0 });
          const n = x("events"), i = x("util"), s = x("gate-executor"), r = x("jsonic"), o = x("use-plugin"), u = v(x("nid")), a = x("patrun"), f = x("rolling-stats"), { Ordu: y } = x("ordu"), { Gubu: T, One: h, Any: _, Skip: g, Open: S } = x("gubu"), d = x("eraro"), b = x("./lib/common"), { make_logging: k } = x("./lib/logging"), { API: O } = x("./lib/api"), { make_ready: A } = x("./lib/ready"), l = x("./lib/act"), E = x("./lib/add"), M = x("./lib/sub"), B = x("./lib/prior"), X = x("./lib/plugin"), { Inward: K } = x("./lib/inward"), { Outward: D } = x("./lib/outward"), { Legacy: j } = x("./lib/legacy"), { resolve_options: Z } = x("./lib/options"), tt = x("./package.json"), { Print: nt } = x("./lib/print"), { addActions: ct } = x("./lib/actions"), { transport: ut } = x("./lib/transport"), { error: V, deep: ot } = b, xt = { tag: "-", timeout: 22222, idlen: 12, didlen: 4, id$: g(String), default_plugins: S({ transport: !0 }), test: !1, quiet: !1, log: _(k().default_logspec), logger: h(Function, Object, String, null), death_delay: 11111, deathdelay: 11111, close_delay: 22222, errhandler: g(h(Function, null)), from: g(String), module: g(), error: { capture: { callback: !0, action: !0 } }, valid: { active: !0, message: !0, option: !0, plugin: !0 }, debug: { fragile: !1, undead: !1, print: { options: !1, fatal: "summary", env: !1, err: !1, depth: 2 }, act_caller: !1, short_logs: !1, callpoint: !1, deprecation: !0, argv: h([], null), env: h({}, null), datalen: 111 }, strict: { result: !0, fixedargs: !0, add: !1, find: !0, maxloop: 11, exports: !1 }, history: { active: !0, prune: !0, interval: 100 }, trace: { act: h(Function, !1), stack: !1, unknown: h(String, !0), invalid: !1 }, stats: { size: 1024, interval: 6e4, running: !1 }, plugin: {}, plugins: h({}, [], null), system: { exit: (...Pt) => {
            p.exit(...Pt);
          }, close_signals: { SIGHUP: !1, SIGTERM: !1, SIGINT: !1, SIGBREAK: !1 }, plugin: { load_once: !1 } }, internal: S({ print: { log: h(Function, null), err: h(Function, null) } }), status: { interval: 6e4, running: !1 }, transport: S({ port: 10101, host: g(String), path: g(String), protocol: g(String) }), limits: { maxparents: 33 }, events: {}, legacy: h(Boolean, { actdef: !1, action_signature: !1, error: !0, error_codes: !1, fail: !1, logging: !1, meta: !1, meta_arg_remove: !1, transport: !0, timeout_string: !0, rules: !1, options: !0 }), order: { add: { debug: !1 }, inward: { debug: !1 }, outward: { debug: !1 }, use: { debug: !1 } }, prior: { direct: !1 }, reload$: g(Boolean), actcache: _(), seneca: _() }, Ut = { Eraro: d, Jsonic: r, Nid: u.default, Patrun: a.Patrun, Gex: a.Gex, clean: b.clean, pattern: b.pattern, print: b.print, error: V, deep: b.deep, Gubu: T, deepextend: b.deep, parsepattern: b.parsePattern, pincanon: b.pincanon, router: function() {
            return (0, a.Patrun)();
          }, resolve_option: b.resolve_option, argprops: j.argprops, recurse: j.recurse, copydata: j.copydata, nil: j.nil, flatten: j.flatten }, pt = { util: Ut };
          function at() {
            n.EventEmitter.call(this), this.setMaxListeners(0);
          }
          function bt(Pt, q) {
            var G = ot({}, typeof Pt == "string" ? { from: Pt } : Pt, q);
            G.deathdelay = G.death_delay;
            var lt = Q(G), It = lt.options();
            lt.log.debug({ kind: "notice", options: kn(Ge({}, It), { internal: null }) }), nt.print_options(lt, It), It.plugins = It.plugins == null ? {} : It.plugins;
            for (var Ft = Object.keys(It.plugins), H = 0; H < Ft.length; H++) {
              var F = Ft[H], P = It.plugins[F];
              P === !1 ? lt.private$.ignore_plugins[F] = !0 : lt.use(P);
            }
            return lt.ready(function() {
              this.log.info({ kind: "notice", data: "hello " + this.id });
            }), lt;
          }
          function Q(Pt) {
            var q = At();
            q.error = V;
            var G = new at();
            G.private$ = q, q.optioner = Z(C, xt, Pt);
            var lt = q.optioner.get();
            q.print = { log: lt.internal.print.log || nt.internal_log, err: lt.internal.print.err || nt.internal_err }, q.actrouter = lt.internal.actrouter || (0, a.Patrun)({ gex: !0 });
            var It = lt.internal.subrouter || {};
            q.subrouter = { inward: It.inward || (0, a.Patrun)({ gex: !0 }), outward: It.outward || (0, a.Patrun)({ gex: !0 }) }, ["log", "act_in", "act_out", "act_err", "ready", "close"].forEach(function(U) {
              typeof lt.events[U] == "function" && G.on(U, lt.events[U]);
            }), q.actnid = (0, u.default)({ length: lt.idlen }), q.didnid = (0, u.default)({ length: lt.didlen }), q.next_action_id = b.autoincr();
            var Ft = q.callpoint = b.make_callpoint(lt.debug.callpoint);
            G.start_time = Date.now(), G.context = {}, G.version = tt.version, G.fixedargs = {}, G.flags = { closed: !1 }, Object.defineProperty(G, "root", { value: G }), q.history = b.history(lt.history);
            const H = A(G);
            G.order = {};
            const F = X.Plugin.api_use(Ft, { debug: !!lt.debug.ordu || !!lt.order.use.debug });
            G.use = F.use, G.order.plugin = F.ordu, G.toString = O.toString, G.has = O.has, G.find = O.find, G.list = O.list, G.status = O.status, G.reply = O.reply, G.sub = M.api_sub, G.list_plugins = O.list_plugins, G.find_plugin = O.find_plugin, G.has_plugin = O.has_plugin, G.ignore_plugin = O.ignore_plugin, G.listen = O.listen(Ft), G.client = O.client(Ft), G.gate = O.gate, G.ungate = O.ungate, G.translate = O.translate, G.ping = O.ping, G.test = O.test, G.quiet = O.quiet, G.export = O.export, G.depends = O.depends, G.delegate = O.delegate, G.prior = B.Prior.api_prior, G.inward = O.inward, G.outward = O.outward, G.error = O.error, G.fail = lt.legacy.fail ? j.make_legacy_fail(lt) : O.fail, G.explain = O.explain, G.decorate = O.decorate, G.seneca = O.seneca, G.close = O.close(Ft), G.options = O.options, G.fix = O.fix, G.wrap = O.wrap, G.add = E.api_add, G.act = l.api_act, G.ready = H.api_ready, G.valid = T, G.internal = function() {
              return { ordu: { use: F.ordu } };
            }, G.findact = G.find, G.plugins = O.list_plugins, G.findplugin = O.find_plugin, G.hasplugin = O.has_plugin, G.hasact = j.hasact, G.act_if = j.act_if, G.findpins = j.findpins, G.pinact = j.findpins, G.next_act = j.next_act, G.idgen = (0, u.default)({ length: lt.idlen }), lt.tag = lt.tag != null ? lt.tag : xt.tag, G.id = lt.id$ || G.idgen() + "/" + G.start_time + "/" + p.pid + "/" + G.version + "/" + lt.tag, G.tag = lt.tag, (lt.debug.short_logs || lt.log.short) && (lt.idlen = 2, G.idgen = (0, u.default)({ length: lt.idlen }), G.id = G.idgen() + "/" + lt.tag), G.fullname = "Seneca/" + G.id, G.die = b.makedie(G, { type: "sys", plugin: "seneca", tag: G.version, id: G.id, callpoint: Ft }), G.util = Ut, q.exports = { options: lt }, q.decorations = {}, G.on("error", G.die), q.ge = s({ timeout: lt.timeout }).clear(H.clear_ready).start(), lt.status.interval > 0 && lt.status.running && (q.stats = q.stats || {}, q.status_interval = setInterval(function() {
              G.log.info({ kind: "status", alive: Date.now() - q.stats.start, act: q.stats.act });
            }, lt.status.interval)), lt.stats && (q.timestats = new f.NamedStats(lt.stats.size, lt.stats.interval), lt.stats.running && setInterval(function() {
              q.timestats.calculate();
            }, lt.stats.interval)), q.plugin_order = { byname: [], byref: [] }, q.use = o({ prefix: ["seneca-", "@seneca/"], module: lt.internal.module || C, msgprefix: !1, builtin: "", merge_defaults: !1 }), q.action_modifiers = [function(U) {
              U.rules = Object.assign(U.rules, ot({}, U.func.validate || {}));
            }], q.sub = { handler: null, tracers: [] }, G.order.add = new y({ name: "add", debug: !!lt.debug.ordu || !!lt.order.add.debug }).add(E.task.prepare).add(E.task.plugin).add(E.task.callpoint).add(E.task.flags).add(E.task.action).add(E.task.prior).add(E.task.rules).add(E.task.register).add(E.task.modify), G.order.inward = new y({ name: "inward", debug: !!lt.debug.ordu || !!lt.order.inward.debug }).add(K.inward_msg_modify).add(K.inward_closed).add(K.inward_act_cache).add(K.inward_act_default).add(K.inward_act_not_found).add(K.inward_act_stats).add(K.inward_validate_msg).add(K.inward_warnings).add(K.inward_msg_meta).add(K.inward_limit_msg).add(K.inward_prepare_delegate).add(K.inward_sub).add(K.inward_announce), G.order.outward = new y({ name: "outward", debug: !!lt.debug.ordu || !!lt.order.outward.debug }).add(D.outward_make_error).add(D.outward_act_stats).add(D.outward_act_cache).add(D.outward_res_object).add(D.outward_res_entity).add(D.outward_msg_meta).add(D.outward_trace).add(D.outward_sub).add(D.outward_announce).add(D.outward_act_error), lt.logger && typeof lt.logger == "object" && (lt.logger.from_options$ = !0);
            var P = q.logging.build_log(G);
            return (lt = q.exports.options = q.optioner.set({ log: P })).test && G.test(typeof lt.test == "string" ? lt.test : null), lt.quiet && G.quiet(), q.exit_close = function() {
              G.close(function(U) {
                U && q.optioner.get().quiet != 1 && q.print.err(U), lt.system.exit(U ? U.exit === null ? 1 : U.exit : 0);
              });
            }, ct(G), lt.legacy.transport || (lt.legacy.error = !1, lt.transport = ot({ port: 62345, host: "127.0.0.1", path: "/act", protocol: "http" }, lt.transport), ut(G)), nt(G, lt.debug.argv || p.argv), b.each(lt.system.close_signals, function(U, rt) {
              U && p.once(rt, q.exit_close);
            }), G.act("sys:seneca,on:point,point:start"), G;
          }
          function At() {
            return { logging: k(), stats: { start: Date.now(), act: { calls: 0, done: 0, fails: 0, cache: 0 }, actmap: {} }, actdef: {}, transport: { register: [] }, plugins: { root$: { name: "root$", fullname: "root$", tag: "-", options: /* @__PURE__ */ Object.create(null), shared: /* @__PURE__ */ Object.create(null) } }, ignore_plugins: {} };
          }
          i.inherits(at, n.EventEmitter), at.prototype.isSeneca = !0, at.prototype.toJSON = function() {
            return { isSeneca: !0, id: this.id, did: this.did, fixedargs: this.fixedargs, fixedmeta: this.fixedmeta, start_time: this.start_time, version: this.version };
          }, at.prototype[i.inspect.custom] = at.prototype.toJSON, C.exports = bt, C.exports.Seneca = at, c.default = bt, C.exports.loghandler = j.loghandler, C.exports.use = function() {
            for (var Pt = new Array(arguments.length), q = 0; q < Pt.length; ++q)
              Pt[q] = arguments[q];
            var G = C.exports();
            return G.use.apply(G, Pt);
          }, C.exports.test = function() {
            return C.exports().test(...arguments);
          }, C.exports.quiet = function() {
            return C.exports().quiet(...arguments);
          }, C.exports.util = Ut, C.exports.valid = T, C.exports.test$ = { intern: pt };
        }).call(this);
      }).call(this, x("_process"));
    }, { "./lib/act": 166, "./lib/actions": 167, "./lib/add": 168, "./lib/api": 169, "./lib/common": 170, "./lib/inward": 172, "./lib/legacy": 173, "./lib/logging": 174, "./lib/options": 176, "./lib/outward": 177, "./lib/plugin": 178, "./lib/print": 179, "./lib/prior": 180, "./lib/ready": 181, "./lib/sub": 182, "./lib/transport": 183, "./package.json": 189, _process: 158, eraro: 51, events: 95, "gate-executor": 100, gubu: 102, jsonic: 119, nid: 131, ordu: 144, patrun: 157, "rolling-stats": 163, "use-plugin": 231, util: 238 }], 191: [function(x, C, c) {
      var p = x("get-intrinsic"), v = x("call-bind/callBound"), n = x("object-inspect"), i = p("%TypeError%"), s = p("%WeakMap%", !0), r = p("%Map%", !0), o = v("WeakMap.prototype.get", !0), u = v("WeakMap.prototype.set", !0), a = v("WeakMap.prototype.has", !0), f = v("Map.prototype.get", !0), y = v("Map.prototype.set", !0), T = v("Map.prototype.has", !0), h = function(d, b) {
        for (var k, O = d; (k = O.next) !== null; O = k)
          if (k.key === b)
            return O.next = k.next, k.next = d.next, d.next = k, k;
      }, _ = function(d, b) {
        var k = h(d, b);
        return k && k.value;
      }, g = function(d, b, k) {
        var O = h(d, b);
        O ? O.value = k : d.next = { key: b, next: d.next, value: k };
      }, S = function(d, b) {
        return !!h(d, b);
      };
      C.exports = function() {
        var d, b, k, O = { assert: function(A) {
          if (!O.has(A))
            throw new i("Side channel does not contain " + n(A));
        }, get: function(A) {
          if (s && A && (typeof A == "object" || typeof A == "function")) {
            if (d)
              return o(d, A);
          } else if (r) {
            if (b)
              return f(b, A);
          } else if (k)
            return _(k, A);
        }, has: function(A) {
          if (s && A && (typeof A == "object" || typeof A == "function")) {
            if (d)
              return a(d, A);
          } else if (r) {
            if (b)
              return T(b, A);
          } else if (k)
            return S(k, A);
          return !1;
        }, set: function(A, l) {
          s && A && (typeof A == "object" || typeof A == "function") ? (d || (d = new s()), u(d, A, l)) : r ? (b || (b = new r()), y(b, A, l)) : (k || (k = { key: {}, next: null }), g(k, A, l));
        } };
        return O;
      };
    }, { "call-bind/callBound": 48, "get-intrinsic": 101, "object-inspect": 136 }], 192: [function(x, C, c) {
      C.exports = n;
      var p = x("events").EventEmitter, v = x("inherits");
      function n() {
        p.call(this);
      }
      v(n, p), n.Readable = x("readable-stream/lib/_stream_readable.js"), n.Writable = x("readable-stream/lib/_stream_writable.js"), n.Duplex = x("readable-stream/lib/_stream_duplex.js"), n.Transform = x("readable-stream/lib/_stream_transform.js"), n.PassThrough = x("readable-stream/lib/_stream_passthrough.js"), n.finished = x("readable-stream/lib/internal/streams/end-of-stream.js"), n.pipeline = x("readable-stream/lib/internal/streams/pipeline.js"), n.Stream = n, n.prototype.pipe = function(i, s) {
        var r = this;
        function o(_) {
          i.writable && i.write(_) === !1 && r.pause && r.pause();
        }
        function u() {
          r.readable && r.resume && r.resume();
        }
        r.on("data", o), i.on("drain", u), i._isStdio || s && s.end === !1 || (r.on("end", f), r.on("close", y));
        var a = !1;
        function f() {
          a || (a = !0, i.end());
        }
        function y() {
          a || (a = !0, typeof i.destroy == "function" && i.destroy());
        }
        function T(_) {
          if (h(), p.listenerCount(this, "error") === 0)
            throw _;
        }
        function h() {
          r.removeListener("data", o), i.removeListener("drain", u), r.removeListener("end", f), r.removeListener("close", y), r.removeListener("error", T), i.removeListener("error", T), r.removeListener("end", h), r.removeListener("close", h), i.removeListener("close", h);
        }
        return r.on("error", T), i.on("error", T), r.on("end", h), r.on("close", h), i.on("close", h), i.emit("pipe", r), i;
      };
    }, { events: 95, inherits: 110, "readable-stream/lib/_stream_duplex.js": 194, "readable-stream/lib/_stream_passthrough.js": 195, "readable-stream/lib/_stream_readable.js": 196, "readable-stream/lib/_stream_transform.js": 197, "readable-stream/lib/_stream_writable.js": 198, "readable-stream/lib/internal/streams/end-of-stream.js": 202, "readable-stream/lib/internal/streams/pipeline.js": 204 }], 193: [function(x, C, c) {
      function p(u, a) {
        u.prototype = Object.create(a.prototype), u.prototype.constructor = u, u.__proto__ = a;
      }
      var v = {};
      function n(u, a, f) {
        f || (f = Error);
        var y = function(T) {
          function h(_, g, S) {
            return T.call(this, function(d, b, k) {
              return typeof a == "string" ? a : a(d, b, k);
            }(_, g, S)) || this;
          }
          return p(h, T), h;
        }(f);
        y.prototype.name = f.name, y.prototype.code = u, v[u] = y;
      }
      function i(u, a) {
        if (Array.isArray(u)) {
          var f = u.length;
          return u = u.map(function(y) {
            return String(y);
          }), f > 2 ? "one of ".concat(a, " ").concat(u.slice(0, f - 1).join(", "), ", or ") + u[f - 1] : f === 2 ? "one of ".concat(a, " ").concat(u[0], " or ").concat(u[1]) : "of ".concat(a, " ").concat(u[0]);
        }
        return "of ".concat(a, " ").concat(String(u));
      }
      function s(u, a, f) {
        return u.substr(!f || f < 0 ? 0 : +f, a.length) === a;
      }
      function r(u, a, f) {
        return (f === void 0 || f > u.length) && (f = u.length), u.substring(f - a.length, f) === a;
      }
      function o(u, a, f) {
        return typeof f != "number" && (f = 0), !(f + a.length > u.length) && u.indexOf(a, f) !== -1;
      }
      n("ERR_INVALID_OPT_VALUE", function(u, a) {
        return 'The value "' + a + '" is invalid for option "' + u + '"';
      }, TypeError), n("ERR_INVALID_ARG_TYPE", function(u, a, f) {
        var y, T;
        if (typeof a == "string" && s(a, "not ") ? (y = "must not be", a = a.replace(/^not /, "")) : y = "must be", r(u, " argument"))
          T = "The ".concat(u, " ").concat(y, " ").concat(i(a, "type"));
        else {
          var h = o(u, ".") ? "property" : "argument";
          T = 'The "'.concat(u, '" ').concat(h, " ").concat(y, " ").concat(i(a, "type"));
        }
        return T += ". Received type ".concat(typeof f);
      }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function(u) {
        return "The " + u + " method is not implemented";
      }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function(u) {
        return "Cannot call " + u + " after a stream was destroyed";
      }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function(u) {
        return "Unknown encoding: " + u;
      }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), C.exports.codes = v;
    }, {}], 194: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = Object.keys || function(y) {
            var T = [];
            for (var h in y)
              T.push(h);
            return T;
          };
          C.exports = u;
          var n = x("./_stream_readable"), i = x("./_stream_writable");
          x("inherits")(u, n);
          for (var s = v(i.prototype), r = 0; r < s.length; r++) {
            var o = s[r];
            u.prototype[o] || (u.prototype[o] = i.prototype[o]);
          }
          function u(y) {
            if (!(this instanceof u))
              return new u(y);
            n.call(this, y), i.call(this, y), this.allowHalfOpen = !0, y && (y.readable === !1 && (this.readable = !1), y.writable === !1 && (this.writable = !1), y.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", a)));
          }
          function a() {
            this._writableState.ended || p.nextTick(f, this);
          }
          function f(y) {
            y.end();
          }
          Object.defineProperty(u.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
            return this._writableState.highWaterMark;
          } }), Object.defineProperty(u.prototype, "writableBuffer", { enumerable: !1, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } }), Object.defineProperty(u.prototype, "writableLength", { enumerable: !1, get: function() {
            return this._writableState.length;
          } }), Object.defineProperty(u.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
          }, set: function(y) {
            this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = y, this._writableState.destroyed = y);
          } });
        }).call(this);
      }).call(this, x("_process"));
    }, { "./_stream_readable": 196, "./_stream_writable": 198, _process: 158, inherits: 110 }], 195: [function(x, C, c) {
      C.exports = v;
      var p = x("./_stream_transform");
      function v(n) {
        if (!(this instanceof v))
          return new v(n);
        p.call(this, n);
      }
      x("inherits")(v, p), v.prototype._transform = function(n, i, s) {
        s(null, n);
      };
    }, { "./_stream_transform": 197, inherits: 110 }], 196: [function(x, C, c) {
      (function(p, v) {
        (function() {
          var n;
          C.exports = D, D.ReadableState = K, x("events").EventEmitter;
          var i = function(H, F) {
            return H.listeners(F).length;
          }, s = x("./internal/streams/stream"), r = x("buffer").Buffer, o = v.Uint8Array || function() {
          };
          function u(H) {
            return r.from(H);
          }
          function a(H) {
            return r.isBuffer(H) || H instanceof o;
          }
          var f, y = x("util");
          f = y && y.debuglog ? y.debuglog("stream") : function() {
          };
          var T, h, _, g = x("./internal/streams/buffer_list"), S = x("./internal/streams/destroy"), d = x("./internal/streams/state"), b = d.getHighWaterMark, k = x("../errors").codes, O = k.ERR_INVALID_ARG_TYPE, A = k.ERR_STREAM_PUSH_AFTER_EOF, l = k.ERR_METHOD_NOT_IMPLEMENTED, E = k.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
          x("inherits")(D, s);
          var M = S.errorOrDestroy, B = ["error", "close", "destroy", "pause", "resume"];
          function X(H, F, P) {
            if (typeof H.prependListener == "function")
              return H.prependListener(F, P);
            H._events && H._events[F] ? Array.isArray(H._events[F]) ? H._events[F].unshift(P) : H._events[F] = [P, H._events[F]] : H.on(F, P);
          }
          function K(H, F, P) {
            n = n || x("./_stream_duplex"), H = H || {}, typeof P != "boolean" && (P = F instanceof n), this.objectMode = !!H.objectMode, P && (this.objectMode = this.objectMode || !!H.readableObjectMode), this.highWaterMark = b(this, H, "readableHighWaterMark", P), this.buffer = new g(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = H.emitClose !== !1, this.autoDestroy = !!H.autoDestroy, this.destroyed = !1, this.defaultEncoding = H.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, H.encoding && (T || (T = x("string_decoder/").StringDecoder), this.decoder = new T(H.encoding), this.encoding = H.encoding);
          }
          function D(H) {
            if (n = n || x("./_stream_duplex"), !(this instanceof D))
              return new D(H);
            var F = this instanceof n;
            this._readableState = new K(H, this, F), this.readable = !0, H && (typeof H.read == "function" && (this._read = H.read), typeof H.destroy == "function" && (this._destroy = H.destroy)), s.call(this);
          }
          function j(H, F, P, U, rt) {
            f("readableAddChunk", F);
            var ft, Ot = H._readableState;
            if (F === null)
              Ot.reading = !1, V(H, Ot);
            else if (rt || (ft = tt(Ot, F)), ft)
              M(H, ft);
            else if (Ot.objectMode || F && F.length > 0)
              if (typeof F == "string" || Ot.objectMode || Object.getPrototypeOf(F) === r.prototype || (F = u(F)), U)
                Ot.endEmitted ? M(H, new E()) : Z(H, Ot, F, !0);
              else if (Ot.ended)
                M(H, new A());
              else {
                if (Ot.destroyed)
                  return !1;
                Ot.reading = !1, Ot.decoder && !P ? (F = Ot.decoder.write(F), Ot.objectMode || F.length !== 0 ? Z(H, Ot, F, !1) : Ut(H, Ot)) : Z(H, Ot, F, !1);
              }
            else
              U || (Ot.reading = !1, Ut(H, Ot));
            return !Ot.ended && (Ot.length < Ot.highWaterMark || Ot.length === 0);
          }
          function Z(H, F, P, U) {
            F.flowing && F.length === 0 && !F.sync ? (F.awaitDrain = 0, H.emit("data", P)) : (F.length += F.objectMode ? 1 : P.length, U ? F.buffer.unshift(P) : F.buffer.push(P), F.needReadable && ot(H)), Ut(H, F);
          }
          function tt(H, F) {
            var P;
            return a(F) || typeof F == "string" || F === void 0 || H.objectMode || (P = new O("chunk", ["string", "Buffer", "Uint8Array"], F)), P;
          }
          Object.defineProperty(D.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._readableState !== void 0 && this._readableState.destroyed;
          }, set: function(H) {
            this._readableState && (this._readableState.destroyed = H);
          } }), D.prototype.destroy = S.destroy, D.prototype._undestroy = S.undestroy, D.prototype._destroy = function(H, F) {
            F(H);
          }, D.prototype.push = function(H, F) {
            var P, U = this._readableState;
            return U.objectMode ? P = !0 : typeof H == "string" && ((F = F || U.defaultEncoding) !== U.encoding && (H = r.from(H, F), F = ""), P = !0), j(this, H, F, !1, P);
          }, D.prototype.unshift = function(H) {
            return j(this, H, null, !0, !1);
          }, D.prototype.isPaused = function() {
            return this._readableState.flowing === !1;
          }, D.prototype.setEncoding = function(H) {
            T || (T = x("string_decoder/").StringDecoder);
            var F = new T(H);
            this._readableState.decoder = F, this._readableState.encoding = this._readableState.decoder.encoding;
            for (var P = this._readableState.buffer.head, U = ""; P !== null; )
              U += F.write(P.data), P = P.next;
            return this._readableState.buffer.clear(), U !== "" && this._readableState.buffer.push(U), this._readableState.length = U.length, this;
          };
          var nt = 1073741824;
          function ct(H) {
            return H >= nt ? H = nt : (H--, H |= H >>> 1, H |= H >>> 2, H |= H >>> 4, H |= H >>> 8, H |= H >>> 16, H++), H;
          }
          function ut(H, F) {
            return H <= 0 || F.length === 0 && F.ended ? 0 : F.objectMode ? 1 : H != H ? F.flowing && F.length ? F.buffer.head.data.length : F.length : (H > F.highWaterMark && (F.highWaterMark = ct(H)), H <= F.length ? H : F.ended ? F.length : (F.needReadable = !0, 0));
          }
          function V(H, F) {
            if (f("onEofChunk"), !F.ended) {
              if (F.decoder) {
                var P = F.decoder.end();
                P && P.length && (F.buffer.push(P), F.length += F.objectMode ? 1 : P.length);
              }
              F.ended = !0, F.sync ? ot(H) : (F.needReadable = !1, F.emittedReadable || (F.emittedReadable = !0, xt(H)));
            }
          }
          function ot(H) {
            var F = H._readableState;
            f("emitReadable", F.needReadable, F.emittedReadable), F.needReadable = !1, F.emittedReadable || (f("emitReadable", F.flowing), F.emittedReadable = !0, p.nextTick(xt, H));
          }
          function xt(H) {
            var F = H._readableState;
            f("emitReadable_", F.destroyed, F.length, F.ended), F.destroyed || !F.length && !F.ended || (H.emit("readable"), F.emittedReadable = !1), F.needReadable = !F.flowing && !F.ended && F.length <= F.highWaterMark, q(H);
          }
          function Ut(H, F) {
            F.readingMore || (F.readingMore = !0, p.nextTick(pt, H, F));
          }
          function pt(H, F) {
            for (; !F.reading && !F.ended && (F.length < F.highWaterMark || F.flowing && F.length === 0); ) {
              var P = F.length;
              if (f("maybeReadMore read 0"), H.read(0), P === F.length)
                break;
            }
            F.readingMore = !1;
          }
          function at(H) {
            return function() {
              var F = H._readableState;
              f("pipeOnDrain", F.awaitDrain), F.awaitDrain && F.awaitDrain--, F.awaitDrain === 0 && i(H, "data") && (F.flowing = !0, q(H));
            };
          }
          function bt(H) {
            var F = H._readableState;
            F.readableListening = H.listenerCount("readable") > 0, F.resumeScheduled && !F.paused ? F.flowing = !0 : H.listenerCount("data") > 0 && H.resume();
          }
          function Q(H) {
            f("readable nexttick read 0"), H.read(0);
          }
          function At(H, F) {
            F.resumeScheduled || (F.resumeScheduled = !0, p.nextTick(Pt, H, F));
          }
          function Pt(H, F) {
            f("resume", F.reading), F.reading || H.read(0), F.resumeScheduled = !1, H.emit("resume"), q(H), F.flowing && !F.reading && H.read(0);
          }
          function q(H) {
            var F = H._readableState;
            for (f("flow", F.flowing); F.flowing && H.read() !== null; )
              ;
          }
          function G(H, F) {
            return F.length === 0 ? null : (F.objectMode ? P = F.buffer.shift() : !H || H >= F.length ? (P = F.decoder ? F.buffer.join("") : F.buffer.length === 1 ? F.buffer.first() : F.buffer.concat(F.length), F.buffer.clear()) : P = F.buffer.consume(H, F.decoder), P);
            var P;
          }
          function lt(H) {
            var F = H._readableState;
            f("endReadable", F.endEmitted), F.endEmitted || (F.ended = !0, p.nextTick(It, F, H));
          }
          function It(H, F) {
            if (f("endReadableNT", H.endEmitted, H.length), !H.endEmitted && H.length === 0 && (H.endEmitted = !0, F.readable = !1, F.emit("end"), H.autoDestroy)) {
              var P = F._writableState;
              (!P || P.autoDestroy && P.finished) && F.destroy();
            }
          }
          function Ft(H, F) {
            for (var P = 0, U = H.length; P < U; P++)
              if (H[P] === F)
                return P;
            return -1;
          }
          D.prototype.read = function(H) {
            f("read", H), H = parseInt(H, 10);
            var F = this._readableState, P = H;
            if (H !== 0 && (F.emittedReadable = !1), H === 0 && F.needReadable && ((F.highWaterMark !== 0 ? F.length >= F.highWaterMark : F.length > 0) || F.ended))
              return f("read: emitReadable", F.length, F.ended), F.length === 0 && F.ended ? lt(this) : ot(this), null;
            if ((H = ut(H, F)) === 0 && F.ended)
              return F.length === 0 && lt(this), null;
            var U, rt = F.needReadable;
            return f("need readable", rt), (F.length === 0 || F.length - H < F.highWaterMark) && f("length less than watermark", rt = !0), F.ended || F.reading ? f("reading or ended", rt = !1) : rt && (f("do read"), F.reading = !0, F.sync = !0, F.length === 0 && (F.needReadable = !0), this._read(F.highWaterMark), F.sync = !1, F.reading || (H = ut(P, F))), (U = H > 0 ? G(H, F) : null) === null ? (F.needReadable = F.length <= F.highWaterMark, H = 0) : (F.length -= H, F.awaitDrain = 0), F.length === 0 && (F.ended || (F.needReadable = !0), P !== H && F.ended && lt(this)), U !== null && this.emit("data", U), U;
          }, D.prototype._read = function(H) {
            M(this, new l("_read()"));
          }, D.prototype.pipe = function(H, F) {
            var P = this, U = this._readableState;
            switch (U.pipesCount) {
              case 0:
                U.pipes = H;
                break;
              case 1:
                U.pipes = [U.pipes, H];
                break;
              default:
                U.pipes.push(H);
            }
            U.pipesCount += 1, f("pipe count=%d opts=%j", U.pipesCount, F);
            var rt = (!F || F.end !== !1) && H !== p.stdout && H !== p.stderr ? Ot : je;
            function ft(Ie, $e) {
              f("onunpipe"), Ie === P && $e && $e.hasUnpiped === !1 && ($e.hasUnpiped = !0, f("cleanup"), H.removeListener("close", Ce), H.removeListener("finish", _e), H.removeListener("drain", Wt), H.removeListener("error", ge), H.removeListener("unpipe", ft), P.removeListener("end", Ot), P.removeListener("end", je), P.removeListener("data", ye), ce = !0, !U.awaitDrain || H._writableState && !H._writableState.needDrain || Wt());
            }
            function Ot() {
              f("onend"), H.end();
            }
            U.endEmitted ? p.nextTick(rt) : P.once("end", rt), H.on("unpipe", ft);
            var Wt = at(P);
            H.on("drain", Wt);
            var ce = !1;
            function ye(Ie) {
              f("ondata");
              var $e = H.write(Ie);
              f("dest.write", $e), $e === !1 && ((U.pipesCount === 1 && U.pipes === H || U.pipesCount > 1 && Ft(U.pipes, H) !== -1) && !ce && (f("false write response, pause", U.awaitDrain), U.awaitDrain++), P.pause());
            }
            function ge(Ie) {
              f("onerror", Ie), je(), H.removeListener("error", ge), i(H, "error") === 0 && M(H, Ie);
            }
            function Ce() {
              H.removeListener("finish", _e), je();
            }
            function _e() {
              f("onfinish"), H.removeListener("close", Ce), je();
            }
            function je() {
              f("unpipe"), P.unpipe(H);
            }
            return P.on("data", ye), X(H, "error", ge), H.once("close", Ce), H.once("finish", _e), H.emit("pipe", P), U.flowing || (f("pipe resume"), P.resume()), H;
          }, D.prototype.unpipe = function(H) {
            var F = this._readableState, P = { hasUnpiped: !1 };
            if (F.pipesCount === 0)
              return this;
            if (F.pipesCount === 1)
              return H && H !== F.pipes ? this : (H || (H = F.pipes), F.pipes = null, F.pipesCount = 0, F.flowing = !1, H && H.emit("unpipe", this, P), this);
            if (!H) {
              var U = F.pipes, rt = F.pipesCount;
              F.pipes = null, F.pipesCount = 0, F.flowing = !1;
              for (var ft = 0; ft < rt; ft++)
                U[ft].emit("unpipe", this, { hasUnpiped: !1 });
              return this;
            }
            var Ot = Ft(F.pipes, H);
            return Ot === -1 ? this : (F.pipes.splice(Ot, 1), F.pipesCount -= 1, F.pipesCount === 1 && (F.pipes = F.pipes[0]), H.emit("unpipe", this, P), this);
          }, D.prototype.on = function(H, F) {
            var P = s.prototype.on.call(this, H, F), U = this._readableState;
            return H === "data" ? (U.readableListening = this.listenerCount("readable") > 0, U.flowing !== !1 && this.resume()) : H === "readable" && (U.endEmitted || U.readableListening || (U.readableListening = U.needReadable = !0, U.flowing = !1, U.emittedReadable = !1, f("on readable", U.length, U.reading), U.length ? ot(this) : U.reading || p.nextTick(Q, this))), P;
          }, D.prototype.addListener = D.prototype.on, D.prototype.removeListener = function(H, F) {
            var P = s.prototype.removeListener.call(this, H, F);
            return H === "readable" && p.nextTick(bt, this), P;
          }, D.prototype.removeAllListeners = function(H) {
            var F = s.prototype.removeAllListeners.apply(this, arguments);
            return H !== "readable" && H !== void 0 || p.nextTick(bt, this), F;
          }, D.prototype.resume = function() {
            var H = this._readableState;
            return H.flowing || (f("resume"), H.flowing = !H.readableListening, At(this, H)), H.paused = !1, this;
          }, D.prototype.pause = function() {
            return f("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (f("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
          }, D.prototype.wrap = function(H) {
            var F = this, P = this._readableState, U = !1;
            for (var rt in H.on("end", function() {
              if (f("wrapped end"), P.decoder && !P.ended) {
                var Ot = P.decoder.end();
                Ot && Ot.length && F.push(Ot);
              }
              F.push(null);
            }), H.on("data", function(Ot) {
              f("wrapped data"), P.decoder && (Ot = P.decoder.write(Ot)), P.objectMode && Ot == null || (P.objectMode || Ot && Ot.length) && (F.push(Ot) || (U = !0, H.pause()));
            }), H)
              this[rt] === void 0 && typeof H[rt] == "function" && (this[rt] = function(Ot) {
                return function() {
                  return H[Ot].apply(H, arguments);
                };
              }(rt));
            for (var ft = 0; ft < B.length; ft++)
              H.on(B[ft], this.emit.bind(this, B[ft]));
            return this._read = function(Ot) {
              f("wrapped _read", Ot), U && (U = !1, H.resume());
            }, this;
          }, typeof Symbol == "function" && (D.prototype[Symbol.asyncIterator] = function() {
            return h === void 0 && (h = x("./internal/streams/async_iterator")), h(this);
          }), Object.defineProperty(D.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
            return this._readableState.highWaterMark;
          } }), Object.defineProperty(D.prototype, "readableBuffer", { enumerable: !1, get: function() {
            return this._readableState && this._readableState.buffer;
          } }), Object.defineProperty(D.prototype, "readableFlowing", { enumerable: !1, get: function() {
            return this._readableState.flowing;
          }, set: function(H) {
            this._readableState && (this._readableState.flowing = H);
          } }), D._fromList = G, Object.defineProperty(D.prototype, "readableLength", { enumerable: !1, get: function() {
            return this._readableState.length;
          } }), typeof Symbol == "function" && (D.from = function(H, F) {
            return _ === void 0 && (_ = x("./internal/streams/from")), _(D, H, F);
          });
        }).call(this);
      }).call(this, x("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "../errors": 193, "./_stream_duplex": 194, "./internal/streams/async_iterator": 199, "./internal/streams/buffer_list": 200, "./internal/streams/destroy": 201, "./internal/streams/from": 203, "./internal/streams/state": 205, "./internal/streams/stream": 206, _process: 158, buffer: 46, events: 95, inherits: 110, "string_decoder/": 207, util: 42 }], 197: [function(x, C, c) {
      C.exports = u;
      var p = x("../errors").codes, v = p.ERR_METHOD_NOT_IMPLEMENTED, n = p.ERR_MULTIPLE_CALLBACK, i = p.ERR_TRANSFORM_ALREADY_TRANSFORMING, s = p.ERR_TRANSFORM_WITH_LENGTH_0, r = x("./_stream_duplex");
      function o(y, T) {
        var h = this._transformState;
        h.transforming = !1;
        var _ = h.writecb;
        if (_ === null)
          return this.emit("error", new n());
        h.writechunk = null, h.writecb = null, T != null && this.push(T), _(y);
        var g = this._readableState;
        g.reading = !1, (g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark);
      }
      function u(y) {
        if (!(this instanceof u))
          return new u(y);
        r.call(this, y), this._transformState = { afterTransform: o.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, y && (typeof y.transform == "function" && (this._transform = y.transform), typeof y.flush == "function" && (this._flush = y.flush)), this.on("prefinish", a);
      }
      function a() {
        var y = this;
        typeof this._flush != "function" || this._readableState.destroyed ? f(this, null, null) : this._flush(function(T, h) {
          f(y, T, h);
        });
      }
      function f(y, T, h) {
        if (T)
          return y.emit("error", T);
        if (h != null && y.push(h), y._writableState.length)
          throw new s();
        if (y._transformState.transforming)
          throw new i();
        return y.push(null);
      }
      x("inherits")(u, r), u.prototype.push = function(y, T) {
        return this._transformState.needTransform = !1, r.prototype.push.call(this, y, T);
      }, u.prototype._transform = function(y, T, h) {
        h(new v("_transform()"));
      }, u.prototype._write = function(y, T, h) {
        var _ = this._transformState;
        if (_.writecb = h, _.writechunk = y, _.writeencoding = T, !_.transforming) {
          var g = this._readableState;
          (_.needTransform || g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark);
        }
      }, u.prototype._read = function(y) {
        var T = this._transformState;
        T.writechunk === null || T.transforming ? T.needTransform = !0 : (T.transforming = !0, this._transform(T.writechunk, T.writeencoding, T.afterTransform));
      }, u.prototype._destroy = function(y, T) {
        r.prototype._destroy.call(this, y, function(h) {
          T(h);
        });
      };
    }, { "../errors": 193, "./_stream_duplex": 194, inherits: 110 }], 198: [function(x, C, c) {
      (function(p, v) {
        (function() {
          function n(q) {
            var G = this;
            this.next = null, this.entry = null, this.finish = function() {
              Pt(G, q);
            };
          }
          var i;
          C.exports = K, K.WritableState = X;
          var s = { deprecate: x("util-deprecate") }, r = x("./internal/streams/stream"), o = x("buffer").Buffer, u = v.Uint8Array || function() {
          };
          function a(q) {
            return o.from(q);
          }
          function f(q) {
            return o.isBuffer(q) || q instanceof u;
          }
          var y, T = x("./internal/streams/destroy"), h = x("./internal/streams/state"), _ = h.getHighWaterMark, g = x("../errors").codes, S = g.ERR_INVALID_ARG_TYPE, d = g.ERR_METHOD_NOT_IMPLEMENTED, b = g.ERR_MULTIPLE_CALLBACK, k = g.ERR_STREAM_CANNOT_PIPE, O = g.ERR_STREAM_DESTROYED, A = g.ERR_STREAM_NULL_VALUES, l = g.ERR_STREAM_WRITE_AFTER_END, E = g.ERR_UNKNOWN_ENCODING, M = T.errorOrDestroy;
          function B() {
          }
          function X(q, G, lt) {
            i = i || x("./_stream_duplex"), q = q || {}, typeof lt != "boolean" && (lt = G instanceof i), this.objectMode = !!q.objectMode, lt && (this.objectMode = this.objectMode || !!q.writableObjectMode), this.highWaterMark = _(this, q, "writableHighWaterMark", lt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var It = q.decodeStrings === !1;
            this.decodeStrings = !It, this.defaultEncoding = q.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ft) {
              V(G, Ft);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = q.emitClose !== !1, this.autoDestroy = !!q.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n(this);
          }
          function K(q) {
            var G = this instanceof (i = i || x("./_stream_duplex"));
            if (!G && !y.call(K, this))
              return new K(q);
            this._writableState = new X(q, this, G), this.writable = !0, q && (typeof q.write == "function" && (this._write = q.write), typeof q.writev == "function" && (this._writev = q.writev), typeof q.destroy == "function" && (this._destroy = q.destroy), typeof q.final == "function" && (this._final = q.final)), r.call(this);
          }
          function D(q, G) {
            var lt = new l();
            M(q, lt), p.nextTick(G, lt);
          }
          function j(q, G, lt, It) {
            var Ft;
            return lt === null ? Ft = new A() : typeof lt == "string" || G.objectMode || (Ft = new S("chunk", ["string", "Buffer"], lt)), !Ft || (M(q, Ft), p.nextTick(It, Ft), !1);
          }
          function Z(q, G, lt) {
            return q.objectMode || q.decodeStrings === !1 || typeof G != "string" || (G = o.from(G, lt)), G;
          }
          function tt(q, G, lt, It, Ft, H) {
            if (!lt) {
              var F = Z(G, It, Ft);
              It !== F && (lt = !0, Ft = "buffer", It = F);
            }
            var P = G.objectMode ? 1 : It.length;
            G.length += P;
            var U = G.length < G.highWaterMark;
            if (U || (G.needDrain = !0), G.writing || G.corked) {
              var rt = G.lastBufferedRequest;
              G.lastBufferedRequest = { chunk: It, encoding: Ft, isBuf: lt, callback: H, next: null }, rt ? rt.next = G.lastBufferedRequest : G.bufferedRequest = G.lastBufferedRequest, G.bufferedRequestCount += 1;
            } else
              nt(q, G, !1, P, It, Ft, H);
            return U;
          }
          function nt(q, G, lt, It, Ft, H, F) {
            G.writelen = It, G.writecb = F, G.writing = !0, G.sync = !0, G.destroyed ? G.onwrite(new O("write")) : lt ? q._writev(Ft, G.onwrite) : q._write(Ft, H, G.onwrite), G.sync = !1;
          }
          function ct(q, G, lt, It, Ft) {
            --G.pendingcb, lt ? (p.nextTick(Ft, It), p.nextTick(Q, q, G), q._writableState.errorEmitted = !0, M(q, It)) : (Ft(It), q._writableState.errorEmitted = !0, M(q, It), Q(q, G));
          }
          function ut(q) {
            q.writing = !1, q.writecb = null, q.length -= q.writelen, q.writelen = 0;
          }
          function V(q, G) {
            var lt = q._writableState, It = lt.sync, Ft = lt.writecb;
            if (typeof Ft != "function")
              throw new b();
            if (ut(lt), G)
              ct(q, lt, It, G, Ft);
            else {
              var H = pt(lt) || q.destroyed;
              H || lt.corked || lt.bufferProcessing || !lt.bufferedRequest || Ut(q, lt), It ? p.nextTick(ot, q, lt, H, Ft) : ot(q, lt, H, Ft);
            }
          }
          function ot(q, G, lt, It) {
            lt || xt(q, G), G.pendingcb--, It(), Q(q, G);
          }
          function xt(q, G) {
            G.length === 0 && G.needDrain && (G.needDrain = !1, q.emit("drain"));
          }
          function Ut(q, G) {
            G.bufferProcessing = !0;
            var lt = G.bufferedRequest;
            if (q._writev && lt && lt.next) {
              var It = G.bufferedRequestCount, Ft = new Array(It), H = G.corkedRequestsFree;
              H.entry = lt;
              for (var F = 0, P = !0; lt; )
                Ft[F] = lt, lt.isBuf || (P = !1), lt = lt.next, F += 1;
              Ft.allBuffers = P, nt(q, G, !0, G.length, Ft, "", H.finish), G.pendingcb++, G.lastBufferedRequest = null, H.next ? (G.corkedRequestsFree = H.next, H.next = null) : G.corkedRequestsFree = new n(G), G.bufferedRequestCount = 0;
            } else {
              for (; lt; ) {
                var U = lt.chunk, rt = lt.encoding, ft = lt.callback;
                if (nt(q, G, !1, G.objectMode ? 1 : U.length, U, rt, ft), lt = lt.next, G.bufferedRequestCount--, G.writing)
                  break;
              }
              lt === null && (G.lastBufferedRequest = null);
            }
            G.bufferedRequest = lt, G.bufferProcessing = !1;
          }
          function pt(q) {
            return q.ending && q.length === 0 && q.bufferedRequest === null && !q.finished && !q.writing;
          }
          function at(q, G) {
            q._final(function(lt) {
              G.pendingcb--, lt && M(q, lt), G.prefinished = !0, q.emit("prefinish"), Q(q, G);
            });
          }
          function bt(q, G) {
            G.prefinished || G.finalCalled || (typeof q._final != "function" || G.destroyed ? (G.prefinished = !0, q.emit("prefinish")) : (G.pendingcb++, G.finalCalled = !0, p.nextTick(at, q, G)));
          }
          function Q(q, G) {
            var lt = pt(G);
            if (lt && (bt(q, G), G.pendingcb === 0 && (G.finished = !0, q.emit("finish"), G.autoDestroy))) {
              var It = q._readableState;
              (!It || It.autoDestroy && It.endEmitted) && q.destroy();
            }
            return lt;
          }
          function At(q, G, lt) {
            G.ending = !0, Q(q, G), lt && (G.finished ? p.nextTick(lt) : q.once("finish", lt)), G.ended = !0, q.writable = !1;
          }
          function Pt(q, G, lt) {
            var It = q.entry;
            for (q.entry = null; It; ) {
              var Ft = It.callback;
              G.pendingcb--, Ft(lt), It = It.next;
            }
            G.corkedRequestsFree.next = q;
          }
          x("inherits")(K, r), X.prototype.getBuffer = function() {
            for (var q = this.bufferedRequest, G = []; q; )
              G.push(q), q = q.next;
            return G;
          }, function() {
            try {
              Object.defineProperty(X.prototype, "buffer", { get: s.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
            } catch (q) {
            }
          }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (y = Function.prototype[Symbol.hasInstance], Object.defineProperty(K, Symbol.hasInstance, { value: function(q) {
            return !!y.call(this, q) || this === K && q && q._writableState instanceof X;
          } })) : y = function(q) {
            return q instanceof this;
          }, K.prototype.pipe = function() {
            M(this, new k());
          }, K.prototype.write = function(q, G, lt) {
            var It = this._writableState, Ft = !1, H = !It.objectMode && f(q);
            return H && !o.isBuffer(q) && (q = a(q)), typeof G == "function" && (lt = G, G = null), H ? G = "buffer" : G || (G = It.defaultEncoding), typeof lt != "function" && (lt = B), It.ending ? D(this, lt) : (H || j(this, It, q, lt)) && (It.pendingcb++, Ft = tt(this, It, H, q, G, lt)), Ft;
          }, K.prototype.cork = function() {
            this._writableState.corked++;
          }, K.prototype.uncork = function() {
            var q = this._writableState;
            q.corked && (q.corked--, q.writing || q.corked || q.bufferProcessing || !q.bufferedRequest || Ut(this, q));
          }, K.prototype.setDefaultEncoding = function(q) {
            if (typeof q == "string" && (q = q.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((q + "").toLowerCase()) > -1))
              throw new E(q);
            return this._writableState.defaultEncoding = q, this;
          }, Object.defineProperty(K.prototype, "writableBuffer", { enumerable: !1, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } }), Object.defineProperty(K.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
            return this._writableState.highWaterMark;
          } }), K.prototype._write = function(q, G, lt) {
            lt(new d("_write()"));
          }, K.prototype._writev = null, K.prototype.end = function(q, G, lt) {
            var It = this._writableState;
            return typeof q == "function" ? (lt = q, q = null, G = null) : typeof G == "function" && (lt = G, G = null), q != null && this.write(q, G), It.corked && (It.corked = 1, this.uncork()), It.ending || At(this, It, lt), this;
          }, Object.defineProperty(K.prototype, "writableLength", { enumerable: !1, get: function() {
            return this._writableState.length;
          } }), Object.defineProperty(K.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._writableState !== void 0 && this._writableState.destroyed;
          }, set: function(q) {
            this._writableState && (this._writableState.destroyed = q);
          } }), K.prototype.destroy = T.destroy, K.prototype._undestroy = T.undestroy, K.prototype._destroy = function(q, G) {
            G(q);
          };
        }).call(this);
      }).call(this, x("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "../errors": 193, "./_stream_duplex": 194, "./internal/streams/destroy": 201, "./internal/streams/state": 205, "./internal/streams/stream": 206, _process: 158, buffer: 46, inherits: 110, "util-deprecate": 232 }], 199: [function(x, C, c) {
      (function(p) {
        (function() {
          var v;
          function n(k, O, A) {
            return O in k ? Object.defineProperty(k, O, { value: A, enumerable: !0, configurable: !0, writable: !0 }) : k[O] = A, k;
          }
          var i = x("./end-of-stream"), s = Symbol("lastResolve"), r = Symbol("lastReject"), o = Symbol("error"), u = Symbol("ended"), a = Symbol("lastPromise"), f = Symbol("handlePromise"), y = Symbol("stream");
          function T(k, O) {
            return { value: k, done: O };
          }
          function h(k) {
            var O = k[s];
            if (O !== null) {
              var A = k[y].read();
              A !== null && (k[a] = null, k[s] = null, k[r] = null, O(T(A, !1)));
            }
          }
          function _(k) {
            p.nextTick(h, k);
          }
          function g(k, O) {
            return function(A, l) {
              k.then(function() {
                O[u] ? A(T(void 0, !0)) : O[f](A, l);
              }, l);
            };
          }
          var S = Object.getPrototypeOf(function() {
          }), d = Object.setPrototypeOf((n(v = { get stream() {
            return this[y];
          }, next: function() {
            var k = this, O = this[o];
            if (O !== null)
              return Promise.reject(O);
            if (this[u])
              return Promise.resolve(T(void 0, !0));
            if (this[y].destroyed)
              return new Promise(function(M, B) {
                p.nextTick(function() {
                  k[o] ? B(k[o]) : M(T(void 0, !0));
                });
              });
            var A, l = this[a];
            if (l)
              A = new Promise(g(l, this));
            else {
              var E = this[y].read();
              if (E !== null)
                return Promise.resolve(T(E, !1));
              A = new Promise(this[f]);
            }
            return this[a] = A, A;
          } }, Symbol.asyncIterator, function() {
            return this;
          }), n(v, "return", function() {
            var k = this;
            return new Promise(function(O, A) {
              k[y].destroy(null, function(l) {
                l ? A(l) : O(T(void 0, !0));
              });
            });
          }), v), S), b = function(k) {
            var O, A = Object.create(d, (n(O = {}, y, { value: k, writable: !0 }), n(O, s, { value: null, writable: !0 }), n(O, r, { value: null, writable: !0 }), n(O, o, { value: null, writable: !0 }), n(O, u, { value: k._readableState.endEmitted, writable: !0 }), n(O, f, { value: function(l, E) {
              var M = A[y].read();
              M ? (A[a] = null, A[s] = null, A[r] = null, l(T(M, !1))) : (A[s] = l, A[r] = E);
            }, writable: !0 }), O));
            return A[a] = null, i(k, function(l) {
              if (l && l.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var E = A[r];
                return E !== null && (A[a] = null, A[s] = null, A[r] = null, E(l)), void (A[o] = l);
              }
              var M = A[s];
              M !== null && (A[a] = null, A[s] = null, A[r] = null, M(T(void 0, !0))), A[u] = !0;
            }), k.on("readable", _.bind(null, A)), A;
          };
          C.exports = b;
        }).call(this);
      }).call(this, x("_process"));
    }, { "./end-of-stream": 202, _process: 158 }], 200: [function(x, C, c) {
      function p(h, _) {
        var g = Object.keys(h);
        if (Object.getOwnPropertySymbols) {
          var S = Object.getOwnPropertySymbols(h);
          _ && (S = S.filter(function(d) {
            return Object.getOwnPropertyDescriptor(h, d).enumerable;
          })), g.push.apply(g, S);
        }
        return g;
      }
      function v(h) {
        for (var _ = 1; _ < arguments.length; _++) {
          var g = arguments[_] != null ? arguments[_] : {};
          _ % 2 ? p(Object(g), !0).forEach(function(S) {
            n(h, S, g[S]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(h, Object.getOwnPropertyDescriptors(g)) : p(Object(g)).forEach(function(S) {
            Object.defineProperty(h, S, Object.getOwnPropertyDescriptor(g, S));
          });
        }
        return h;
      }
      function n(h, _, g) {
        return _ in h ? Object.defineProperty(h, _, { value: g, enumerable: !0, configurable: !0, writable: !0 }) : h[_] = g, h;
      }
      function i(h, _) {
        if (!(h instanceof _))
          throw new TypeError("Cannot call a class as a function");
      }
      function s(h, _) {
        for (var g = 0; g < _.length; g++) {
          var S = _[g];
          S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(h, S.key, S);
        }
      }
      function r(h, _, g) {
        return _ && s(h.prototype, _), g && s(h, g), h;
      }
      var o = x("buffer"), u = o.Buffer, a = x("util"), f = a.inspect, y = f && f.custom || "inspect";
      function T(h, _, g) {
        u.prototype.copy.call(h, _, g);
      }
      C.exports = function() {
        function h() {
          i(this, h), this.head = null, this.tail = null, this.length = 0;
        }
        return r(h, [{ key: "push", value: function(_) {
          var g = { data: _, next: null };
          this.length > 0 ? this.tail.next = g : this.head = g, this.tail = g, ++this.length;
        } }, { key: "unshift", value: function(_) {
          var g = { data: _, next: this.head };
          this.length === 0 && (this.tail = g), this.head = g, ++this.length;
        } }, { key: "shift", value: function() {
          if (this.length !== 0) {
            var _ = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, _;
          }
        } }, { key: "clear", value: function() {
          this.head = this.tail = null, this.length = 0;
        } }, { key: "join", value: function(_) {
          if (this.length === 0)
            return "";
          for (var g = this.head, S = "" + g.data; g = g.next; )
            S += _ + g.data;
          return S;
        } }, { key: "concat", value: function(_) {
          if (this.length === 0)
            return u.alloc(0);
          for (var g = u.allocUnsafe(_ >>> 0), S = this.head, d = 0; S; )
            T(S.data, g, d), d += S.data.length, S = S.next;
          return g;
        } }, { key: "consume", value: function(_, g) {
          var S;
          return _ < this.head.data.length ? (S = this.head.data.slice(0, _), this.head.data = this.head.data.slice(_)) : S = _ === this.head.data.length ? this.shift() : g ? this._getString(_) : this._getBuffer(_), S;
        } }, { key: "first", value: function() {
          return this.head.data;
        } }, { key: "_getString", value: function(_) {
          var g = this.head, S = 1, d = g.data;
          for (_ -= d.length; g = g.next; ) {
            var b = g.data, k = _ > b.length ? b.length : _;
            if (k === b.length ? d += b : d += b.slice(0, _), (_ -= k) === 0) {
              k === b.length ? (++S, g.next ? this.head = g.next : this.head = this.tail = null) : (this.head = g, g.data = b.slice(k));
              break;
            }
            ++S;
          }
          return this.length -= S, d;
        } }, { key: "_getBuffer", value: function(_) {
          var g = u.allocUnsafe(_), S = this.head, d = 1;
          for (S.data.copy(g), _ -= S.data.length; S = S.next; ) {
            var b = S.data, k = _ > b.length ? b.length : _;
            if (b.copy(g, g.length - _, 0, k), (_ -= k) === 0) {
              k === b.length ? (++d, S.next ? this.head = S.next : this.head = this.tail = null) : (this.head = S, S.data = b.slice(k));
              break;
            }
            ++d;
          }
          return this.length -= d, g;
        } }, { key: y, value: function(_, g) {
          return f(this, v({}, g, { depth: 0, customInspect: !1 }));
        } }]), h;
      }();
    }, { buffer: 46, util: 42 }], 201: [function(x, C, c) {
      (function(p) {
        (function() {
          function v(u, a) {
            var f = this, y = this._readableState && this._readableState.destroyed, T = this._writableState && this._writableState.destroyed;
            return y || T ? (a ? a(u) : u && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, p.nextTick(r, this, u)) : p.nextTick(r, this, u)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(u || null, function(h) {
              !a && h ? f._writableState ? f._writableState.errorEmitted ? p.nextTick(i, f) : (f._writableState.errorEmitted = !0, p.nextTick(n, f, h)) : p.nextTick(n, f, h) : a ? (p.nextTick(i, f), a(h)) : p.nextTick(i, f);
            }), this);
          }
          function n(u, a) {
            r(u, a), i(u);
          }
          function i(u) {
            u._writableState && !u._writableState.emitClose || u._readableState && !u._readableState.emitClose || u.emit("close");
          }
          function s() {
            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
          }
          function r(u, a) {
            u.emit("error", a);
          }
          function o(u, a) {
            var f = u._readableState, y = u._writableState;
            f && f.autoDestroy || y && y.autoDestroy ? u.destroy(a) : u.emit("error", a);
          }
          C.exports = { destroy: v, undestroy: s, errorOrDestroy: o };
        }).call(this);
      }).call(this, x("_process"));
    }, { _process: 158 }], 202: [function(x, C, c) {
      var p = x("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
      function v(r) {
        var o = !1;
        return function() {
          if (!o) {
            o = !0;
            for (var u = arguments.length, a = new Array(u), f = 0; f < u; f++)
              a[f] = arguments[f];
            r.apply(this, a);
          }
        };
      }
      function n() {
      }
      function i(r) {
        return r.setHeader && typeof r.abort == "function";
      }
      function s(r, o, u) {
        if (typeof o == "function")
          return s(r, null, o);
        o || (o = {}), u = v(u || n);
        var a = o.readable || o.readable !== !1 && r.readable, f = o.writable || o.writable !== !1 && r.writable, y = function() {
          r.writable || h();
        }, T = r._writableState && r._writableState.finished, h = function() {
          f = !1, T = !0, a || u.call(r);
        }, _ = r._readableState && r._readableState.endEmitted, g = function() {
          a = !1, _ = !0, f || u.call(r);
        }, S = function(k) {
          u.call(r, k);
        }, d = function() {
          var k;
          return a && !_ ? (r._readableState && r._readableState.ended || (k = new p()), u.call(r, k)) : f && !T ? (r._writableState && r._writableState.ended || (k = new p()), u.call(r, k)) : void 0;
        }, b = function() {
          r.req.on("finish", h);
        };
        return i(r) ? (r.on("complete", h), r.on("abort", d), r.req ? b() : r.on("request", b)) : f && !r._writableState && (r.on("end", y), r.on("close", y)), r.on("end", g), r.on("finish", h), o.error !== !1 && r.on("error", S), r.on("close", d), function() {
          r.removeListener("complete", h), r.removeListener("abort", d), r.removeListener("request", b), r.req && r.req.removeListener("finish", h), r.removeListener("end", y), r.removeListener("close", y), r.removeListener("finish", h), r.removeListener("end", g), r.removeListener("error", S), r.removeListener("close", d);
        };
      }
      C.exports = s;
    }, { "../../../errors": 193 }], 203: [function(x, C, c) {
      C.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, {}], 204: [function(x, C, c) {
      var p;
      function v(h) {
        var _ = !1;
        return function() {
          _ || (_ = !0, h.apply(void 0, arguments));
        };
      }
      var n = x("../../../errors").codes, i = n.ERR_MISSING_ARGS, s = n.ERR_STREAM_DESTROYED;
      function r(h) {
        if (h)
          throw h;
      }
      function o(h) {
        return h.setHeader && typeof h.abort == "function";
      }
      function u(h, _, g, S) {
        S = v(S);
        var d = !1;
        h.on("close", function() {
          d = !0;
        }), p === void 0 && (p = x("./end-of-stream")), p(h, { readable: _, writable: g }, function(k) {
          if (k)
            return S(k);
          d = !0, S();
        });
        var b = !1;
        return function(k) {
          if (!d && !b)
            return b = !0, o(h) ? h.abort() : typeof h.destroy == "function" ? h.destroy() : void S(k || new s("pipe"));
        };
      }
      function a(h) {
        h();
      }
      function f(h, _) {
        return h.pipe(_);
      }
      function y(h) {
        return h.length ? typeof h[h.length - 1] != "function" ? r : h.pop() : r;
      }
      function T() {
        for (var h = arguments.length, _ = new Array(h), g = 0; g < h; g++)
          _[g] = arguments[g];
        var S, d = y(_);
        if (Array.isArray(_[0]) && (_ = _[0]), _.length < 2)
          throw new i("streams");
        var b = _.map(function(k, O) {
          var A = O < _.length - 1;
          return u(k, A, O > 0, function(l) {
            S || (S = l), l && b.forEach(a), A || (b.forEach(a), d(S));
          });
        });
        return _.reduce(f);
      }
      C.exports = T;
    }, { "../../../errors": 193, "./end-of-stream": 202 }], 205: [function(x, C, c) {
      var p = x("../../../errors").codes.ERR_INVALID_OPT_VALUE;
      function v(i, s, r) {
        return i.highWaterMark != null ? i.highWaterMark : s ? i[r] : null;
      }
      function n(i, s, r, o) {
        var u = v(s, o, r);
        if (u != null) {
          if (!isFinite(u) || Math.floor(u) !== u || u < 0)
            throw new p(o ? r : "highWaterMark", u);
          return Math.floor(u);
        }
        return i.objectMode ? 16 : 16384;
      }
      C.exports = { getHighWaterMark: n };
    }, { "../../../errors": 193 }], 206: [function(x, C, c) {
      C.exports = x("events").EventEmitter;
    }, { events: 95 }], 207: [function(x, C, c) {
      var p = x("safe-buffer").Buffer, v = p.isEncoding || function(b) {
        switch ((b = "" + b) && b.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1;
        }
      };
      function n(b) {
        if (!b)
          return "utf8";
        for (var k; ; )
          switch (b) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return b;
            default:
              if (k)
                return;
              b = ("" + b).toLowerCase(), k = !0;
          }
      }
      function i(b) {
        var k = n(b);
        if (typeof k != "string" && (p.isEncoding === v || !v(b)))
          throw new Error("Unknown encoding: " + b);
        return k || b;
      }
      function s(b) {
        var k;
        switch (this.encoding = i(b), this.encoding) {
          case "utf16le":
            this.text = T, this.end = h, k = 4;
            break;
          case "utf8":
            this.fillLast = a, k = 4;
            break;
          case "base64":
            this.text = _, this.end = g, k = 3;
            break;
          default:
            return this.write = S, void (this.end = d);
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = p.allocUnsafe(k);
      }
      function r(b) {
        return b <= 127 ? 0 : b >> 5 == 6 ? 2 : b >> 4 == 14 ? 3 : b >> 3 == 30 ? 4 : b >> 6 == 2 ? -1 : -2;
      }
      function o(b, k, O) {
        var A = k.length - 1;
        if (A < O)
          return 0;
        var l = r(k[A]);
        return l >= 0 ? (l > 0 && (b.lastNeed = l - 1), l) : --A < O || l === -2 ? 0 : (l = r(k[A])) >= 0 ? (l > 0 && (b.lastNeed = l - 2), l) : --A < O || l === -2 ? 0 : (l = r(k[A])) >= 0 ? (l > 0 && (l === 2 ? l = 0 : b.lastNeed = l - 3), l) : 0;
      }
      function u(b, k, O) {
        if ((192 & k[0]) != 128)
          return b.lastNeed = 0, "�";
        if (b.lastNeed > 1 && k.length > 1) {
          if ((192 & k[1]) != 128)
            return b.lastNeed = 1, "�";
          if (b.lastNeed > 2 && k.length > 2 && (192 & k[2]) != 128)
            return b.lastNeed = 2, "�";
        }
      }
      function a(b) {
        var k = this.lastTotal - this.lastNeed, O = u(this, b);
        return O !== void 0 ? O : this.lastNeed <= b.length ? (b.copy(this.lastChar, k, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (b.copy(this.lastChar, k, 0, b.length), void (this.lastNeed -= b.length));
      }
      function f(b, k) {
        var O = o(this, b, k);
        if (!this.lastNeed)
          return b.toString("utf8", k);
        this.lastTotal = O;
        var A = b.length - (O - this.lastNeed);
        return b.copy(this.lastChar, 0, A), b.toString("utf8", k, A);
      }
      function y(b) {
        var k = b && b.length ? this.write(b) : "";
        return this.lastNeed ? k + "�" : k;
      }
      function T(b, k) {
        if ((b.length - k) % 2 == 0) {
          var O = b.toString("utf16le", k);
          if (O) {
            var A = O.charCodeAt(O.length - 1);
            if (A >= 55296 && A <= 56319)
              return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1], O.slice(0, -1);
          }
          return O;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = b[b.length - 1], b.toString("utf16le", k, b.length - 1);
      }
      function h(b) {
        var k = b && b.length ? this.write(b) : "";
        if (this.lastNeed) {
          var O = this.lastTotal - this.lastNeed;
          return k + this.lastChar.toString("utf16le", 0, O);
        }
        return k;
      }
      function _(b, k) {
        var O = (b.length - k) % 3;
        return O === 0 ? b.toString("base64", k) : (this.lastNeed = 3 - O, this.lastTotal = 3, O === 1 ? this.lastChar[0] = b[b.length - 1] : (this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1]), b.toString("base64", k, b.length - O));
      }
      function g(b) {
        var k = b && b.length ? this.write(b) : "";
        return this.lastNeed ? k + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : k;
      }
      function S(b) {
        return b.toString(this.encoding);
      }
      function d(b) {
        return b && b.length ? this.write(b) : "";
      }
      c.StringDecoder = s, s.prototype.write = function(b) {
        if (b.length === 0)
          return "";
        var k, O;
        if (this.lastNeed) {
          if ((k = this.fillLast(b)) === void 0)
            return "";
          O = this.lastNeed, this.lastNeed = 0;
        } else
          O = 0;
        return O < b.length ? k ? k + this.text(b, O) : this.text(b, O) : k || "";
      }, s.prototype.end = y, s.prototype.text = f, s.prototype.fillLast = function(b) {
        if (this.lastNeed <= b.length)
          return b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, b.length), this.lastNeed -= b.length;
      };
    }, { "safe-buffer": 164 }], 208: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = x("./lib/request"), n = x("./lib/response"), i = x("xtend"), s = x("builtin-status-codes"), r = x("url"), o = c;
          o.request = function(u, a) {
            u = typeof u == "string" ? r.parse(u) : i(u);
            var f = p.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", y = u.protocol || f, T = u.hostname || u.host, h = u.port, _ = u.path || "/";
            T && T.indexOf(":") !== -1 && (T = "[" + T + "]"), u.url = (T ? y + "//" + T : "") + (h ? ":" + h : "") + _, u.method = (u.method || "GET").toUpperCase(), u.headers = u.headers || {};
            var g = new v(u);
            return a && g.on("response", a), g;
          }, o.get = function(u, a) {
            var f = o.request(u, a);
            return f.end(), f;
          }, o.ClientRequest = v, o.IncomingMessage = n.IncomingMessage, o.Agent = function() {
          }, o.Agent.defaultMaxSockets = 4, o.globalAgent = new o.Agent(), o.STATUS_CODES = s, o.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "./lib/request": 210, "./lib/response": 211, "builtin-status-codes": 47, url: 229, xtend: 240 }], 209: [function(x, C, c) {
      (function(p) {
        (function() {
          var v;
          function n() {
            if (v !== void 0)
              return v;
            if (p.XMLHttpRequest) {
              v = new p.XMLHttpRequest();
              try {
                v.open("GET", p.XDomainRequest ? "/" : "https://example.com");
              } catch (r) {
                v = null;
              }
            } else
              v = null;
            return v;
          }
          function i(r) {
            var o = n();
            if (!o)
              return !1;
            try {
              return o.responseType = r, o.responseType === r;
            } catch (u) {
            }
            return !1;
          }
          function s(r) {
            return typeof r == "function";
          }
          c.fetch = s(p.fetch) && s(p.ReadableStream), c.writableStream = s(p.WritableStream), c.abortController = s(p.AbortController), c.arraybuffer = c.fetch || i("arraybuffer"), c.msstream = !c.fetch && i("ms-stream"), c.mozchunkedarraybuffer = !c.fetch && i("moz-chunked-arraybuffer"), c.overrideMimeType = c.fetch || !!n() && s(n().overrideMimeType), v = null;
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 210: [function(x, C, c) {
      (function(p, v, n) {
        (function() {
          var i = x("./capability"), s = x("inherits"), r = x("./response"), o = x("readable-stream"), u = r.IncomingMessage, a = r.readyStates;
          function f(_, g) {
            return i.fetch && g ? "fetch" : i.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : i.msstream ? "ms-stream" : i.arraybuffer && _ ? "arraybuffer" : "text";
          }
          var y = C.exports = function(_) {
            var g, S = this;
            o.Writable.call(S), S._opts = _, S._body = [], S._headers = {}, _.auth && S.setHeader("Authorization", "Basic " + n.from(_.auth).toString("base64")), Object.keys(_.headers).forEach(function(b) {
              S.setHeader(b, _.headers[b]);
            });
            var d = !0;
            if (_.mode === "disable-fetch" || "requestTimeout" in _ && !i.abortController)
              d = !1, g = !0;
            else if (_.mode === "prefer-streaming")
              g = !1;
            else if (_.mode === "allow-wrong-content-type")
              g = !i.overrideMimeType;
            else {
              if (_.mode && _.mode !== "default" && _.mode !== "prefer-fast")
                throw new Error("Invalid value for opts.mode");
              g = !0;
            }
            S._mode = f(g, d), S._fetchTimer = null, S._socketTimeout = null, S._socketTimer = null, S.on("finish", function() {
              S._onFinish();
            });
          };
          function T(_) {
            try {
              var g = _.status;
              return g !== null && g !== 0;
            } catch (S) {
              return !1;
            }
          }
          s(y, o.Writable), y.prototype.setHeader = function(_, g) {
            var S = _.toLowerCase();
            h.indexOf(S) === -1 && (this._headers[S] = { name: _, value: g });
          }, y.prototype.getHeader = function(_) {
            var g = this._headers[_.toLowerCase()];
            return g ? g.value : null;
          }, y.prototype.removeHeader = function(_) {
            delete this._headers[_.toLowerCase()];
          }, y.prototype._onFinish = function() {
            var _ = this;
            if (!_._destroyed) {
              var g = _._opts;
              "timeout" in g && g.timeout !== 0 && _.setTimeout(g.timeout);
              var S = _._headers, d = null;
              g.method !== "GET" && g.method !== "HEAD" && (d = new Blob(_._body, { type: (S["content-type"] || {}).value || "" }));
              var b = [];
              if (Object.keys(S).forEach(function(l) {
                var E = S[l].name, M = S[l].value;
                Array.isArray(M) ? M.forEach(function(B) {
                  b.push([E, B]);
                }) : b.push([E, M]);
              }), _._mode === "fetch") {
                var k = null;
                if (i.abortController) {
                  var O = new AbortController();
                  k = O.signal, _._fetchAbortController = O, "requestTimeout" in g && g.requestTimeout !== 0 && (_._fetchTimer = v.setTimeout(function() {
                    _.emit("requestTimeout"), _._fetchAbortController && _._fetchAbortController.abort();
                  }, g.requestTimeout));
                }
                v.fetch(_._opts.url, { method: _._opts.method, headers: b, body: d || void 0, mode: "cors", credentials: g.withCredentials ? "include" : "same-origin", signal: k }).then(function(l) {
                  _._fetchResponse = l, _._resetTimers(!1), _._connect();
                }, function(l) {
                  _._resetTimers(!0), _._destroyed || _.emit("error", l);
                });
              } else {
                var A = _._xhr = new v.XMLHttpRequest();
                try {
                  A.open(_._opts.method, _._opts.url, !0);
                } catch (l) {
                  return void p.nextTick(function() {
                    _.emit("error", l);
                  });
                }
                "responseType" in A && (A.responseType = _._mode), "withCredentials" in A && (A.withCredentials = !!g.withCredentials), _._mode === "text" && "overrideMimeType" in A && A.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in g && (A.timeout = g.requestTimeout, A.ontimeout = function() {
                  _.emit("requestTimeout");
                }), b.forEach(function(l) {
                  A.setRequestHeader(l[0], l[1]);
                }), _._response = null, A.onreadystatechange = function() {
                  switch (A.readyState) {
                    case a.LOADING:
                    case a.DONE:
                      _._onXHRProgress();
                  }
                }, _._mode === "moz-chunked-arraybuffer" && (A.onprogress = function() {
                  _._onXHRProgress();
                }), A.onerror = function() {
                  _._destroyed || (_._resetTimers(!0), _.emit("error", new Error("XHR error")));
                };
                try {
                  A.send(d);
                } catch (l) {
                  return void p.nextTick(function() {
                    _.emit("error", l);
                  });
                }
              }
            }
          }, y.prototype._onXHRProgress = function() {
            this._resetTimers(!1), T(this._xhr) && !this._destroyed && (this._response || this._connect(), this._response._onXHRProgress(this._resetTimers.bind(this)));
          }, y.prototype._connect = function() {
            var _ = this;
            _._destroyed || (_._response = new u(_._xhr, _._fetchResponse, _._mode, _._resetTimers.bind(_)), _._response.on("error", function(g) {
              _.emit("error", g);
            }), _.emit("response", _._response));
          }, y.prototype._write = function(_, g, S) {
            this._body.push(_), S();
          }, y.prototype._resetTimers = function(_) {
            var g = this;
            v.clearTimeout(g._socketTimer), g._socketTimer = null, _ ? (v.clearTimeout(g._fetchTimer), g._fetchTimer = null) : g._socketTimeout && (g._socketTimer = v.setTimeout(function() {
              g.emit("timeout");
            }, g._socketTimeout));
          }, y.prototype.abort = y.prototype.destroy = function(_) {
            this._destroyed = !0, this._resetTimers(!0), this._response && (this._response._destroyed = !0), this._xhr ? this._xhr.abort() : this._fetchAbortController && this._fetchAbortController.abort(), _ && this.emit("error", _);
          }, y.prototype.end = function(_, g, S) {
            typeof _ == "function" && (S = _, _ = void 0), o.Writable.prototype.end.call(this, _, g, S);
          }, y.prototype.setTimeout = function(_, g) {
            g && this.once("timeout", g), this._socketTimeout = _, this._resetTimers(!1);
          }, y.prototype.flushHeaders = function() {
          }, y.prototype.setNoDelay = function() {
          }, y.prototype.setSocketKeepAlive = function() {
          };
          var h = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
        }).call(this);
      }).call(this, x("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, x("buffer").Buffer);
    }, { "./capability": 209, "./response": 211, _process: 158, buffer: 46, inherits: 110, "readable-stream": 226 }], 211: [function(x, C, c) {
      (function(p, v, n) {
        (function() {
          var i = x("./capability"), s = x("inherits"), r = x("readable-stream"), o = c.readyStates = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 }, u = c.IncomingMessage = function(a, f, y, T) {
            var h = this;
            if (r.Readable.call(h), h._mode = y, h.headers = {}, h.rawHeaders = [], h.trailers = {}, h.rawTrailers = [], h.on("end", function() {
              p.nextTick(function() {
                h.emit("close");
              });
            }), y === "fetch") {
              if (h._fetchResponse = f, h.url = f.url, h.statusCode = f.status, h.statusMessage = f.statusText, f.headers.forEach(function(b, k) {
                h.headers[k.toLowerCase()] = b, h.rawHeaders.push(k, b);
              }), i.writableStream) {
                var _ = new WritableStream({ write: function(b) {
                  return T(!1), new Promise(function(k, O) {
                    h._destroyed ? O() : h.push(n.from(b)) ? k() : h._resumeFetch = k;
                  });
                }, close: function() {
                  T(!0), h._destroyed || h.push(null);
                }, abort: function(b) {
                  T(!0), h._destroyed || h.emit("error", b);
                } });
                try {
                  return void f.body.pipeTo(_).catch(function(b) {
                    T(!0), h._destroyed || h.emit("error", b);
                  });
                } catch (b) {
                }
              }
              var g = f.body.getReader();
              (function b() {
                g.read().then(function(k) {
                  h._destroyed || (T(k.done), k.done ? h.push(null) : (h.push(n.from(k.value)), b()));
                }).catch(function(k) {
                  T(!0), h._destroyed || h.emit("error", k);
                });
              })();
            } else if (h._xhr = a, h._pos = 0, h.url = a.responseURL, h.statusCode = a.status, h.statusMessage = a.statusText, a.getAllResponseHeaders().split(/\r?\n/).forEach(function(b) {
              var k = b.match(/^([^:]+):\s*(.*)/);
              if (k) {
                var O = k[1].toLowerCase();
                O === "set-cookie" ? (h.headers[O] === void 0 && (h.headers[O] = []), h.headers[O].push(k[2])) : h.headers[O] !== void 0 ? h.headers[O] += ", " + k[2] : h.headers[O] = k[2], h.rawHeaders.push(k[1], k[2]);
              }
            }), h._charset = "x-user-defined", !i.overrideMimeType) {
              var S = h.rawHeaders["mime-type"];
              if (S) {
                var d = S.match(/;\s*charset=([^;])(;|$)/);
                d && (h._charset = d[1].toLowerCase());
              }
              h._charset || (h._charset = "utf-8");
            }
          };
          s(u, r.Readable), u.prototype._read = function() {
            var a = this._resumeFetch;
            a && (this._resumeFetch = null, a());
          }, u.prototype._onXHRProgress = function(a) {
            var f = this, y = f._xhr, T = null;
            switch (f._mode) {
              case "text":
                if ((T = y.responseText).length > f._pos) {
                  var h = T.substr(f._pos);
                  if (f._charset === "x-user-defined") {
                    for (var _ = n.alloc(h.length), g = 0; g < h.length; g++)
                      _[g] = 255 & h.charCodeAt(g);
                    f.push(_);
                  } else
                    f.push(h, f._charset);
                  f._pos = T.length;
                }
                break;
              case "arraybuffer":
                if (y.readyState !== o.DONE || !y.response)
                  break;
                T = y.response, f.push(n.from(new Uint8Array(T)));
                break;
              case "moz-chunked-arraybuffer":
                if (T = y.response, y.readyState !== o.LOADING || !T)
                  break;
                f.push(n.from(new Uint8Array(T)));
                break;
              case "ms-stream":
                if (T = y.response, y.readyState !== o.LOADING)
                  break;
                var S = new v.MSStreamReader();
                S.onprogress = function() {
                  S.result.byteLength > f._pos && (f.push(n.from(new Uint8Array(S.result.slice(f._pos)))), f._pos = S.result.byteLength);
                }, S.onload = function() {
                  a(!0), f.push(null);
                }, S.readAsArrayBuffer(T);
            }
            f._xhr.readyState === o.DONE && f._mode !== "ms-stream" && (a(!0), f.push(null));
          };
        }).call(this);
      }).call(this, x("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {}, x("buffer").Buffer);
    }, { "./capability": 209, _process: 158, buffer: 46, inherits: 110, "readable-stream": 226 }], 212: [function(x, C, c) {
      function p(u, a) {
        u.prototype = Object.create(a.prototype), u.prototype.constructor = u, u.__proto__ = a;
      }
      var v = {};
      function n(u, a, f) {
        f || (f = Error);
        var y = function(T) {
          function h(_, g, S) {
            return T.call(this, function(d, b, k) {
              return typeof a == "string" ? a : a(d, b, k);
            }(_, g, S)) || this;
          }
          return p(h, T), h;
        }(f);
        y.prototype.name = f.name, y.prototype.code = u, v[u] = y;
      }
      function i(u, a) {
        if (Array.isArray(u)) {
          var f = u.length;
          return u = u.map(function(y) {
            return String(y);
          }), f > 2 ? "one of ".concat(a, " ").concat(u.slice(0, f - 1).join(", "), ", or ") + u[f - 1] : f === 2 ? "one of ".concat(a, " ").concat(u[0], " or ").concat(u[1]) : "of ".concat(a, " ").concat(u[0]);
        }
        return "of ".concat(a, " ").concat(String(u));
      }
      function s(u, a, f) {
        return u.substr(!f || f < 0 ? 0 : +f, a.length) === a;
      }
      function r(u, a, f) {
        return (f === void 0 || f > u.length) && (f = u.length), u.substring(f - a.length, f) === a;
      }
      function o(u, a, f) {
        return typeof f != "number" && (f = 0), !(f + a.length > u.length) && u.indexOf(a, f) !== -1;
      }
      n("ERR_INVALID_OPT_VALUE", function(u, a) {
        return 'The value "' + a + '" is invalid for option "' + u + '"';
      }, TypeError), n("ERR_INVALID_ARG_TYPE", function(u, a, f) {
        var y, T;
        if (typeof a == "string" && s(a, "not ") ? (y = "must not be", a = a.replace(/^not /, "")) : y = "must be", r(u, " argument"))
          T = "The ".concat(u, " ").concat(y, " ").concat(i(a, "type"));
        else {
          var h = o(u, ".") ? "property" : "argument";
          T = 'The "'.concat(u, '" ').concat(h, " ").concat(y, " ").concat(i(a, "type"));
        }
        return T += ". Received type ".concat(typeof f);
      }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function(u) {
        return "The " + u + " method is not implemented";
      }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function(u) {
        return "Cannot call " + u + " after a stream was destroyed";
      }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function(u) {
        return "Unknown encoding: " + u;
      }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), C.exports.codes = v;
    }, {}], 213: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = Object.keys || function(y) {
            var T = [];
            for (var h in y)
              T.push(h);
            return T;
          };
          C.exports = u;
          var n = x("./_stream_readable"), i = x("./_stream_writable");
          x("inherits")(u, n);
          for (var s = v(i.prototype), r = 0; r < s.length; r++) {
            var o = s[r];
            u.prototype[o] || (u.prototype[o] = i.prototype[o]);
          }
          function u(y) {
            if (!(this instanceof u))
              return new u(y);
            n.call(this, y), i.call(this, y), this.allowHalfOpen = !0, y && (y.readable === !1 && (this.readable = !1), y.writable === !1 && (this.writable = !1), y.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", a)));
          }
          function a() {
            this._writableState.ended || p.nextTick(f, this);
          }
          function f(y) {
            y.end();
          }
          Object.defineProperty(u.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
            return this._writableState.highWaterMark;
          } }), Object.defineProperty(u.prototype, "writableBuffer", { enumerable: !1, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } }), Object.defineProperty(u.prototype, "writableLength", { enumerable: !1, get: function() {
            return this._writableState.length;
          } }), Object.defineProperty(u.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
          }, set: function(y) {
            this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = y, this._writableState.destroyed = y);
          } });
        }).call(this);
      }).call(this, x("_process"));
    }, { "./_stream_readable": 215, "./_stream_writable": 217, _process: 158, inherits: 110 }], 214: [function(x, C, c) {
      C.exports = v;
      var p = x("./_stream_transform");
      function v(n) {
        if (!(this instanceof v))
          return new v(n);
        p.call(this, n);
      }
      x("inherits")(v, p), v.prototype._transform = function(n, i, s) {
        s(null, n);
      };
    }, { "./_stream_transform": 216, inherits: 110 }], 215: [function(x, C, c) {
      (function(p, v) {
        (function() {
          var n;
          C.exports = D, D.ReadableState = K, x("events").EventEmitter;
          var i = function(H, F) {
            return H.listeners(F).length;
          }, s = x("./internal/streams/stream"), r = x("buffer").Buffer, o = v.Uint8Array || function() {
          };
          function u(H) {
            return r.from(H);
          }
          function a(H) {
            return r.isBuffer(H) || H instanceof o;
          }
          var f, y = x("util");
          f = y && y.debuglog ? y.debuglog("stream") : function() {
          };
          var T, h, _, g = x("./internal/streams/buffer_list"), S = x("./internal/streams/destroy"), d = x("./internal/streams/state"), b = d.getHighWaterMark, k = x("../errors").codes, O = k.ERR_INVALID_ARG_TYPE, A = k.ERR_STREAM_PUSH_AFTER_EOF, l = k.ERR_METHOD_NOT_IMPLEMENTED, E = k.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
          x("inherits")(D, s);
          var M = S.errorOrDestroy, B = ["error", "close", "destroy", "pause", "resume"];
          function X(H, F, P) {
            if (typeof H.prependListener == "function")
              return H.prependListener(F, P);
            H._events && H._events[F] ? Array.isArray(H._events[F]) ? H._events[F].unshift(P) : H._events[F] = [P, H._events[F]] : H.on(F, P);
          }
          function K(H, F, P) {
            n = n || x("./_stream_duplex"), H = H || {}, typeof P != "boolean" && (P = F instanceof n), this.objectMode = !!H.objectMode, P && (this.objectMode = this.objectMode || !!H.readableObjectMode), this.highWaterMark = b(this, H, "readableHighWaterMark", P), this.buffer = new g(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = H.emitClose !== !1, this.autoDestroy = !!H.autoDestroy, this.destroyed = !1, this.defaultEncoding = H.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, H.encoding && (T || (T = x("string_decoder/").StringDecoder), this.decoder = new T(H.encoding), this.encoding = H.encoding);
          }
          function D(H) {
            if (n = n || x("./_stream_duplex"), !(this instanceof D))
              return new D(H);
            var F = this instanceof n;
            this._readableState = new K(H, this, F), this.readable = !0, H && (typeof H.read == "function" && (this._read = H.read), typeof H.destroy == "function" && (this._destroy = H.destroy)), s.call(this);
          }
          function j(H, F, P, U, rt) {
            f("readableAddChunk", F);
            var ft, Ot = H._readableState;
            if (F === null)
              Ot.reading = !1, V(H, Ot);
            else if (rt || (ft = tt(Ot, F)), ft)
              M(H, ft);
            else if (Ot.objectMode || F && F.length > 0)
              if (typeof F == "string" || Ot.objectMode || Object.getPrototypeOf(F) === r.prototype || (F = u(F)), U)
                Ot.endEmitted ? M(H, new E()) : Z(H, Ot, F, !0);
              else if (Ot.ended)
                M(H, new A());
              else {
                if (Ot.destroyed)
                  return !1;
                Ot.reading = !1, Ot.decoder && !P ? (F = Ot.decoder.write(F), Ot.objectMode || F.length !== 0 ? Z(H, Ot, F, !1) : Ut(H, Ot)) : Z(H, Ot, F, !1);
              }
            else
              U || (Ot.reading = !1, Ut(H, Ot));
            return !Ot.ended && (Ot.length < Ot.highWaterMark || Ot.length === 0);
          }
          function Z(H, F, P, U) {
            F.flowing && F.length === 0 && !F.sync ? (F.awaitDrain = 0, H.emit("data", P)) : (F.length += F.objectMode ? 1 : P.length, U ? F.buffer.unshift(P) : F.buffer.push(P), F.needReadable && ot(H)), Ut(H, F);
          }
          function tt(H, F) {
            var P;
            return a(F) || typeof F == "string" || F === void 0 || H.objectMode || (P = new O("chunk", ["string", "Buffer", "Uint8Array"], F)), P;
          }
          Object.defineProperty(D.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._readableState !== void 0 && this._readableState.destroyed;
          }, set: function(H) {
            this._readableState && (this._readableState.destroyed = H);
          } }), D.prototype.destroy = S.destroy, D.prototype._undestroy = S.undestroy, D.prototype._destroy = function(H, F) {
            F(H);
          }, D.prototype.push = function(H, F) {
            var P, U = this._readableState;
            return U.objectMode ? P = !0 : typeof H == "string" && ((F = F || U.defaultEncoding) !== U.encoding && (H = r.from(H, F), F = ""), P = !0), j(this, H, F, !1, P);
          }, D.prototype.unshift = function(H) {
            return j(this, H, null, !0, !1);
          }, D.prototype.isPaused = function() {
            return this._readableState.flowing === !1;
          }, D.prototype.setEncoding = function(H) {
            T || (T = x("string_decoder/").StringDecoder);
            var F = new T(H);
            this._readableState.decoder = F, this._readableState.encoding = this._readableState.decoder.encoding;
            for (var P = this._readableState.buffer.head, U = ""; P !== null; )
              U += F.write(P.data), P = P.next;
            return this._readableState.buffer.clear(), U !== "" && this._readableState.buffer.push(U), this._readableState.length = U.length, this;
          };
          var nt = 1073741824;
          function ct(H) {
            return H >= nt ? H = nt : (H--, H |= H >>> 1, H |= H >>> 2, H |= H >>> 4, H |= H >>> 8, H |= H >>> 16, H++), H;
          }
          function ut(H, F) {
            return H <= 0 || F.length === 0 && F.ended ? 0 : F.objectMode ? 1 : H != H ? F.flowing && F.length ? F.buffer.head.data.length : F.length : (H > F.highWaterMark && (F.highWaterMark = ct(H)), H <= F.length ? H : F.ended ? F.length : (F.needReadable = !0, 0));
          }
          function V(H, F) {
            if (f("onEofChunk"), !F.ended) {
              if (F.decoder) {
                var P = F.decoder.end();
                P && P.length && (F.buffer.push(P), F.length += F.objectMode ? 1 : P.length);
              }
              F.ended = !0, F.sync ? ot(H) : (F.needReadable = !1, F.emittedReadable || (F.emittedReadable = !0, xt(H)));
            }
          }
          function ot(H) {
            var F = H._readableState;
            f("emitReadable", F.needReadable, F.emittedReadable), F.needReadable = !1, F.emittedReadable || (f("emitReadable", F.flowing), F.emittedReadable = !0, p.nextTick(xt, H));
          }
          function xt(H) {
            var F = H._readableState;
            f("emitReadable_", F.destroyed, F.length, F.ended), F.destroyed || !F.length && !F.ended || (H.emit("readable"), F.emittedReadable = !1), F.needReadable = !F.flowing && !F.ended && F.length <= F.highWaterMark, q(H);
          }
          function Ut(H, F) {
            F.readingMore || (F.readingMore = !0, p.nextTick(pt, H, F));
          }
          function pt(H, F) {
            for (; !F.reading && !F.ended && (F.length < F.highWaterMark || F.flowing && F.length === 0); ) {
              var P = F.length;
              if (f("maybeReadMore read 0"), H.read(0), P === F.length)
                break;
            }
            F.readingMore = !1;
          }
          function at(H) {
            return function() {
              var F = H._readableState;
              f("pipeOnDrain", F.awaitDrain), F.awaitDrain && F.awaitDrain--, F.awaitDrain === 0 && i(H, "data") && (F.flowing = !0, q(H));
            };
          }
          function bt(H) {
            var F = H._readableState;
            F.readableListening = H.listenerCount("readable") > 0, F.resumeScheduled && !F.paused ? F.flowing = !0 : H.listenerCount("data") > 0 && H.resume();
          }
          function Q(H) {
            f("readable nexttick read 0"), H.read(0);
          }
          function At(H, F) {
            F.resumeScheduled || (F.resumeScheduled = !0, p.nextTick(Pt, H, F));
          }
          function Pt(H, F) {
            f("resume", F.reading), F.reading || H.read(0), F.resumeScheduled = !1, H.emit("resume"), q(H), F.flowing && !F.reading && H.read(0);
          }
          function q(H) {
            var F = H._readableState;
            for (f("flow", F.flowing); F.flowing && H.read() !== null; )
              ;
          }
          function G(H, F) {
            return F.length === 0 ? null : (F.objectMode ? P = F.buffer.shift() : !H || H >= F.length ? (P = F.decoder ? F.buffer.join("") : F.buffer.length === 1 ? F.buffer.first() : F.buffer.concat(F.length), F.buffer.clear()) : P = F.buffer.consume(H, F.decoder), P);
            var P;
          }
          function lt(H) {
            var F = H._readableState;
            f("endReadable", F.endEmitted), F.endEmitted || (F.ended = !0, p.nextTick(It, F, H));
          }
          function It(H, F) {
            if (f("endReadableNT", H.endEmitted, H.length), !H.endEmitted && H.length === 0 && (H.endEmitted = !0, F.readable = !1, F.emit("end"), H.autoDestroy)) {
              var P = F._writableState;
              (!P || P.autoDestroy && P.finished) && F.destroy();
            }
          }
          function Ft(H, F) {
            for (var P = 0, U = H.length; P < U; P++)
              if (H[P] === F)
                return P;
            return -1;
          }
          D.prototype.read = function(H) {
            f("read", H), H = parseInt(H, 10);
            var F = this._readableState, P = H;
            if (H !== 0 && (F.emittedReadable = !1), H === 0 && F.needReadable && ((F.highWaterMark !== 0 ? F.length >= F.highWaterMark : F.length > 0) || F.ended))
              return f("read: emitReadable", F.length, F.ended), F.length === 0 && F.ended ? lt(this) : ot(this), null;
            if ((H = ut(H, F)) === 0 && F.ended)
              return F.length === 0 && lt(this), null;
            var U, rt = F.needReadable;
            return f("need readable", rt), (F.length === 0 || F.length - H < F.highWaterMark) && f("length less than watermark", rt = !0), F.ended || F.reading ? f("reading or ended", rt = !1) : rt && (f("do read"), F.reading = !0, F.sync = !0, F.length === 0 && (F.needReadable = !0), this._read(F.highWaterMark), F.sync = !1, F.reading || (H = ut(P, F))), (U = H > 0 ? G(H, F) : null) === null ? (F.needReadable = F.length <= F.highWaterMark, H = 0) : (F.length -= H, F.awaitDrain = 0), F.length === 0 && (F.ended || (F.needReadable = !0), P !== H && F.ended && lt(this)), U !== null && this.emit("data", U), U;
          }, D.prototype._read = function(H) {
            M(this, new l("_read()"));
          }, D.prototype.pipe = function(H, F) {
            var P = this, U = this._readableState;
            switch (U.pipesCount) {
              case 0:
                U.pipes = H;
                break;
              case 1:
                U.pipes = [U.pipes, H];
                break;
              default:
                U.pipes.push(H);
            }
            U.pipesCount += 1, f("pipe count=%d opts=%j", U.pipesCount, F);
            var rt = (!F || F.end !== !1) && H !== p.stdout && H !== p.stderr ? Ot : je;
            function ft(Ie, $e) {
              f("onunpipe"), Ie === P && $e && $e.hasUnpiped === !1 && ($e.hasUnpiped = !0, f("cleanup"), H.removeListener("close", Ce), H.removeListener("finish", _e), H.removeListener("drain", Wt), H.removeListener("error", ge), H.removeListener("unpipe", ft), P.removeListener("end", Ot), P.removeListener("end", je), P.removeListener("data", ye), ce = !0, !U.awaitDrain || H._writableState && !H._writableState.needDrain || Wt());
            }
            function Ot() {
              f("onend"), H.end();
            }
            U.endEmitted ? p.nextTick(rt) : P.once("end", rt), H.on("unpipe", ft);
            var Wt = at(P);
            H.on("drain", Wt);
            var ce = !1;
            function ye(Ie) {
              f("ondata");
              var $e = H.write(Ie);
              f("dest.write", $e), $e === !1 && ((U.pipesCount === 1 && U.pipes === H || U.pipesCount > 1 && Ft(U.pipes, H) !== -1) && !ce && (f("false write response, pause", U.awaitDrain), U.awaitDrain++), P.pause());
            }
            function ge(Ie) {
              f("onerror", Ie), je(), H.removeListener("error", ge), i(H, "error") === 0 && M(H, Ie);
            }
            function Ce() {
              H.removeListener("finish", _e), je();
            }
            function _e() {
              f("onfinish"), H.removeListener("close", Ce), je();
            }
            function je() {
              f("unpipe"), P.unpipe(H);
            }
            return P.on("data", ye), X(H, "error", ge), H.once("close", Ce), H.once("finish", _e), H.emit("pipe", P), U.flowing || (f("pipe resume"), P.resume()), H;
          }, D.prototype.unpipe = function(H) {
            var F = this._readableState, P = { hasUnpiped: !1 };
            if (F.pipesCount === 0)
              return this;
            if (F.pipesCount === 1)
              return H && H !== F.pipes ? this : (H || (H = F.pipes), F.pipes = null, F.pipesCount = 0, F.flowing = !1, H && H.emit("unpipe", this, P), this);
            if (!H) {
              var U = F.pipes, rt = F.pipesCount;
              F.pipes = null, F.pipesCount = 0, F.flowing = !1;
              for (var ft = 0; ft < rt; ft++)
                U[ft].emit("unpipe", this, { hasUnpiped: !1 });
              return this;
            }
            var Ot = Ft(F.pipes, H);
            return Ot === -1 ? this : (F.pipes.splice(Ot, 1), F.pipesCount -= 1, F.pipesCount === 1 && (F.pipes = F.pipes[0]), H.emit("unpipe", this, P), this);
          }, D.prototype.on = function(H, F) {
            var P = s.prototype.on.call(this, H, F), U = this._readableState;
            return H === "data" ? (U.readableListening = this.listenerCount("readable") > 0, U.flowing !== !1 && this.resume()) : H === "readable" && (U.endEmitted || U.readableListening || (U.readableListening = U.needReadable = !0, U.flowing = !1, U.emittedReadable = !1, f("on readable", U.length, U.reading), U.length ? ot(this) : U.reading || p.nextTick(Q, this))), P;
          }, D.prototype.addListener = D.prototype.on, D.prototype.removeListener = function(H, F) {
            var P = s.prototype.removeListener.call(this, H, F);
            return H === "readable" && p.nextTick(bt, this), P;
          }, D.prototype.removeAllListeners = function(H) {
            var F = s.prototype.removeAllListeners.apply(this, arguments);
            return H !== "readable" && H !== void 0 || p.nextTick(bt, this), F;
          }, D.prototype.resume = function() {
            var H = this._readableState;
            return H.flowing || (f("resume"), H.flowing = !H.readableListening, At(this, H)), H.paused = !1, this;
          }, D.prototype.pause = function() {
            return f("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (f("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
          }, D.prototype.wrap = function(H) {
            var F = this, P = this._readableState, U = !1;
            for (var rt in H.on("end", function() {
              if (f("wrapped end"), P.decoder && !P.ended) {
                var Ot = P.decoder.end();
                Ot && Ot.length && F.push(Ot);
              }
              F.push(null);
            }), H.on("data", function(Ot) {
              f("wrapped data"), P.decoder && (Ot = P.decoder.write(Ot)), P.objectMode && Ot == null || (P.objectMode || Ot && Ot.length) && (F.push(Ot) || (U = !0, H.pause()));
            }), H)
              this[rt] === void 0 && typeof H[rt] == "function" && (this[rt] = function(Ot) {
                return function() {
                  return H[Ot].apply(H, arguments);
                };
              }(rt));
            for (var ft = 0; ft < B.length; ft++)
              H.on(B[ft], this.emit.bind(this, B[ft]));
            return this._read = function(Ot) {
              f("wrapped _read", Ot), U && (U = !1, H.resume());
            }, this;
          }, typeof Symbol == "function" && (D.prototype[Symbol.asyncIterator] = function() {
            return h === void 0 && (h = x("./internal/streams/async_iterator")), h(this);
          }), Object.defineProperty(D.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
            return this._readableState.highWaterMark;
          } }), Object.defineProperty(D.prototype, "readableBuffer", { enumerable: !1, get: function() {
            return this._readableState && this._readableState.buffer;
          } }), Object.defineProperty(D.prototype, "readableFlowing", { enumerable: !1, get: function() {
            return this._readableState.flowing;
          }, set: function(H) {
            this._readableState && (this._readableState.flowing = H);
          } }), D._fromList = G, Object.defineProperty(D.prototype, "readableLength", { enumerable: !1, get: function() {
            return this._readableState.length;
          } }), typeof Symbol == "function" && (D.from = function(H, F) {
            return _ === void 0 && (_ = x("./internal/streams/from")), _(D, H, F);
          });
        }).call(this);
      }).call(this, x("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "../errors": 212, "./_stream_duplex": 213, "./internal/streams/async_iterator": 218, "./internal/streams/buffer_list": 219, "./internal/streams/destroy": 220, "./internal/streams/from": 222, "./internal/streams/state": 224, "./internal/streams/stream": 225, _process: 158, buffer: 46, events: 95, inherits: 110, "string_decoder/": 227, util: 42 }], 216: [function(x, C, c) {
      C.exports = u;
      var p = x("../errors").codes, v = p.ERR_METHOD_NOT_IMPLEMENTED, n = p.ERR_MULTIPLE_CALLBACK, i = p.ERR_TRANSFORM_ALREADY_TRANSFORMING, s = p.ERR_TRANSFORM_WITH_LENGTH_0, r = x("./_stream_duplex");
      function o(y, T) {
        var h = this._transformState;
        h.transforming = !1;
        var _ = h.writecb;
        if (_ === null)
          return this.emit("error", new n());
        h.writechunk = null, h.writecb = null, T != null && this.push(T), _(y);
        var g = this._readableState;
        g.reading = !1, (g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark);
      }
      function u(y) {
        if (!(this instanceof u))
          return new u(y);
        r.call(this, y), this._transformState = { afterTransform: o.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, y && (typeof y.transform == "function" && (this._transform = y.transform), typeof y.flush == "function" && (this._flush = y.flush)), this.on("prefinish", a);
      }
      function a() {
        var y = this;
        typeof this._flush != "function" || this._readableState.destroyed ? f(this, null, null) : this._flush(function(T, h) {
          f(y, T, h);
        });
      }
      function f(y, T, h) {
        if (T)
          return y.emit("error", T);
        if (h != null && y.push(h), y._writableState.length)
          throw new s();
        if (y._transformState.transforming)
          throw new i();
        return y.push(null);
      }
      x("inherits")(u, r), u.prototype.push = function(y, T) {
        return this._transformState.needTransform = !1, r.prototype.push.call(this, y, T);
      }, u.prototype._transform = function(y, T, h) {
        h(new v("_transform()"));
      }, u.prototype._write = function(y, T, h) {
        var _ = this._transformState;
        if (_.writecb = h, _.writechunk = y, _.writeencoding = T, !_.transforming) {
          var g = this._readableState;
          (_.needTransform || g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark);
        }
      }, u.prototype._read = function(y) {
        var T = this._transformState;
        T.writechunk === null || T.transforming ? T.needTransform = !0 : (T.transforming = !0, this._transform(T.writechunk, T.writeencoding, T.afterTransform));
      }, u.prototype._destroy = function(y, T) {
        r.prototype._destroy.call(this, y, function(h) {
          T(h);
        });
      };
    }, { "../errors": 212, "./_stream_duplex": 213, inherits: 110 }], 217: [function(x, C, c) {
      (function(p, v) {
        (function() {
          function n(q) {
            var G = this;
            this.next = null, this.entry = null, this.finish = function() {
              Pt(G, q);
            };
          }
          var i;
          C.exports = K, K.WritableState = X;
          var s = { deprecate: x("util-deprecate") }, r = x("./internal/streams/stream"), o = x("buffer").Buffer, u = v.Uint8Array || function() {
          };
          function a(q) {
            return o.from(q);
          }
          function f(q) {
            return o.isBuffer(q) || q instanceof u;
          }
          var y, T = x("./internal/streams/destroy"), h = x("./internal/streams/state"), _ = h.getHighWaterMark, g = x("../errors").codes, S = g.ERR_INVALID_ARG_TYPE, d = g.ERR_METHOD_NOT_IMPLEMENTED, b = g.ERR_MULTIPLE_CALLBACK, k = g.ERR_STREAM_CANNOT_PIPE, O = g.ERR_STREAM_DESTROYED, A = g.ERR_STREAM_NULL_VALUES, l = g.ERR_STREAM_WRITE_AFTER_END, E = g.ERR_UNKNOWN_ENCODING, M = T.errorOrDestroy;
          function B() {
          }
          function X(q, G, lt) {
            i = i || x("./_stream_duplex"), q = q || {}, typeof lt != "boolean" && (lt = G instanceof i), this.objectMode = !!q.objectMode, lt && (this.objectMode = this.objectMode || !!q.writableObjectMode), this.highWaterMark = _(this, q, "writableHighWaterMark", lt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var It = q.decodeStrings === !1;
            this.decodeStrings = !It, this.defaultEncoding = q.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ft) {
              V(G, Ft);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = q.emitClose !== !1, this.autoDestroy = !!q.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n(this);
          }
          function K(q) {
            var G = this instanceof (i = i || x("./_stream_duplex"));
            if (!G && !y.call(K, this))
              return new K(q);
            this._writableState = new X(q, this, G), this.writable = !0, q && (typeof q.write == "function" && (this._write = q.write), typeof q.writev == "function" && (this._writev = q.writev), typeof q.destroy == "function" && (this._destroy = q.destroy), typeof q.final == "function" && (this._final = q.final)), r.call(this);
          }
          function D(q, G) {
            var lt = new l();
            M(q, lt), p.nextTick(G, lt);
          }
          function j(q, G, lt, It) {
            var Ft;
            return lt === null ? Ft = new A() : typeof lt == "string" || G.objectMode || (Ft = new S("chunk", ["string", "Buffer"], lt)), !Ft || (M(q, Ft), p.nextTick(It, Ft), !1);
          }
          function Z(q, G, lt) {
            return q.objectMode || q.decodeStrings === !1 || typeof G != "string" || (G = o.from(G, lt)), G;
          }
          function tt(q, G, lt, It, Ft, H) {
            if (!lt) {
              var F = Z(G, It, Ft);
              It !== F && (lt = !0, Ft = "buffer", It = F);
            }
            var P = G.objectMode ? 1 : It.length;
            G.length += P;
            var U = G.length < G.highWaterMark;
            if (U || (G.needDrain = !0), G.writing || G.corked) {
              var rt = G.lastBufferedRequest;
              G.lastBufferedRequest = { chunk: It, encoding: Ft, isBuf: lt, callback: H, next: null }, rt ? rt.next = G.lastBufferedRequest : G.bufferedRequest = G.lastBufferedRequest, G.bufferedRequestCount += 1;
            } else
              nt(q, G, !1, P, It, Ft, H);
            return U;
          }
          function nt(q, G, lt, It, Ft, H, F) {
            G.writelen = It, G.writecb = F, G.writing = !0, G.sync = !0, G.destroyed ? G.onwrite(new O("write")) : lt ? q._writev(Ft, G.onwrite) : q._write(Ft, H, G.onwrite), G.sync = !1;
          }
          function ct(q, G, lt, It, Ft) {
            --G.pendingcb, lt ? (p.nextTick(Ft, It), p.nextTick(Q, q, G), q._writableState.errorEmitted = !0, M(q, It)) : (Ft(It), q._writableState.errorEmitted = !0, M(q, It), Q(q, G));
          }
          function ut(q) {
            q.writing = !1, q.writecb = null, q.length -= q.writelen, q.writelen = 0;
          }
          function V(q, G) {
            var lt = q._writableState, It = lt.sync, Ft = lt.writecb;
            if (typeof Ft != "function")
              throw new b();
            if (ut(lt), G)
              ct(q, lt, It, G, Ft);
            else {
              var H = pt(lt) || q.destroyed;
              H || lt.corked || lt.bufferProcessing || !lt.bufferedRequest || Ut(q, lt), It ? p.nextTick(ot, q, lt, H, Ft) : ot(q, lt, H, Ft);
            }
          }
          function ot(q, G, lt, It) {
            lt || xt(q, G), G.pendingcb--, It(), Q(q, G);
          }
          function xt(q, G) {
            G.length === 0 && G.needDrain && (G.needDrain = !1, q.emit("drain"));
          }
          function Ut(q, G) {
            G.bufferProcessing = !0;
            var lt = G.bufferedRequest;
            if (q._writev && lt && lt.next) {
              var It = G.bufferedRequestCount, Ft = new Array(It), H = G.corkedRequestsFree;
              H.entry = lt;
              for (var F = 0, P = !0; lt; )
                Ft[F] = lt, lt.isBuf || (P = !1), lt = lt.next, F += 1;
              Ft.allBuffers = P, nt(q, G, !0, G.length, Ft, "", H.finish), G.pendingcb++, G.lastBufferedRequest = null, H.next ? (G.corkedRequestsFree = H.next, H.next = null) : G.corkedRequestsFree = new n(G), G.bufferedRequestCount = 0;
            } else {
              for (; lt; ) {
                var U = lt.chunk, rt = lt.encoding, ft = lt.callback;
                if (nt(q, G, !1, G.objectMode ? 1 : U.length, U, rt, ft), lt = lt.next, G.bufferedRequestCount--, G.writing)
                  break;
              }
              lt === null && (G.lastBufferedRequest = null);
            }
            G.bufferedRequest = lt, G.bufferProcessing = !1;
          }
          function pt(q) {
            return q.ending && q.length === 0 && q.bufferedRequest === null && !q.finished && !q.writing;
          }
          function at(q, G) {
            q._final(function(lt) {
              G.pendingcb--, lt && M(q, lt), G.prefinished = !0, q.emit("prefinish"), Q(q, G);
            });
          }
          function bt(q, G) {
            G.prefinished || G.finalCalled || (typeof q._final != "function" || G.destroyed ? (G.prefinished = !0, q.emit("prefinish")) : (G.pendingcb++, G.finalCalled = !0, p.nextTick(at, q, G)));
          }
          function Q(q, G) {
            var lt = pt(G);
            if (lt && (bt(q, G), G.pendingcb === 0 && (G.finished = !0, q.emit("finish"), G.autoDestroy))) {
              var It = q._readableState;
              (!It || It.autoDestroy && It.endEmitted) && q.destroy();
            }
            return lt;
          }
          function At(q, G, lt) {
            G.ending = !0, Q(q, G), lt && (G.finished ? p.nextTick(lt) : q.once("finish", lt)), G.ended = !0, q.writable = !1;
          }
          function Pt(q, G, lt) {
            var It = q.entry;
            for (q.entry = null; It; ) {
              var Ft = It.callback;
              G.pendingcb--, Ft(lt), It = It.next;
            }
            G.corkedRequestsFree.next = q;
          }
          x("inherits")(K, r), X.prototype.getBuffer = function() {
            for (var q = this.bufferedRequest, G = []; q; )
              G.push(q), q = q.next;
            return G;
          }, function() {
            try {
              Object.defineProperty(X.prototype, "buffer", { get: s.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
            } catch (q) {
            }
          }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (y = Function.prototype[Symbol.hasInstance], Object.defineProperty(K, Symbol.hasInstance, { value: function(q) {
            return !!y.call(this, q) || this === K && q && q._writableState instanceof X;
          } })) : y = function(q) {
            return q instanceof this;
          }, K.prototype.pipe = function() {
            M(this, new k());
          }, K.prototype.write = function(q, G, lt) {
            var It = this._writableState, Ft = !1, H = !It.objectMode && f(q);
            return H && !o.isBuffer(q) && (q = a(q)), typeof G == "function" && (lt = G, G = null), H ? G = "buffer" : G || (G = It.defaultEncoding), typeof lt != "function" && (lt = B), It.ending ? D(this, lt) : (H || j(this, It, q, lt)) && (It.pendingcb++, Ft = tt(this, It, H, q, G, lt)), Ft;
          }, K.prototype.cork = function() {
            this._writableState.corked++;
          }, K.prototype.uncork = function() {
            var q = this._writableState;
            q.corked && (q.corked--, q.writing || q.corked || q.bufferProcessing || !q.bufferedRequest || Ut(this, q));
          }, K.prototype.setDefaultEncoding = function(q) {
            if (typeof q == "string" && (q = q.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((q + "").toLowerCase()) > -1))
              throw new E(q);
            return this._writableState.defaultEncoding = q, this;
          }, Object.defineProperty(K.prototype, "writableBuffer", { enumerable: !1, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } }), Object.defineProperty(K.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
            return this._writableState.highWaterMark;
          } }), K.prototype._write = function(q, G, lt) {
            lt(new d("_write()"));
          }, K.prototype._writev = null, K.prototype.end = function(q, G, lt) {
            var It = this._writableState;
            return typeof q == "function" ? (lt = q, q = null, G = null) : typeof G == "function" && (lt = G, G = null), q != null && this.write(q, G), It.corked && (It.corked = 1, this.uncork()), It.ending || At(this, It, lt), this;
          }, Object.defineProperty(K.prototype, "writableLength", { enumerable: !1, get: function() {
            return this._writableState.length;
          } }), Object.defineProperty(K.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._writableState !== void 0 && this._writableState.destroyed;
          }, set: function(q) {
            this._writableState && (this._writableState.destroyed = q);
          } }), K.prototype.destroy = T.destroy, K.prototype._undestroy = T.undestroy, K.prototype._destroy = function(q, G) {
            G(q);
          };
        }).call(this);
      }).call(this, x("_process"), typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "../errors": 212, "./_stream_duplex": 213, "./internal/streams/destroy": 220, "./internal/streams/state": 224, "./internal/streams/stream": 225, _process: 158, buffer: 46, inherits: 110, "util-deprecate": 232 }], 218: [function(x, C, c) {
      (function(p) {
        (function() {
          var v;
          function n(k, O, A) {
            return O in k ? Object.defineProperty(k, O, { value: A, enumerable: !0, configurable: !0, writable: !0 }) : k[O] = A, k;
          }
          var i = x("./end-of-stream"), s = Symbol("lastResolve"), r = Symbol("lastReject"), o = Symbol("error"), u = Symbol("ended"), a = Symbol("lastPromise"), f = Symbol("handlePromise"), y = Symbol("stream");
          function T(k, O) {
            return { value: k, done: O };
          }
          function h(k) {
            var O = k[s];
            if (O !== null) {
              var A = k[y].read();
              A !== null && (k[a] = null, k[s] = null, k[r] = null, O(T(A, !1)));
            }
          }
          function _(k) {
            p.nextTick(h, k);
          }
          function g(k, O) {
            return function(A, l) {
              k.then(function() {
                O[u] ? A(T(void 0, !0)) : O[f](A, l);
              }, l);
            };
          }
          var S = Object.getPrototypeOf(function() {
          }), d = Object.setPrototypeOf((n(v = { get stream() {
            return this[y];
          }, next: function() {
            var k = this, O = this[o];
            if (O !== null)
              return Promise.reject(O);
            if (this[u])
              return Promise.resolve(T(void 0, !0));
            if (this[y].destroyed)
              return new Promise(function(M, B) {
                p.nextTick(function() {
                  k[o] ? B(k[o]) : M(T(void 0, !0));
                });
              });
            var A, l = this[a];
            if (l)
              A = new Promise(g(l, this));
            else {
              var E = this[y].read();
              if (E !== null)
                return Promise.resolve(T(E, !1));
              A = new Promise(this[f]);
            }
            return this[a] = A, A;
          } }, Symbol.asyncIterator, function() {
            return this;
          }), n(v, "return", function() {
            var k = this;
            return new Promise(function(O, A) {
              k[y].destroy(null, function(l) {
                l ? A(l) : O(T(void 0, !0));
              });
            });
          }), v), S), b = function(k) {
            var O, A = Object.create(d, (n(O = {}, y, { value: k, writable: !0 }), n(O, s, { value: null, writable: !0 }), n(O, r, { value: null, writable: !0 }), n(O, o, { value: null, writable: !0 }), n(O, u, { value: k._readableState.endEmitted, writable: !0 }), n(O, f, { value: function(l, E) {
              var M = A[y].read();
              M ? (A[a] = null, A[s] = null, A[r] = null, l(T(M, !1))) : (A[s] = l, A[r] = E);
            }, writable: !0 }), O));
            return A[a] = null, i(k, function(l) {
              if (l && l.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var E = A[r];
                return E !== null && (A[a] = null, A[s] = null, A[r] = null, E(l)), void (A[o] = l);
              }
              var M = A[s];
              M !== null && (A[a] = null, A[s] = null, A[r] = null, M(T(void 0, !0))), A[u] = !0;
            }), k.on("readable", _.bind(null, A)), A;
          };
          C.exports = b;
        }).call(this);
      }).call(this, x("_process"));
    }, { "./end-of-stream": 221, _process: 158 }], 219: [function(x, C, c) {
      function p(h, _) {
        var g = Object.keys(h);
        if (Object.getOwnPropertySymbols) {
          var S = Object.getOwnPropertySymbols(h);
          _ && (S = S.filter(function(d) {
            return Object.getOwnPropertyDescriptor(h, d).enumerable;
          })), g.push.apply(g, S);
        }
        return g;
      }
      function v(h) {
        for (var _ = 1; _ < arguments.length; _++) {
          var g = arguments[_] != null ? arguments[_] : {};
          _ % 2 ? p(Object(g), !0).forEach(function(S) {
            n(h, S, g[S]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(h, Object.getOwnPropertyDescriptors(g)) : p(Object(g)).forEach(function(S) {
            Object.defineProperty(h, S, Object.getOwnPropertyDescriptor(g, S));
          });
        }
        return h;
      }
      function n(h, _, g) {
        return _ in h ? Object.defineProperty(h, _, { value: g, enumerable: !0, configurable: !0, writable: !0 }) : h[_] = g, h;
      }
      function i(h, _) {
        if (!(h instanceof _))
          throw new TypeError("Cannot call a class as a function");
      }
      function s(h, _) {
        for (var g = 0; g < _.length; g++) {
          var S = _[g];
          S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(h, S.key, S);
        }
      }
      function r(h, _, g) {
        return _ && s(h.prototype, _), g && s(h, g), h;
      }
      var o = x("buffer"), u = o.Buffer, a = x("util"), f = a.inspect, y = f && f.custom || "inspect";
      function T(h, _, g) {
        u.prototype.copy.call(h, _, g);
      }
      C.exports = function() {
        function h() {
          i(this, h), this.head = null, this.tail = null, this.length = 0;
        }
        return r(h, [{ key: "push", value: function(_) {
          var g = { data: _, next: null };
          this.length > 0 ? this.tail.next = g : this.head = g, this.tail = g, ++this.length;
        } }, { key: "unshift", value: function(_) {
          var g = { data: _, next: this.head };
          this.length === 0 && (this.tail = g), this.head = g, ++this.length;
        } }, { key: "shift", value: function() {
          if (this.length !== 0) {
            var _ = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, _;
          }
        } }, { key: "clear", value: function() {
          this.head = this.tail = null, this.length = 0;
        } }, { key: "join", value: function(_) {
          if (this.length === 0)
            return "";
          for (var g = this.head, S = "" + g.data; g = g.next; )
            S += _ + g.data;
          return S;
        } }, { key: "concat", value: function(_) {
          if (this.length === 0)
            return u.alloc(0);
          for (var g = u.allocUnsafe(_ >>> 0), S = this.head, d = 0; S; )
            T(S.data, g, d), d += S.data.length, S = S.next;
          return g;
        } }, { key: "consume", value: function(_, g) {
          var S;
          return _ < this.head.data.length ? (S = this.head.data.slice(0, _), this.head.data = this.head.data.slice(_)) : S = _ === this.head.data.length ? this.shift() : g ? this._getString(_) : this._getBuffer(_), S;
        } }, { key: "first", value: function() {
          return this.head.data;
        } }, { key: "_getString", value: function(_) {
          var g = this.head, S = 1, d = g.data;
          for (_ -= d.length; g = g.next; ) {
            var b = g.data, k = _ > b.length ? b.length : _;
            if (k === b.length ? d += b : d += b.slice(0, _), (_ -= k) === 0) {
              k === b.length ? (++S, g.next ? this.head = g.next : this.head = this.tail = null) : (this.head = g, g.data = b.slice(k));
              break;
            }
            ++S;
          }
          return this.length -= S, d;
        } }, { key: "_getBuffer", value: function(_) {
          var g = u.allocUnsafe(_), S = this.head, d = 1;
          for (S.data.copy(g), _ -= S.data.length; S = S.next; ) {
            var b = S.data, k = _ > b.length ? b.length : _;
            if (b.copy(g, g.length - _, 0, k), (_ -= k) === 0) {
              k === b.length ? (++d, S.next ? this.head = S.next : this.head = this.tail = null) : (this.head = S, S.data = b.slice(k));
              break;
            }
            ++d;
          }
          return this.length -= d, g;
        } }, { key: y, value: function(_, g) {
          return f(this, v({}, g, { depth: 0, customInspect: !1 }));
        } }]), h;
      }();
    }, { buffer: 46, util: 42 }], 220: [function(x, C, c) {
      (function(p) {
        (function() {
          function v(u, a) {
            var f = this, y = this._readableState && this._readableState.destroyed, T = this._writableState && this._writableState.destroyed;
            return y || T ? (a ? a(u) : u && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, p.nextTick(r, this, u)) : p.nextTick(r, this, u)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(u || null, function(h) {
              !a && h ? f._writableState ? f._writableState.errorEmitted ? p.nextTick(i, f) : (f._writableState.errorEmitted = !0, p.nextTick(n, f, h)) : p.nextTick(n, f, h) : a ? (p.nextTick(i, f), a(h)) : p.nextTick(i, f);
            }), this);
          }
          function n(u, a) {
            r(u, a), i(u);
          }
          function i(u) {
            u._writableState && !u._writableState.emitClose || u._readableState && !u._readableState.emitClose || u.emit("close");
          }
          function s() {
            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
          }
          function r(u, a) {
            u.emit("error", a);
          }
          function o(u, a) {
            var f = u._readableState, y = u._writableState;
            f && f.autoDestroy || y && y.autoDestroy ? u.destroy(a) : u.emit("error", a);
          }
          C.exports = { destroy: v, undestroy: s, errorOrDestroy: o };
        }).call(this);
      }).call(this, x("_process"));
    }, { _process: 158 }], 221: [function(x, C, c) {
      var p = x("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
      function v(r) {
        var o = !1;
        return function() {
          if (!o) {
            o = !0;
            for (var u = arguments.length, a = new Array(u), f = 0; f < u; f++)
              a[f] = arguments[f];
            r.apply(this, a);
          }
        };
      }
      function n() {
      }
      function i(r) {
        return r.setHeader && typeof r.abort == "function";
      }
      function s(r, o, u) {
        if (typeof o == "function")
          return s(r, null, o);
        o || (o = {}), u = v(u || n);
        var a = o.readable || o.readable !== !1 && r.readable, f = o.writable || o.writable !== !1 && r.writable, y = function() {
          r.writable || h();
        }, T = r._writableState && r._writableState.finished, h = function() {
          f = !1, T = !0, a || u.call(r);
        }, _ = r._readableState && r._readableState.endEmitted, g = function() {
          a = !1, _ = !0, f || u.call(r);
        }, S = function(k) {
          u.call(r, k);
        }, d = function() {
          var k;
          return a && !_ ? (r._readableState && r._readableState.ended || (k = new p()), u.call(r, k)) : f && !T ? (r._writableState && r._writableState.ended || (k = new p()), u.call(r, k)) : void 0;
        }, b = function() {
          r.req.on("finish", h);
        };
        return i(r) ? (r.on("complete", h), r.on("abort", d), r.req ? b() : r.on("request", b)) : f && !r._writableState && (r.on("end", y), r.on("close", y)), r.on("end", g), r.on("finish", h), o.error !== !1 && r.on("error", S), r.on("close", d), function() {
          r.removeListener("complete", h), r.removeListener("abort", d), r.removeListener("request", b), r.req && r.req.removeListener("finish", h), r.removeListener("end", y), r.removeListener("close", y), r.removeListener("finish", h), r.removeListener("end", g), r.removeListener("error", S), r.removeListener("close", d);
        };
      }
      C.exports = s;
    }, { "../../../errors": 212 }], 222: [function(x, C, c) {
      C.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, {}], 223: [function(x, C, c) {
      var p;
      function v(h) {
        var _ = !1;
        return function() {
          _ || (_ = !0, h.apply(void 0, arguments));
        };
      }
      var n = x("../../../errors").codes, i = n.ERR_MISSING_ARGS, s = n.ERR_STREAM_DESTROYED;
      function r(h) {
        if (h)
          throw h;
      }
      function o(h) {
        return h.setHeader && typeof h.abort == "function";
      }
      function u(h, _, g, S) {
        S = v(S);
        var d = !1;
        h.on("close", function() {
          d = !0;
        }), p === void 0 && (p = x("./end-of-stream")), p(h, { readable: _, writable: g }, function(k) {
          if (k)
            return S(k);
          d = !0, S();
        });
        var b = !1;
        return function(k) {
          if (!d && !b)
            return b = !0, o(h) ? h.abort() : typeof h.destroy == "function" ? h.destroy() : void S(k || new s("pipe"));
        };
      }
      function a(h) {
        h();
      }
      function f(h, _) {
        return h.pipe(_);
      }
      function y(h) {
        return h.length ? typeof h[h.length - 1] != "function" ? r : h.pop() : r;
      }
      function T() {
        for (var h = arguments.length, _ = new Array(h), g = 0; g < h; g++)
          _[g] = arguments[g];
        var S, d = y(_);
        if (Array.isArray(_[0]) && (_ = _[0]), _.length < 2)
          throw new i("streams");
        var b = _.map(function(k, O) {
          var A = O < _.length - 1;
          return u(k, A, O > 0, function(l) {
            S || (S = l), l && b.forEach(a), A || (b.forEach(a), d(S));
          });
        });
        return _.reduce(f);
      }
      C.exports = T;
    }, { "../../../errors": 212, "./end-of-stream": 221 }], 224: [function(x, C, c) {
      var p = x("../../../errors").codes.ERR_INVALID_OPT_VALUE;
      function v(i, s, r) {
        return i.highWaterMark != null ? i.highWaterMark : s ? i[r] : null;
      }
      function n(i, s, r, o) {
        var u = v(s, o, r);
        if (u != null) {
          if (!isFinite(u) || Math.floor(u) !== u || u < 0)
            throw new p(o ? r : "highWaterMark", u);
          return Math.floor(u);
        }
        return i.objectMode ? 16 : 16384;
      }
      C.exports = { getHighWaterMark: n };
    }, { "../../../errors": 212 }], 225: [function(x, C, c) {
      C.exports = x("events").EventEmitter;
    }, { events: 95 }], 226: [function(x, C, c) {
      c = C.exports = x("./lib/_stream_readable.js"), c.Stream = c, c.Readable = c, c.Writable = x("./lib/_stream_writable.js"), c.Duplex = x("./lib/_stream_duplex.js"), c.Transform = x("./lib/_stream_transform.js"), c.PassThrough = x("./lib/_stream_passthrough.js"), c.finished = x("./lib/internal/streams/end-of-stream.js"), c.pipeline = x("./lib/internal/streams/pipeline.js");
    }, { "./lib/_stream_duplex.js": 213, "./lib/_stream_passthrough.js": 214, "./lib/_stream_readable.js": 215, "./lib/_stream_transform.js": 216, "./lib/_stream_writable.js": 217, "./lib/internal/streams/end-of-stream.js": 221, "./lib/internal/streams/pipeline.js": 223 }], 227: [function(x, C, c) {
      var p = x("safe-buffer").Buffer, v = p.isEncoding || function(b) {
        switch ((b = "" + b) && b.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1;
        }
      };
      function n(b) {
        if (!b)
          return "utf8";
        for (var k; ; )
          switch (b) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return b;
            default:
              if (k)
                return;
              b = ("" + b).toLowerCase(), k = !0;
          }
      }
      function i(b) {
        var k = n(b);
        if (typeof k != "string" && (p.isEncoding === v || !v(b)))
          throw new Error("Unknown encoding: " + b);
        return k || b;
      }
      function s(b) {
        var k;
        switch (this.encoding = i(b), this.encoding) {
          case "utf16le":
            this.text = T, this.end = h, k = 4;
            break;
          case "utf8":
            this.fillLast = a, k = 4;
            break;
          case "base64":
            this.text = _, this.end = g, k = 3;
            break;
          default:
            return this.write = S, void (this.end = d);
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = p.allocUnsafe(k);
      }
      function r(b) {
        return b <= 127 ? 0 : b >> 5 == 6 ? 2 : b >> 4 == 14 ? 3 : b >> 3 == 30 ? 4 : b >> 6 == 2 ? -1 : -2;
      }
      function o(b, k, O) {
        var A = k.length - 1;
        if (A < O)
          return 0;
        var l = r(k[A]);
        return l >= 0 ? (l > 0 && (b.lastNeed = l - 1), l) : --A < O || l === -2 ? 0 : (l = r(k[A])) >= 0 ? (l > 0 && (b.lastNeed = l - 2), l) : --A < O || l === -2 ? 0 : (l = r(k[A])) >= 0 ? (l > 0 && (l === 2 ? l = 0 : b.lastNeed = l - 3), l) : 0;
      }
      function u(b, k, O) {
        if ((192 & k[0]) != 128)
          return b.lastNeed = 0, "�";
        if (b.lastNeed > 1 && k.length > 1) {
          if ((192 & k[1]) != 128)
            return b.lastNeed = 1, "�";
          if (b.lastNeed > 2 && k.length > 2 && (192 & k[2]) != 128)
            return b.lastNeed = 2, "�";
        }
      }
      function a(b) {
        var k = this.lastTotal - this.lastNeed, O = u(this, b);
        return O !== void 0 ? O : this.lastNeed <= b.length ? (b.copy(this.lastChar, k, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (b.copy(this.lastChar, k, 0, b.length), void (this.lastNeed -= b.length));
      }
      function f(b, k) {
        var O = o(this, b, k);
        if (!this.lastNeed)
          return b.toString("utf8", k);
        this.lastTotal = O;
        var A = b.length - (O - this.lastNeed);
        return b.copy(this.lastChar, 0, A), b.toString("utf8", k, A);
      }
      function y(b) {
        var k = b && b.length ? this.write(b) : "";
        return this.lastNeed ? k + "�" : k;
      }
      function T(b, k) {
        if ((b.length - k) % 2 == 0) {
          var O = b.toString("utf16le", k);
          if (O) {
            var A = O.charCodeAt(O.length - 1);
            if (A >= 55296 && A <= 56319)
              return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1], O.slice(0, -1);
          }
          return O;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = b[b.length - 1], b.toString("utf16le", k, b.length - 1);
      }
      function h(b) {
        var k = b && b.length ? this.write(b) : "";
        if (this.lastNeed) {
          var O = this.lastTotal - this.lastNeed;
          return k + this.lastChar.toString("utf16le", 0, O);
        }
        return k;
      }
      function _(b, k) {
        var O = (b.length - k) % 3;
        return O === 0 ? b.toString("base64", k) : (this.lastNeed = 3 - O, this.lastTotal = 3, O === 1 ? this.lastChar[0] = b[b.length - 1] : (this.lastChar[0] = b[b.length - 2], this.lastChar[1] = b[b.length - 1]), b.toString("base64", k, b.length - O));
      }
      function g(b) {
        var k = b && b.length ? this.write(b) : "";
        return this.lastNeed ? k + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : k;
      }
      function S(b) {
        return b.toString(this.encoding);
      }
      function d(b) {
        return b && b.length ? this.write(b) : "";
      }
      c.StringDecoder = s, s.prototype.write = function(b) {
        if (b.length === 0)
          return "";
        var k, O;
        if (this.lastNeed) {
          if ((k = this.fillLast(b)) === void 0)
            return "";
          O = this.lastNeed, this.lastNeed = 0;
        } else
          O = 0;
        return O < b.length ? k ? k + this.text(b, O) : this.text(b, O) : k || "";
      }, s.prototype.end = y, s.prototype.text = f, s.prototype.fillLast = function(b) {
        if (this.lastNeed <= b.length)
          return b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        b.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, b.length), this.lastNeed -= b.length;
      };
    }, { "safe-buffer": 164 }], 228: [function(x, C, c) {
      (function(p, v) {
        (function() {
          var n = x("process/browser.js").nextTick, i = Function.prototype.apply, s = Array.prototype.slice, r = {}, o = 0;
          function u(a, f) {
            this._id = a, this._clearFn = f;
          }
          c.setTimeout = function() {
            return new u(i.call(setTimeout, window, arguments), clearTimeout);
          }, c.setInterval = function() {
            return new u(i.call(setInterval, window, arguments), clearInterval);
          }, c.clearTimeout = c.clearInterval = function(a) {
            a.close();
          }, u.prototype.unref = u.prototype.ref = function() {
          }, u.prototype.close = function() {
            this._clearFn.call(window, this._id);
          }, c.enroll = function(a, f) {
            clearTimeout(a._idleTimeoutId), a._idleTimeout = f;
          }, c.unenroll = function(a) {
            clearTimeout(a._idleTimeoutId), a._idleTimeout = -1;
          }, c._unrefActive = c.active = function(a) {
            clearTimeout(a._idleTimeoutId);
            var f = a._idleTimeout;
            f >= 0 && (a._idleTimeoutId = setTimeout(function() {
              a._onTimeout && a._onTimeout();
            }, f));
          }, c.setImmediate = typeof p == "function" ? p : function(a) {
            var f = o++, y = !(arguments.length < 2) && s.call(arguments, 1);
            return r[f] = !0, n(function() {
              r[f] && (y ? a.apply(null, y) : a.call(null), c.clearImmediate(f));
            }), f;
          }, c.clearImmediate = typeof v == "function" ? v : function(a) {
            delete r[a];
          };
        }).call(this);
      }).call(this, x("timers").setImmediate, x("timers").clearImmediate);
    }, { "process/browser.js": 158, timers: 228 }], 229: [function(x, C, c) {
      var p = x("punycode"), v = x("./util");
      function n() {
        this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
      }
      c.parse = k, c.resolve = A, c.resolveObject = l, c.format = O, c.Url = n;
      var i = /^([a-z0-9.+-]+:)/i, s = /:[0-9]*$/, r = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, o = ["<", ">", '"', "`", " ", "\r", `
`, "	"], u = ["{", "}", "|", "\\", "^", "`"].concat(o), a = ["'"].concat(u), f = ["%", "/", "?", ";", "#"].concat(a), y = ["/", "?", "#"], T = 255, h = /^[+a-z0-9A-Z_-]{0,63}$/, _ = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, g = { javascript: !0, "javascript:": !0 }, S = { javascript: !0, "javascript:": !0 }, d = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 }, b = x("querystring");
      function k(E, M, B) {
        if (E && v.isObject(E) && E instanceof n)
          return E;
        var X = new n();
        return X.parse(E, M, B), X;
      }
      function O(E) {
        return v.isString(E) && (E = k(E)), E instanceof n ? E.format() : n.prototype.format.call(E);
      }
      function A(E, M) {
        return k(E, !1, !0).resolve(M);
      }
      function l(E, M) {
        return E ? k(E, !1, !0).resolveObject(M) : M;
      }
      n.prototype.parse = function(E, M, B) {
        if (!v.isString(E))
          throw new TypeError("Parameter 'url' must be a string, not " + typeof E);
        var X = E.indexOf("?"), K = X !== -1 && X < E.indexOf("#") ? "?" : "#", D = E.split(K);
        D[0] = D[0].replace(/\\/g, "/");
        var j = E = D.join(K);
        if (j = j.trim(), !B && E.split("#").length === 1) {
          var Z = r.exec(j);
          if (Z)
            return this.path = j, this.href = j, this.pathname = Z[1], Z[2] ? (this.search = Z[2], this.query = M ? b.parse(this.search.substr(1)) : this.search.substr(1)) : M && (this.search = "", this.query = {}), this;
        }
        var tt = i.exec(j);
        if (tt) {
          var nt = (tt = tt[0]).toLowerCase();
          this.protocol = nt, j = j.substr(tt.length);
        }
        if (B || tt || j.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var ct = j.substr(0, 2) === "//";
          !ct || tt && S[tt] || (j = j.substr(2), this.slashes = !0);
        }
        if (!S[tt] && (ct || tt && !d[tt])) {
          for (var ut, V, ot = -1, xt = 0; xt < y.length; xt++)
            (Ut = j.indexOf(y[xt])) !== -1 && (ot === -1 || Ut < ot) && (ot = Ut);
          for ((V = ot === -1 ? j.lastIndexOf("@") : j.lastIndexOf("@", ot)) !== -1 && (ut = j.slice(0, V), j = j.slice(V + 1), this.auth = decodeURIComponent(ut)), ot = -1, xt = 0; xt < f.length; xt++) {
            var Ut;
            (Ut = j.indexOf(f[xt])) !== -1 && (ot === -1 || Ut < ot) && (ot = Ut);
          }
          ot === -1 && (ot = j.length), this.host = j.slice(0, ot), j = j.slice(ot), this.parseHost(), this.hostname = this.hostname || "";
          var pt = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
          if (!pt)
            for (var at = this.hostname.split(/\./), bt = (xt = 0, at.length); xt < bt; xt++) {
              var Q = at[xt];
              if (Q && !Q.match(h)) {
                for (var At = "", Pt = 0, q = Q.length; Pt < q; Pt++)
                  Q.charCodeAt(Pt) > 127 ? At += "x" : At += Q[Pt];
                if (!At.match(h)) {
                  var G = at.slice(0, xt), lt = at.slice(xt + 1), It = Q.match(_);
                  It && (G.push(It[1]), lt.unshift(It[2])), lt.length && (j = "/" + lt.join(".") + j), this.hostname = G.join(".");
                  break;
                }
              }
            }
          this.hostname.length > T ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), pt || (this.hostname = p.toASCII(this.hostname));
          var Ft = this.port ? ":" + this.port : "", H = this.hostname || "";
          this.host = H + Ft, this.href += this.host, pt && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), j[0] !== "/" && (j = "/" + j));
        }
        if (!g[nt])
          for (xt = 0, bt = a.length; xt < bt; xt++) {
            var F = a[xt];
            if (j.indexOf(F) !== -1) {
              var P = encodeURIComponent(F);
              P === F && (P = escape(F)), j = j.split(F).join(P);
            }
          }
        var U = j.indexOf("#");
        U !== -1 && (this.hash = j.substr(U), j = j.slice(0, U));
        var rt = j.indexOf("?");
        if (rt !== -1 ? (this.search = j.substr(rt), this.query = j.substr(rt + 1), M && (this.query = b.parse(this.query)), j = j.slice(0, rt)) : M && (this.search = "", this.query = {}), j && (this.pathname = j), d[nt] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          Ft = this.pathname || "";
          var ft = this.search || "";
          this.path = Ft + ft;
        }
        return this.href = this.format(), this;
      }, n.prototype.format = function() {
        var E = this.auth || "";
        E && (E = (E = encodeURIComponent(E)).replace(/%3A/i, ":"), E += "@");
        var M = this.protocol || "", B = this.pathname || "", X = this.hash || "", K = !1, D = "";
        this.host ? K = E + this.host : this.hostname && (K = E + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (K += ":" + this.port)), this.query && v.isObject(this.query) && Object.keys(this.query).length && (D = b.stringify(this.query));
        var j = this.search || D && "?" + D || "";
        return M && M.substr(-1) !== ":" && (M += ":"), this.slashes || (!M || d[M]) && K !== !1 ? (K = "//" + (K || ""), B && B.charAt(0) !== "/" && (B = "/" + B)) : K || (K = ""), X && X.charAt(0) !== "#" && (X = "#" + X), j && j.charAt(0) !== "?" && (j = "?" + j), M + K + (B = B.replace(/[?#]/g, function(Z) {
          return encodeURIComponent(Z);
        })) + (j = j.replace("#", "%23")) + X;
      }, n.prototype.resolve = function(E) {
        return this.resolveObject(k(E, !1, !0)).format();
      }, n.prototype.resolveObject = function(E) {
        if (v.isString(E)) {
          var M = new n();
          M.parse(E, !1, !0), E = M;
        }
        for (var B = new n(), X = Object.keys(this), K = 0; K < X.length; K++) {
          var D = X[K];
          B[D] = this[D];
        }
        if (B.hash = E.hash, E.href === "")
          return B.href = B.format(), B;
        if (E.slashes && !E.protocol) {
          for (var j = Object.keys(E), Z = 0; Z < j.length; Z++) {
            var tt = j[Z];
            tt !== "protocol" && (B[tt] = E[tt]);
          }
          return d[B.protocol] && B.hostname && !B.pathname && (B.path = B.pathname = "/"), B.href = B.format(), B;
        }
        if (E.protocol && E.protocol !== B.protocol) {
          if (!d[E.protocol]) {
            for (var nt = Object.keys(E), ct = 0; ct < nt.length; ct++) {
              var ut = nt[ct];
              B[ut] = E[ut];
            }
            return B.href = B.format(), B;
          }
          if (B.protocol = E.protocol, E.host || S[E.protocol])
            B.pathname = E.pathname;
          else {
            for (var V = (E.pathname || "").split("/"); V.length && !(E.host = V.shift()); )
              ;
            E.host || (E.host = ""), E.hostname || (E.hostname = ""), V[0] !== "" && V.unshift(""), V.length < 2 && V.unshift(""), B.pathname = V.join("/");
          }
          if (B.search = E.search, B.query = E.query, B.host = E.host || "", B.auth = E.auth, B.hostname = E.hostname || E.host, B.port = E.port, B.pathname || B.search) {
            var ot = B.pathname || "", xt = B.search || "";
            B.path = ot + xt;
          }
          return B.slashes = B.slashes || E.slashes, B.href = B.format(), B;
        }
        var Ut = B.pathname && B.pathname.charAt(0) === "/", pt = E.host || E.pathname && E.pathname.charAt(0) === "/", at = pt || Ut || B.host && E.pathname, bt = at, Q = B.pathname && B.pathname.split("/") || [], At = (V = E.pathname && E.pathname.split("/") || [], B.protocol && !d[B.protocol]);
        if (At && (B.hostname = "", B.port = null, B.host && (Q[0] === "" ? Q[0] = B.host : Q.unshift(B.host)), B.host = "", E.protocol && (E.hostname = null, E.port = null, E.host && (V[0] === "" ? V[0] = E.host : V.unshift(E.host)), E.host = null), at = at && (V[0] === "" || Q[0] === "")), pt)
          B.host = E.host || E.host === "" ? E.host : B.host, B.hostname = E.hostname || E.hostname === "" ? E.hostname : B.hostname, B.search = E.search, B.query = E.query, Q = V;
        else if (V.length)
          Q || (Q = []), Q.pop(), Q = Q.concat(V), B.search = E.search, B.query = E.query;
        else if (!v.isNullOrUndefined(E.search))
          return At && (B.hostname = B.host = Q.shift(), (It = !!(B.host && B.host.indexOf("@") > 0) && B.host.split("@")) && (B.auth = It.shift(), B.host = B.hostname = It.shift())), B.search = E.search, B.query = E.query, v.isNull(B.pathname) && v.isNull(B.search) || (B.path = (B.pathname ? B.pathname : "") + (B.search ? B.search : "")), B.href = B.format(), B;
        if (!Q.length)
          return B.pathname = null, B.search ? B.path = "/" + B.search : B.path = null, B.href = B.format(), B;
        for (var Pt = Q.slice(-1)[0], q = (B.host || E.host || Q.length > 1) && (Pt === "." || Pt === "..") || Pt === "", G = 0, lt = Q.length; lt >= 0; lt--)
          (Pt = Q[lt]) === "." ? Q.splice(lt, 1) : Pt === ".." ? (Q.splice(lt, 1), G++) : G && (Q.splice(lt, 1), G--);
        if (!at && !bt)
          for (; G--; G)
            Q.unshift("..");
        !at || Q[0] === "" || Q[0] && Q[0].charAt(0) === "/" || Q.unshift(""), q && Q.join("/").substr(-1) !== "/" && Q.push("");
        var It, Ft = Q[0] === "" || Q[0] && Q[0].charAt(0) === "/";
        return At && (B.hostname = B.host = Ft ? "" : Q.length ? Q.shift() : "", (It = !!(B.host && B.host.indexOf("@") > 0) && B.host.split("@")) && (B.auth = It.shift(), B.host = B.hostname = It.shift())), (at = at || B.host && Q.length) && !Ft && Q.unshift(""), Q.length ? B.pathname = Q.join("/") : (B.pathname = null, B.path = null), v.isNull(B.pathname) && v.isNull(B.search) || (B.path = (B.pathname ? B.pathname : "") + (B.search ? B.search : "")), B.auth = E.auth || B.auth, B.slashes = B.slashes || E.slashes, B.href = B.format(), B;
      }, n.prototype.parseHost = function() {
        var E = this.host, M = s.exec(E);
        M && ((M = M[0]) !== ":" && (this.port = M.substr(1)), E = E.substr(0, E.length - M.length)), E && (this.hostname = E);
      };
    }, { "./util": 230, punycode: 159, querystring: 162 }], 230: [function(x, C, c) {
      C.exports = { isString: function(p) {
        return typeof p == "string";
      }, isObject: function(p) {
        return typeof p == "object" && p !== null;
      }, isNull: function(p) {
        return p === null;
      }, isNullOrUndefined: function(p) {
        return p == null;
      } };
    }, {}], 231: [function(x, C, c) {
      const p = x("path"), v = x("module"), n = x("nid"), i = x("norma"), s = x("eraro"), r = x("lodash.defaultsdeep");
      function o(d) {
        d = Object.assign({ prefix: "plugin-", builtin: "../plugin/", module: C.parent, errmsgprefix: !0, system_modules: S.make_system_modules(), merge_defaults: !0, gubu: !0 }, d);
        const b = s({ package: "use-plugin", msgmap: g(), module: C, prefix: d.errmsgprefix });
        function k() {
          return u(a(i("{plugin:o|f|s, options:o|s|n|b?, callback:f?}", arguments), d, b), d, b);
        }
        return k.use_plugin_desc = function(O) {
          return u(O, d, b);
        }, k.build_plugin_desc = function() {
          return a(i("{plugin:o|f|s, options:o|s|n|b?, callback:f?}", arguments), d, b);
        }, k;
      }
      function u(d, b, k) {
        d.search = _(d.name, b.builtin, b.prefix, b.system_modules), typeof d.init != "function" && f(d, b.module, k);
        let O = null;
        if (O = d.init && d.init.defaults && (d.init.defaults.gubu && d.init.defaults.gubu.gubu$ || typeof d.init.defaults == "function") ? d.init.defaults : d.defaults && d.defaults.gubu && d.defaults.gubu.gubu$ || typeof d.defaults == "function" ? d.defaults : Object.assign({}, d.defaults, d.init && d.init.defaults), d.defaults = O, b.merge_defaults && typeof O == "object" && (d.options = r({}, d.options, O)), typeof d.init != "function") {
          const A = {};
          for (let E = 0; E < d.history.length; E++) {
            const M = d.history[E], B = p.dirname(M.module);
            A[B] = A[B] || [], A[B].push(M.path);
          }
          const l = [];
          throw Object.keys(A).forEach(function(E) {
            l.push("[ " + p.resolve(E) + ": "), A[E].forEach(function(M) {
              l.push(M + ", ");
            }), l.push(" ] ");
          }), d.searchlist = l.join(""), k("not_found", d);
        }
        return d;
      }
      function a(d, b, k) {
        const O = d.plugin;
        let A = d.options == null ? O.options == null ? {} : O.options : d.options, l = { options: A = typeof A == "object" ? A : { value$: A }, callback: d.callback, history: [] };
        if (typeof O == "string")
          l.name = O;
        else if (typeof O == "function") {
          if (O.name !== "")
            l.name = O.name;
          else {
            const M = Array.isArray(b.prefix) ? b.prefix[0] : b.prefix;
            l.name = M + n();
          }
          l.init = O;
        } else if (typeof O == "object") {
          let M = (l = Object.assign({}, O, l)).name;
          if (typeof M != "string" && (M = l.init != null ? l.init.name : null), M == null)
            throw k("no_name", { plugin: O });
          if (l.name = M, l.init != null && typeof l.init != "function")
            throw k("no_init_function", { name: M, plugin: O });
        }
        l.options = Object.assign({}, l.options || {}, A || {});
        const E = /^(.+)\$(.+)$/.exec(l.name);
        if (E && (l.name = E[1], l.tag = E[2]), l.full = l.name + (l.tag == null || l.tag == "" ? "" : "$" + l.tag), !l.name)
          throw k("no_name", l);
        return l;
      }
      function f(d, b, k) {
        let O, A = b, l = !0, E = 0, M = {};
        for (; M.initfunc == null && (O = T(A)); ) {
          if ((M = h(O, d, l, E)).error)
            throw y(M.error, M.found, d, k);
          l = !1, E++, A = A.parent;
        }
        d.modulepath = M.module, d.requirepath = M.require, d.found = M.found, M.initfunc && M.initfunc.name != null && M.initfunc.name !== "" && (d.name = M.initfunc.name), d.init = M.initfunc, d.init && typeof d.init.defaults == "object" && (d.defaults = Object.assign({}, d.init.defaults));
      }
      function y(d, b, k, O) {
        return k.err = d, k.found = b, k.found_name = k.found.name, k.err_msg = d.message, d instanceof SyntaxError ? O("syntax_error", k) : d.code == "MODULE_NOT_FOUND" ? (k.err_msg = d.stack.replace(/\n.*\(module\.js:.*/g, ""), k.err_msg = k.err_msg.replace(/\s+/g, " "), O("require_failed", k)) : O("load_failed", k);
      }
      function T(d) {
        if (d == null)
          return null;
        const b = d.require.bind(d);
        return b.module = d.id, b;
      }
      function h(d, b, k, O) {
        const A = b.search;
        let l, E;
        t:
          for (let M = 0; M < A.length; M++)
            if (E = A[M], (k || E.type != "builtin") && (O !== 0 || E.type == "builtin" || !E.name.match(/^[./]/)))
              try {
                d.resolve && (E.path = d.resolve(E.name));
                const B = { module: d.module, path: E.path, name: E.name };
                b.history.push(B), l = d(E.name);
                break;
              } catch (B) {
                if (B.code == "MODULE_NOT_FOUND") {
                  if (B.message.indexOf(E.name) == -1)
                    return { error: B, found: E };
                  continue t;
                }
                return { error: B, found: E };
              }
        return { initfunc: l, module: d.module, require: E.name, path: E.path, found: E };
      }
      function _() {
        const d = i("{name:s, builtin:s|a?, prefix:s|a?, system:a?}", arguments), b = d.name, k = d.builtin ? Array.isArray(d.builtin) ? d.builtin : [d.builtin] : [], O = d.prefix ? Array.isArray(d.prefix) ? d.prefix : [d.prefix] : [], A = d.system || [], l = [];
        return b.match(/^[./]/) || k.forEach(function(E) {
          l.push({ type: "builtin", name: E + b }), O.forEach(function(M) {
            l.push({ type: "builtin", name: E + M + b });
          });
        }), O.forEach(function(E) {
          l.push({ type: "normal", name: E + b });
        }), A.indexOf(b) == -1 && l.push({ type: "normal", name: b }), l.push({ type: "normal", name: "./" + b }), O.forEach(function(E) {
          l.push({ type: "normal", name: "./" + E + b });
        }), l;
      }
      function g() {
        return { syntax_error: "Could not load plugin <%=name%> defined in <%=found_name%> due to syntax error: <%=err_msg%>. See STDERR for details.", not_found: "Could not load plugin <%=name%>; searched the following folder and file paths: <%=searchlist%>.", require_failed: "Could not load plugin <%=name%> defined in <%=found_name%> as a require call inside the plugin (or a module required by the plugin) failed: <%=err_msg%>.", no_name: "No name property found for plugin defined by Object <%=plugin%>.", no_init_function: "The init property is not a function for plugin <%=name%> defined by Object <%=plugin%>.", load_failed: "Could not load plugin <%=name%> defined in <%=found_name%> due to error: <%=err_msg%>.", invalid_option: "Plugin <%=name%>: option value is not valid: <%=err_msg%> in options <%=options%>" };
      }
      C.exports = o;
      const S = C.exports.intern = { make_system_modules: function() {
        return v.builtinModules;
      } };
    }, { eraro: 51, "lodash.defaultsdeep": 121, module: 45, nid: 131, norma: 133, path: 156 }], 232: [function(x, C, c) {
      (function(p) {
        (function() {
          function v(i, s) {
            if (n("noDeprecation"))
              return i;
            var r = !1;
            return function() {
              if (!r) {
                if (n("throwDeprecation"))
                  throw new Error(s);
                n("traceDeprecation") ? console.trace(s) : console.warn(s), r = !0;
              }
              return i.apply(this, arguments);
            };
          }
          function n(i) {
            try {
              if (!p.localStorage)
                return !1;
            } catch (r) {
              return !1;
            }
            var s = p.localStorage[i];
            return s != null && String(s).toLowerCase() === "true";
          }
          C.exports = v;
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, {}], 233: [function(x, C, c) {
      var p = x("for-each"), v = typeof Object.defineProperty == "function", n = [].__proto__ === Array.prototype;
      if (!v || !n)
        throw new TypeError("util.promisify requires a true ES5 environment, that also supports `__proto__`");
      var i = x("object.getownpropertydescriptors");
      if (typeof Promise != "function")
        throw new TypeError("`Promise` must be globally available for util.promisify to work.");
      var s = x("call-bind/callBound"), r = s("Array.prototype.slice"), o = s("Array.prototype.concat"), u = s("Array.prototype.forEach"), a = x("has-symbols")(), f = a ? Symbol.for("nodejs.util.promisify.custom") : null, y = a ? Symbol("customPromisifyArgs") : null;
      C.exports = function(T) {
        if (typeof T != "function") {
          var h = new TypeError('The "original" argument must be of type function');
          throw h.name = "TypeError [ERR_INVALID_ARG_TYPE]", h.code = "ERR_INVALID_ARG_TYPE", h;
        }
        if (a && T[f]) {
          var _ = T[f];
          if (typeof _ != "function")
            throw new TypeError("The [util.promisify.custom] property must be a function");
          return Object.defineProperty(_, f, { configurable: !0, enumerable: !1, value: _, writable: !1 }), _;
        }
        var g = T[y], S = function() {
          var b = r(arguments), k = this;
          return new Promise(function(O, A) {
            T.apply(k, o(b, function(l) {
              var E = arguments.length > 1 ? r(arguments, 1) : [];
              if (l)
                A(l);
              else if (g !== void 0 && E.length > 1) {
                var M = {};
                u(g, function(B, X) {
                  M[B] = E[X];
                }), O(M);
              } else
                O(E[0]);
            }));
          });
        };
        S.__proto__ = T.__proto__, Object.defineProperty(S, f, { configurable: !0, enumerable: !1, value: S, writable: !1 });
        var d = i(T);
        return p(d, function(b, k) {
          try {
            Object.defineProperty(S, b, k);
          } catch (O) {
          }
        }), S;
      }, C.exports.custom = f, C.exports.customPromisifyArgs = y;
    }, { "call-bind/callBound": 48, "for-each": 97, "has-symbols": 104, "object.getownpropertydescriptors": 141 }], 234: [function(x, C, c) {
      var p = x("util"), v = x("./implementation");
      C.exports = function() {
        return typeof p.promisify == "function" && p.promisify.custom === v.custom ? p.promisify : v;
      };
    }, { "./implementation": 233, util: 238 }], 235: [function(x, C, c) {
      var p = x("util"), v = x("./polyfill");
      C.exports = function() {
        var n = v();
        return n !== p.promisify && Object.defineProperty(p, "promisify", { configurable: !0, enumerable: !0, value: n, writable: !0 }), n;
      };
    }, { "./polyfill": 234, util: 238 }], 236: [function(x, C, c) {
      C.exports = function(p) {
        return p && typeof p == "object" && typeof p.copy == "function" && typeof p.fill == "function" && typeof p.readUInt8 == "function";
      };
    }, {}], 237: [function(x, C, c) {
      var p = x("is-arguments"), v = x("is-generator-function"), n = x("which-typed-array"), i = x("is-typed-array");
      function s(ft) {
        return ft.call.bind(ft);
      }
      var r = typeof BigInt != "undefined", o = typeof Symbol != "undefined", u = s(Object.prototype.toString), a = s(Number.prototype.valueOf), f = s(String.prototype.valueOf), y = s(Boolean.prototype.valueOf);
      if (r)
        var T = s(BigInt.prototype.valueOf);
      if (o)
        var h = s(Symbol.prototype.valueOf);
      function _(ft, Ot) {
        if (typeof ft != "object")
          return !1;
        try {
          return Ot(ft), !0;
        } catch (Wt) {
          return !1;
        }
      }
      function g(ft) {
        return typeof Promise != "undefined" && ft instanceof Promise || ft !== null && typeof ft == "object" && typeof ft.then == "function" && typeof ft.catch == "function";
      }
      function S(ft) {
        return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(ft) : i(ft) || pt(ft);
      }
      function d(ft) {
        return n(ft) === "Uint8Array";
      }
      function b(ft) {
        return n(ft) === "Uint8ClampedArray";
      }
      function k(ft) {
        return n(ft) === "Uint16Array";
      }
      function O(ft) {
        return n(ft) === "Uint32Array";
      }
      function A(ft) {
        return n(ft) === "Int8Array";
      }
      function l(ft) {
        return n(ft) === "Int16Array";
      }
      function E(ft) {
        return n(ft) === "Int32Array";
      }
      function M(ft) {
        return n(ft) === "Float32Array";
      }
      function B(ft) {
        return n(ft) === "Float64Array";
      }
      function X(ft) {
        return n(ft) === "BigInt64Array";
      }
      function K(ft) {
        return n(ft) === "BigUint64Array";
      }
      function D(ft) {
        return u(ft) === "[object Map]";
      }
      function j(ft) {
        return typeof Map != "undefined" && (D.working ? D(ft) : ft instanceof Map);
      }
      function Z(ft) {
        return u(ft) === "[object Set]";
      }
      function tt(ft) {
        return typeof Set != "undefined" && (Z.working ? Z(ft) : ft instanceof Set);
      }
      function nt(ft) {
        return u(ft) === "[object WeakMap]";
      }
      function ct(ft) {
        return typeof WeakMap != "undefined" && (nt.working ? nt(ft) : ft instanceof WeakMap);
      }
      function ut(ft) {
        return u(ft) === "[object WeakSet]";
      }
      function V(ft) {
        return ut(ft);
      }
      function ot(ft) {
        return u(ft) === "[object ArrayBuffer]";
      }
      function xt(ft) {
        return typeof ArrayBuffer != "undefined" && (ot.working ? ot(ft) : ft instanceof ArrayBuffer);
      }
      function Ut(ft) {
        return u(ft) === "[object DataView]";
      }
      function pt(ft) {
        return typeof DataView != "undefined" && (Ut.working ? Ut(ft) : ft instanceof DataView);
      }
      c.isArgumentsObject = p, c.isGeneratorFunction = v, c.isTypedArray = i, c.isPromise = g, c.isArrayBufferView = S, c.isUint8Array = d, c.isUint8ClampedArray = b, c.isUint16Array = k, c.isUint32Array = O, c.isInt8Array = A, c.isInt16Array = l, c.isInt32Array = E, c.isFloat32Array = M, c.isFloat64Array = B, c.isBigInt64Array = X, c.isBigUint64Array = K, D.working = typeof Map != "undefined" && D(/* @__PURE__ */ new Map()), c.isMap = j, Z.working = typeof Set != "undefined" && Z(/* @__PURE__ */ new Set()), c.isSet = tt, nt.working = typeof WeakMap != "undefined" && nt(/* @__PURE__ */ new WeakMap()), c.isWeakMap = ct, ut.working = typeof WeakSet != "undefined" && ut(/* @__PURE__ */ new WeakSet()), c.isWeakSet = V, ot.working = typeof ArrayBuffer != "undefined" && ot(new ArrayBuffer()), c.isArrayBuffer = xt, Ut.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && Ut(new DataView(new ArrayBuffer(1), 0, 1)), c.isDataView = pt;
      var at = typeof SharedArrayBuffer != "undefined" ? SharedArrayBuffer : void 0;
      function bt(ft) {
        return u(ft) === "[object SharedArrayBuffer]";
      }
      function Q(ft) {
        return at !== void 0 && (bt.working === void 0 && (bt.working = bt(new at())), bt.working ? bt(ft) : ft instanceof at);
      }
      function At(ft) {
        return u(ft) === "[object AsyncFunction]";
      }
      function Pt(ft) {
        return u(ft) === "[object Map Iterator]";
      }
      function q(ft) {
        return u(ft) === "[object Set Iterator]";
      }
      function G(ft) {
        return u(ft) === "[object Generator]";
      }
      function lt(ft) {
        return u(ft) === "[object WebAssembly.Module]";
      }
      function It(ft) {
        return _(ft, a);
      }
      function Ft(ft) {
        return _(ft, f);
      }
      function H(ft) {
        return _(ft, y);
      }
      function F(ft) {
        return r && _(ft, T);
      }
      function P(ft) {
        return o && _(ft, h);
      }
      function U(ft) {
        return It(ft) || Ft(ft) || H(ft) || F(ft) || P(ft);
      }
      function rt(ft) {
        return typeof Uint8Array != "undefined" && (xt(ft) || Q(ft));
      }
      c.isSharedArrayBuffer = Q, c.isAsyncFunction = At, c.isMapIterator = Pt, c.isSetIterator = q, c.isGeneratorObject = G, c.isWebAssemblyCompiledModule = lt, c.isNumberObject = It, c.isStringObject = Ft, c.isBooleanObject = H, c.isBigIntObject = F, c.isSymbolObject = P, c.isBoxedPrimitive = U, c.isAnyArrayBuffer = rt, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(ft) {
        Object.defineProperty(c, ft, { enumerable: !1, value: function() {
          throw new Error(ft + " is not supported in userland");
        } });
      });
    }, { "is-arguments": 111, "is-generator-function": 114, "is-typed-array": 118, "which-typed-array": 239 }], 238: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = Object.getOwnPropertyDescriptors || function(pt) {
            for (var at = Object.keys(pt), bt = {}, Q = 0; Q < at.length; Q++)
              bt[at[Q]] = Object.getOwnPropertyDescriptor(pt, at[Q]);
            return bt;
          }, n = /%[sdj%]/g;
          c.format = function(pt) {
            if (!l(pt)) {
              for (var at = [], bt = 0; bt < arguments.length; bt++)
                at.push(o(arguments[bt]));
              return at.join(" ");
            }
            bt = 1;
            for (var Q = arguments, At = Q.length, Pt = String(pt).replace(n, function(G) {
              if (G === "%%")
                return "%";
              if (bt >= At)
                return G;
              switch (G) {
                case "%s":
                  return String(Q[bt++]);
                case "%d":
                  return Number(Q[bt++]);
                case "%j":
                  try {
                    return JSON.stringify(Q[bt++]);
                  } catch (lt) {
                    return "[Circular]";
                  }
                default:
                  return G;
              }
            }), q = Q[bt]; bt < At; q = Q[++bt])
              k(q) || !X(q) ? Pt += " " + q : Pt += " " + o(q);
            return Pt;
          }, c.deprecate = function(pt, at) {
            if (typeof p != "undefined" && p.noDeprecation === !0)
              return pt;
            if (typeof p == "undefined")
              return function() {
                return c.deprecate(pt, at).apply(this, arguments);
              };
            var bt = !1;
            return function() {
              if (!bt) {
                if (p.throwDeprecation)
                  throw new Error(at);
                p.traceDeprecation ? console.trace(at) : console.error(at), bt = !0;
              }
              return pt.apply(this, arguments);
            };
          };
          var i = {}, s = /^$/;
          if (p.env.NODE_DEBUG) {
            var r = p.env.NODE_DEBUG;
            r = r.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), s = new RegExp("^" + r + "$", "i");
          }
          function o(pt, at) {
            var bt = { seen: [], stylize: a };
            return arguments.length >= 3 && (bt.depth = arguments[2]), arguments.length >= 4 && (bt.colors = arguments[3]), b(at) ? bt.showHidden = at : at && c._extend(bt, at), M(bt.showHidden) && (bt.showHidden = !1), M(bt.depth) && (bt.depth = 2), M(bt.colors) && (bt.colors = !1), M(bt.customInspect) && (bt.customInspect = !0), bt.colors && (bt.stylize = u), y(bt, pt, bt.depth);
          }
          function u(pt, at) {
            var bt = o.styles[at];
            return bt ? "\x1B[" + o.colors[bt][0] + "m" + pt + "\x1B[" + o.colors[bt][1] + "m" : pt;
          }
          function a(pt, at) {
            return pt;
          }
          function f(pt) {
            var at = {};
            return pt.forEach(function(bt, Q) {
              at[bt] = !0;
            }), at;
          }
          function y(pt, at, bt) {
            if (pt.customInspect && at && j(at.inspect) && at.inspect !== c.inspect && (!at.constructor || at.constructor.prototype !== at)) {
              var Q = at.inspect(bt, pt);
              return l(Q) || (Q = y(pt, Q, bt)), Q;
            }
            var At = T(pt, at);
            if (At)
              return At;
            var Pt = Object.keys(at), q = f(Pt);
            if (pt.showHidden && (Pt = Object.getOwnPropertyNames(at)), D(at) && (Pt.indexOf("message") >= 0 || Pt.indexOf("description") >= 0))
              return h(at);
            if (Pt.length === 0) {
              if (j(at)) {
                var G = at.name ? ": " + at.name : "";
                return pt.stylize("[Function" + G + "]", "special");
              }
              if (B(at))
                return pt.stylize(RegExp.prototype.toString.call(at), "regexp");
              if (K(at))
                return pt.stylize(Date.prototype.toString.call(at), "date");
              if (D(at))
                return h(at);
            }
            var lt, It = "", Ft = !1, H = ["{", "}"];
            return d(at) && (Ft = !0, H = ["[", "]"]), j(at) && (It = " [Function" + (at.name ? ": " + at.name : "") + "]"), B(at) && (It = " " + RegExp.prototype.toString.call(at)), K(at) && (It = " " + Date.prototype.toUTCString.call(at)), D(at) && (It = " " + h(at)), Pt.length !== 0 || Ft && at.length != 0 ? bt < 0 ? B(at) ? pt.stylize(RegExp.prototype.toString.call(at), "regexp") : pt.stylize("[Object]", "special") : (pt.seen.push(at), lt = Ft ? _(pt, at, bt, q, Pt) : Pt.map(function(F) {
              return g(pt, at, bt, q, F, Ft);
            }), pt.seen.pop(), S(lt, It, H)) : H[0] + It + H[1];
          }
          function T(pt, at) {
            if (M(at))
              return pt.stylize("undefined", "undefined");
            if (l(at)) {
              var bt = "'" + JSON.stringify(at).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return pt.stylize(bt, "string");
            }
            return A(at) ? pt.stylize("" + at, "number") : b(at) ? pt.stylize("" + at, "boolean") : k(at) ? pt.stylize("null", "null") : void 0;
          }
          function h(pt) {
            return "[" + Error.prototype.toString.call(pt) + "]";
          }
          function _(pt, at, bt, Q, At) {
            for (var Pt = [], q = 0, G = at.length; q < G; ++q)
              V(at, String(q)) ? Pt.push(g(pt, at, bt, Q, String(q), !0)) : Pt.push("");
            return At.forEach(function(lt) {
              lt.match(/^\d+$/) || Pt.push(g(pt, at, bt, Q, lt, !0));
            }), Pt;
          }
          function g(pt, at, bt, Q, At, Pt) {
            var q, G, lt;
            if ((lt = Object.getOwnPropertyDescriptor(at, At) || { value: at[At] }).get ? G = lt.set ? pt.stylize("[Getter/Setter]", "special") : pt.stylize("[Getter]", "special") : lt.set && (G = pt.stylize("[Setter]", "special")), V(Q, At) || (q = "[" + At + "]"), G || (pt.seen.indexOf(lt.value) < 0 ? (G = k(bt) ? y(pt, lt.value, null) : y(pt, lt.value, bt - 1)).indexOf(`
`) > -1 && (G = Pt ? G.split(`
`).map(function(It) {
              return "  " + It;
            }).join(`
`).substr(2) : `
` + G.split(`
`).map(function(It) {
              return "   " + It;
            }).join(`
`)) : G = pt.stylize("[Circular]", "special")), M(q)) {
              if (Pt && At.match(/^\d+$/))
                return G;
              (q = JSON.stringify("" + At)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (q = q.substr(1, q.length - 2), q = pt.stylize(q, "name")) : (q = q.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), q = pt.stylize(q, "string"));
            }
            return q + ": " + G;
          }
          function S(pt, at, bt) {
            return pt.reduce(function(Q, At) {
              return At.indexOf(`
`) >= 0, Q + At.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0) > 60 ? bt[0] + (at === "" ? "" : at + `
 `) + " " + pt.join(`,
  `) + " " + bt[1] : bt[0] + at + " " + pt.join(", ") + " " + bt[1];
          }
          function d(pt) {
            return Array.isArray(pt);
          }
          function b(pt) {
            return typeof pt == "boolean";
          }
          function k(pt) {
            return pt === null;
          }
          function O(pt) {
            return pt == null;
          }
          function A(pt) {
            return typeof pt == "number";
          }
          function l(pt) {
            return typeof pt == "string";
          }
          function E(pt) {
            return typeof pt == "symbol";
          }
          function M(pt) {
            return pt === void 0;
          }
          function B(pt) {
            return X(pt) && tt(pt) === "[object RegExp]";
          }
          function X(pt) {
            return typeof pt == "object" && pt !== null;
          }
          function K(pt) {
            return X(pt) && tt(pt) === "[object Date]";
          }
          function D(pt) {
            return X(pt) && (tt(pt) === "[object Error]" || pt instanceof Error);
          }
          function j(pt) {
            return typeof pt == "function";
          }
          function Z(pt) {
            return pt === null || typeof pt == "boolean" || typeof pt == "number" || typeof pt == "string" || typeof pt == "symbol" || pt === void 0;
          }
          function tt(pt) {
            return Object.prototype.toString.call(pt);
          }
          function nt(pt) {
            return pt < 10 ? "0" + pt.toString(10) : pt.toString(10);
          }
          c.debuglog = function(pt) {
            if (pt = pt.toUpperCase(), !i[pt])
              if (s.test(pt)) {
                var at = p.pid;
                i[pt] = function() {
                  var bt = c.format.apply(c, arguments);
                  console.error("%s %d: %s", pt, at, bt);
                };
              } else
                i[pt] = function() {
                };
            return i[pt];
          }, c.inspect = o, o.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, o.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, c.types = x("./support/types"), c.isArray = d, c.isBoolean = b, c.isNull = k, c.isNullOrUndefined = O, c.isNumber = A, c.isString = l, c.isSymbol = E, c.isUndefined = M, c.isRegExp = B, c.types.isRegExp = B, c.isObject = X, c.isDate = K, c.types.isDate = K, c.isError = D, c.types.isNativeError = D, c.isFunction = j, c.isPrimitive = Z, c.isBuffer = x("./support/isBuffer");
          var ct = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          function ut() {
            var pt = /* @__PURE__ */ new Date(), at = [nt(pt.getHours()), nt(pt.getMinutes()), nt(pt.getSeconds())].join(":");
            return [pt.getDate(), ct[pt.getMonth()], at].join(" ");
          }
          function V(pt, at) {
            return Object.prototype.hasOwnProperty.call(pt, at);
          }
          c.log = function() {
            console.log("%s - %s", ut(), c.format.apply(c, arguments));
          }, c.inherits = x("inherits"), c._extend = function(pt, at) {
            if (!at || !X(at))
              return pt;
            for (var bt = Object.keys(at), Q = bt.length; Q--; )
              pt[bt[Q]] = at[bt[Q]];
            return pt;
          };
          var ot = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : void 0;
          function xt(pt, at) {
            if (!pt) {
              var bt = new Error("Promise was rejected with a falsy value");
              bt.reason = pt, pt = bt;
            }
            return at(pt);
          }
          function Ut(pt) {
            if (typeof pt != "function")
              throw new TypeError('The "original" argument must be of type Function');
            function at() {
              for (var bt = [], Q = 0; Q < arguments.length; Q++)
                bt.push(arguments[Q]);
              var At = bt.pop();
              if (typeof At != "function")
                throw new TypeError("The last argument must be of type Function");
              var Pt = this, q = function() {
                return At.apply(Pt, arguments);
              };
              pt.apply(this, bt).then(function(G) {
                p.nextTick(q.bind(null, null, G));
              }, function(G) {
                p.nextTick(xt.bind(null, G, q));
              });
            }
            return Object.setPrototypeOf(at, Object.getPrototypeOf(pt)), Object.defineProperties(at, v(pt)), at;
          }
          c.promisify = function(pt) {
            if (typeof pt != "function")
              throw new TypeError('The "original" argument must be of type Function');
            if (ot && pt[ot]) {
              var at;
              if (typeof (at = pt[ot]) != "function")
                throw new TypeError('The "util.promisify.custom" argument must be of type Function');
              return Object.defineProperty(at, ot, { value: at, enumerable: !1, writable: !1, configurable: !0 }), at;
            }
            function at() {
              for (var bt, Q, At = new Promise(function(G, lt) {
                bt = G, Q = lt;
              }), Pt = [], q = 0; q < arguments.length; q++)
                Pt.push(arguments[q]);
              Pt.push(function(G, lt) {
                G ? Q(G) : bt(lt);
              });
              try {
                pt.apply(this, Pt);
              } catch (G) {
                Q(G);
              }
              return At;
            }
            return Object.setPrototypeOf(at, Object.getPrototypeOf(pt)), ot && Object.defineProperty(at, ot, { value: at, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(at, v(pt));
          }, c.promisify.custom = ot, c.callbackify = Ut;
        }).call(this);
      }).call(this, x("_process"));
    }, { "./support/isBuffer": 236, "./support/types": 237, _process: 158, inherits: 110 }], 239: [function(x, C, c) {
      (function(p) {
        (function() {
          var v = x("for-each"), n = x("available-typed-arrays"), i = x("call-bind/callBound"), s = i("Object.prototype.toString"), r = x("has-tostringtag/shams")(), o = typeof globalThis == "undefined" ? p : globalThis, u = n(), a = i("String.prototype.slice"), f = {}, y = x("es-abstract/helpers/getOwnPropertyDescriptor"), T = Object.getPrototypeOf;
          r && y && T && v(u, function(g) {
            if (typeof o[g] == "function") {
              var S = new o[g]();
              if (Symbol.toStringTag in S) {
                var d = T(S), b = y(d, Symbol.toStringTag);
                if (!b) {
                  var k = T(d);
                  b = y(k, Symbol.toStringTag);
                }
                f[g] = b.get;
              }
            }
          });
          var h = function(g) {
            var S = !1;
            return v(f, function(d, b) {
              if (!S)
                try {
                  var k = d.call(g);
                  k === b && (S = k);
                } catch (O) {
                }
            }), S;
          }, _ = x("is-typed-array");
          C.exports = function(g) {
            return !!_(g) && (r && Symbol.toStringTag in g ? h(g) : a(s(g), 8, -1));
          };
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { "available-typed-arrays": 40, "call-bind/callBound": 48, "es-abstract/helpers/getOwnPropertyDescriptor": 84, "for-each": 97, "has-tostringtag/shams": 106, "is-typed-array": 118 }], 240: [function(x, C, c) {
      C.exports = v;
      var p = Object.prototype.hasOwnProperty;
      function v() {
        for (var n = {}, i = 0; i < arguments.length; i++) {
          var s = arguments[i];
          for (var r in s)
            p.call(s, r) && (n[r] = s[r]);
        }
        return n;
      }
    }, {}], 241: [function(x, C, c) {
      (function(p) {
        (function() {
          x("util.promisify/shim")();
          let v = x("timers"), n = x("seneca"), i = x("seneca-promisify");
          p.setImmediate = p.setImmediate || v.setImmediate;
          let s = function(r, o) {
            (r = r || {}).legacy = r.legacy || !1;
            let u = n(r, o);
            function a(f) {
              return sn(this, null, function* () {
                let y = Object.keys(f);
                for (let T of y) {
                  let h = f[T];
                  f[T] = typeof h == "function" ? yield h() : h;
                }
                return f;
              });
            }
            return u.use(i), u.use({ name: "browser", init: function(f) {
              f.endpoint = f.endpoint || "/seneca", f.fetch = f.fetch || {}, f.headers = f.headers || {}, this.add("role:transport,hook:client,type:browser", function(h, _) {
                let g = this;
                _({ send: function(S, d, b) {
                  return sn(this, null, function* () {
                    let k = kn(Ge({ method: "post" }, f.fetch), { mode: "cors", cache: "no-cache", headers: yield a(Ge(Ge({ "Content-Type": "application/json" }, f.fetch.headers), f.headers)), body: T.stringifyJSON(T.externalize_msg(g, S, b)) }), O = f.endpoint;
                    if (typeof O == "function")
                      O = O.call(g, S, k, b);
                    else if (y) {
                      let A = y.find(S);
                      A && (O = A.endpoint != null ? A.endpoint : (A.prefix == null ? "" : typeof A.prefix == "function" ? A.prefix.call(g, S, k, b) : A.prefix) + O + (A.suffix == null ? "" : typeof A.suffix == "function" ? A.suffix.call(g, S, k, b) : A.suffix));
                    }
                    fetch(O, k).then(function(A) {
                      return A.ok ? A.json() : d(new Error(JSON.stringify(A)));
                    }).then(function(A) {
                      Array.isArray(A) && (A.meta$ = { id: "ID" });
                      let l = T.internalize_reply(g, A);
                      d(l.err, l.out, l.meta);
                    });
                  });
                } });
              });
              let y, T = this.export("transport/utils");
              typeof f.pathmap == "object" && (y = u.util.Patrun({ gex: !0 }), Object.entries(f.pathmap).forEach((h) => {
                y.add(u.util.Jsonic(h[0]), h[1]);
              }), f.debug && console.log("SENECA", "pathmap", "" + y));
            } }), u;
          };
          s.util = n.util, s.valid = n.valid, s.prototype = n.prototype, s.browser = { version: "4.0.1" }, C.exports = s;
        }).call(this);
      }).call(this, typeof commonjsGlobal != "undefined" ? commonjsGlobal : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
    }, { seneca: 190, "seneca-promisify": 165, timers: 228, "util.promisify/shim": 235 }] }, {}, [241])(241);
  });
})(senecaBrowser);
const Seneca = /* @__PURE__ */ getDefaultExportFromCjs(senecaBrowserExports);
var entityExports = {}, entity = {
  get exports() {
    return entityExports;
  },
  set exports(x) {
    entityExports = x;
  }
}, make_entity = {};
Object.defineProperty(make_entity, "__esModule", { value: !0 });
make_entity.Entity = make_entity.MakeEntity = void 0;
const proto = Object.getPrototypeOf, toString_map = {
  // '': make_toString(),
}, NO_ENTITY = null, NO_ERROR = null;
function entargs(x, C) {
  return C.role = "entity", C.ent = x, this.canon.name !== null && (C.name = this.canon.name), this.canon.base !== null && (C.base = this.canon.base), this.canon.zone !== null && (C.zone = this.canon.zone), C;
}
class Entity {
  constructor(C, c) {
    this.private$ = {
      canon: null,
      promise: !1,
      get_instance: () => null,
      entargs
    };
    const p = this.private$;
    p.get_instance = function() {
      return c;
    }, p.canon = C, p.entargs = entargs, this.private$ = this.private$, this.entity$ = this.canon$();
  }
  // Properties without '$' suffix are persisted
  // id property is special: created if not present when saving
  //   lack of id indicates new data record to create
  //   to set id of a new record, use id$
  // func$ functions provide persistence operations
  // args: (<zone>,<base>,<name>,<props>)
  // can be partially specified:
  // make$(name)
  // make$(base,name)
  // make$(zone,base,name)
  // make$(zone,base,null)
  // make$(zone,null,null)
  // props can specify zone$,base$,name$, but args override if present
  // escaped names: foo_$ is converted to foo
  make$(...C) {
    const c = this;
    let p = C[0], v = C[C.length - 1], n = c.private$.promise;
    typeof v == "boolean" && (n = v, C = C.slice(0, C.length - 1));
    let i = c.private$.get_instance();
    if (p && p.seneca && (i = p, p = C[1], C = C.slice(1)), p && p.entity$ && typeof p.canon$ == "function")
      return p;
    const s = C[C.length - 1];
    let r = {};
    for (s && typeof s == "object" && (C.pop(), r = Ge({}, s)); C.length < 3; )
      C.unshift(null);
    let o;
    if (typeof r.entity$ == "string")
      o = parsecanon(r.entity$);
    else if (r.entity$ && typeof r.entity$ == "object")
      o = {}, o.zone = r.entity$.zone, o.base = r.entity$.base, o.name = r.entity$.name;
    else {
      let h = C.pop();
      h = h == null ? r.name$ : h, o = parsecanon(h);
    }
    const u = o.name;
    let a = C.pop();
    a = a == null ? o.base : a, a = a == null ? r.base$ : a;
    let f = C.pop();
    f = f == null ? o.zone : f, f = f == null ? r.zone$ : f;
    const y = {};
    y.name = u == null ? c.private$.canon.name : u, y.base = a == null ? c.private$.canon.base : a, y.zone = f == null ? c.private$.canon.zone : f;
    const T = MakeEntity(y, i, {
      // const entity: Entity = MakeEntity(new_canon, self.private$.get_instance(), {
      promise: n
    });
    for (const h in r)
      Object.prototype.hasOwnProperty.call(r, h) && (~h.indexOf("$") ? h.length > 2 && h.slice(-2) === "_$" && (T[h.slice(0, -2)] = r[h]) : T[h] = r[h]);
    return Object.prototype.hasOwnProperty.call(r, "id$") && (T.id$ = r.id$), c.log$ && c.log$("make", T.canon$({ string: !0 }), T), T;
  }
  /** Save the entity.
   *  param {object} [data] - Subset of entity field values.
   *  param {callback~save$} done - Callback function providing saved entity.
   */
  save$(C, c) {
    const p = this, v = p.private$.get_instance();
    let n = { cmd: "save", q: {} }, i = prepareCmd(p, C, n, c);
    n = p.private$.entargs(p, n);
    const s = p.private$.promise && !i;
    return s ? entityPromise(v, n) : (v.act(n, i), s ? NO_ENTITY : p);
  }
  /** Callback for Entity.save$.
   *  @callback callback~save$
   *  @param {error} error - Error object, if any.
   *  @param {Entity} entity - Saved Entity object containing updated data fields (in particular, `id`, if auto-generated).
   */
  // provide native database driver
  native$(C) {
    const c = this, p = c.private$.get_instance(), v = c.private$.promise;
    let n = { cmd: "native" }, i = prepareCmd(c, void 0, n, C);
    return n = c.private$.entargs(c, n), v && !C ? entityPromise(p, n) : (p.act(n, i), v ? NO_ENTITY : c);
  }
  // load one
  // TODO: qin can be an entity, in which case, grab the id and reload
  // qin omitted => reload self
  /** Load the entity.
   *  param {object|string|number} [query] - Either a entity id, or a query object with field values that must match.
   *  param {callback~load$} done - Callback function providing loaded entity, if found.
   */
  load$(C, c) {
    const p = this;
    typeof C == "function" && (c = C, C = null);
    const v = p.private$.get_instance(), n = normalize_query(C, p);
    let i = { cmd: "load", q: n, qent: p }, s = prepareCmd(p, void 0, i, c);
    i = p.private$.entargs(p, i);
    const r = p.private$.promise && !s;
    return emptyQuery(n) ? r ? NO_ENTITY : (c && c.call(v, NO_ERROR, NO_ENTITY), p) : r ? entityPromise(v, i) : (v.act(i, s), r ? NO_ENTITY : p);
  }
  /** Callback for Entity.load$.
   *  @callback callback~load$
   *  @param {error} error - Error object, if any.
   *  @param {Entity} entity - Matching `Entity` object, if found.
   */
  // TODO: need an update$ - does an atomic upsert
  // list zero or more
  // qin is optional, if omitted, list all
  /** Load the entity.
   *  param {object|string|number} [query] - A query object with field values that must match, can be empty.
   *  param {callback~list$} done - Callback function providing list of matching `Entity` objects, if any.
   */
  // TODO: refactor list, remove, etc, as per save, load
  list$(C, c) {
    const p = this;
    typeof C == "function" && (c = C, C = null);
    const v = p.private$.get_instance();
    let i = { cmd: "list", q: normalize_query(C, p), qent: p };
    const s = prepareCmd(p, void 0, i, c);
    i = p.private$.entargs(p, i);
    const r = p.private$.promise && !s;
    return r ? entityPromise(v, i) : (v.act(i, s), r ? NO_ENTITY : p);
  }
  /** Callback for Entity.list$.
   *  @callback callback~list$
   *  @param {error} error - Error object, if any.
   *  @param {Entity} entity - Array of `Entity` objects matching query.
   */
  // remove one or more
  // TODO: make qin optional, in which case, use id
  /** Remove the `Entity`.
   *  param {object|string|number} [query] - Either a entity id, or a query object with field values that must match.
   *  param {callback~remove$} done - Callback function to confirm removal.
   */
  remove$(C, c) {
    const p = this;
    typeof C == "function" && (c = C, C = null);
    const v = p.private$.get_instance(), n = normalize_query(C, p);
    let i = p.private$.entargs(p, { cmd: "remove", q: n, qent: p }), s = prepareCmd(p, void 0, i, c);
    const r = p.private$.promise && !s;
    return emptyQuery(n) ? r ? NO_ENTITY : (s && s.call(v, NO_ERROR, NO_ENTITY), p) : r ? entityPromise(v, i) : (v.act(i, s), r ? NO_ENTITY : p);
  }
  // DEPRECATE: legacy
  delete$(C, c) {
    return this.remove$(C, c);
  }
  /** Callback for Entity.remove$.
   *  @callback callback~remove$
   *  @param {error} error - Error object, if any.
   */
  fields$() {
    const C = this, c = [];
    for (const p in C)
      Object.prototype.hasOwnProperty.call(C, p) && typeof C[p] != "function" && p.charAt(p.length - 1) !== "$" && c.push(p);
    return c;
  }
  // TODO: remove
  close$(C) {
    const c = this, p = c.private$.get_instance();
    let v = c.private$.entargs(c, { cmd: "close" }), n = prepareCmd(c, void 0, v, C);
    const i = c.private$.promise && !n;
    return c.log$ && c.log$("close"), i ? p.post(v) : (p.act(v, n), c);
  }
  is$(C) {
    const c = this, p = C ? C.entity$ ? C.canon$({ object: !0 }) : parsecanon(C) : null;
    if (!p)
      return !1;
    let v = c.canon$({ object: !0 }), n = Object.keys(v), i = n.length === Object.keys(p).length;
    if (i)
      for (let s of n)
        i = i && v[s] === p[s];
    return i;
  }
  canon$(C) {
    const c = this, p = c.private$.canon;
    if (C)
      if (C.isa) {
        const v = parsecanon(C.isa);
        return v.zone == p.zone && v.base == p.base && v.name == p.name;
      } else {
        if (C.parse)
          return parsecanon(C.parse);
        C.change && (p.zone = C.change.zone == null ? p.zone : C.change.zone, p.base = C.change.base == null ? p.base : C.change.base, p.name = C.change.name == null ? p.name : C.change.name, C.zone == null && delete p.zone, C.base == null && delete p.base, C.name == null && delete p.name, c.entity$ = c.canon$());
      }
    return C == null || C.string || C.string$ ? (
      // ? [
      //   (opt && opt.string$ ? '$' : '') +
      //   (null == canon.zone ? '-' : canon.zone),
      //   null == canon.base ? '-' : canon.base,
      //   null == canon.name ? '-' : canon.name,
      // ].join('/') // TODO: make joiner an option
      (C && C.string$ ? "$" : "") + canonstr(p)
    ) : C.array ? [p.zone, p.base, p.name] : C.array$ ? [p.zone, p.base, p.name] : C.object ? { zone: p.zone, base: p.base, name: p.name } : C.object$ ? { zone$: p.zone, base$: p.base, name$: p.name } : [p.zone, p.base, p.name];
  }
  // data = object, or true|undef = include $, false = exclude $
  data$(C, c) {
    const p = this;
    let v;
    if (C && typeof C == "object") {
      for (const n in C)
        n.charAt(0) !== "$" && n.charAt(n.length - 1) !== "$" && (v = C[n], v && typeof v == "object" && v.entity$ ? p[n] = v.id : p[n] = v);
      return C.id$ != null && (p.id$ = C.id$), C.merge$ != null && (p.merge$ = C.merge$), C.custom$ != null && p.custom$(C.custom$), p;
    } else {
      const n = C == null ? !0 : !!C;
      if (C = {}, n) {
        c = c || "object";
        let s = {};
        s[c] = !0, C.entity$ = p.canon$(s), 0 < Object.keys(p.custom$).length && (C.custom$ = p.private$.get_instance().util.deep(p.custom$));
      }
      const i = p.fields$();
      for (let s = 0; s < i.length; s++)
        ~i[s].indexOf("$") || (v = p[i[s]], v && typeof v == "object" && v.entity$ ? C[i[s]] = v.id : v !== void 0 && (C[i[s]] = v));
      return C;
    }
  }
  clone$() {
    const C = this;
    let c = this.private$.get_instance().util.deep, p = C.make$(c({}, C.data$()));
    return 0 < Object.keys(C.custom$).length && p.custom$(C.custom$), p;
  }
  custom$(C) {
    return {};
  }
}
make_entity.Entity = Entity;
function entityPromise(x, C) {
  var c;
  let p = ((c = C.q) === null || c === void 0 ? void 0 : c.meta$) === !0;
  return new Promise((v, n) => {
    x.act(C, (i, s, r) => {
      i ? n((p && (i.meta$ = r), i)) : v((p && ((s != null && s.entity$ ? proto(s) : s || (s = { entity$: null })).meta$ = r), s));
    });
  });
}
function prepareCmd(x, C, c, p) {
  return typeof C == "function" ? p = C : C && typeof C == "object" && (x.data$(C), c.q = C), p == null ? void 0 : x.done$ ? x.done$(p) : p;
}
function emptyQuery(x) {
  return x == null || Object.keys(x).length === 0;
}
function normalize_query(x, C) {
  let c = x;
  if ((x == null || typeof x == "function") && C.id != null ? c = { id: C.id } : typeof x == "string" || typeof x == "number" ? c = x === "" ? null : { id: x } : typeof x == "function" && (c = null), c != null)
    for (let p in c)
      c[p] === void 0 && delete c[p];
  return c;
}
function parsecanon(x) {
  let C = {};
  if (Array.isArray(x))
    return {
      zone: x[0],
      base: x[1],
      name: x[2]
    };
  if (x && typeof x == "object" && typeof x != "function")
    return x;
  if (typeof x != "string")
    return C;
  const c = /\$?((\w+|-)\/)?((\w+|-)\/)?(\w+|-)/.exec(x);
  if (c) {
    const p = c[4] == null ? 4 : 2, v = c[4] == null ? 2 : 4;
    C.zone = c[p] === "-" ? void 0 : c[p], C.base = c[v] === "-" ? void 0 : c[v], C.name = c[5] === "-" ? void 0 : c[5];
  } else
    throw new Error(`Invalid entity canon: ${x}; expected format: zone/base/name.`);
  return C;
}
function canonstr(x) {
  return x = x || { name: "" }, [
    x.zone == null || x.zone === "" ? "-" : x.zone,
    x.base == null || x.base === "" ? "-" : x.base,
    x.name == null || x.name === "" ? "-" : x.name
  ].join("/");
}
function handle_options(x, C) {
  var c;
  return x = x || /* @__PURE__ */ Object.create(null), C.util.Jsonic, x.hide && Object.keys(x.hide).forEach((p) => {
    const v = x.hide[p], n = parsecanon(v), i = [
      n.zone == null ? "-" : n.zone,
      n.base == null ? "-" : n.base,
      n.name == null ? "-" : n.name
    ].join("/");
    toString_map[i] = make_toString(i, p, x);
  }), ((c = x.meta) === null || c === void 0 ? void 0 : c.provide) === !1 && (Entity.prototype.done$ = (p) => p == null ? void 0 : function(v, n) {
    p.call(this, v, n);
  }), x;
}
function make_toString(x, C, c, p) {
  c = c || { jsonic: {} };
  let v = [];
  return Array.isArray(C) ? v.concat(C) : C && typeof C == "object" && Object.keys(C).forEach((n) => {
    v.push(n);
  }), v.push("id"), function() {
    return [
      "$",
      x || this.canon$({ string: !0 }),
      ";id=",
      this.id,
      ";",
      jsonic_stringify(this, {
        omit: v,
        depth: c.jsonic.depth,
        maxitems: c.jsonic.maxitems,
        maxchars: c.jsonic.maxchars
      })
    ].join("");
  };
}
function MakeEntity(x, C, c) {
  c = handle_options(c, C);
  const p = C.util.deep, v = new Entity(x, C);
  let n = v.canon$({ string: !0 }), i = (toString_map[n] || toString_map[""] || (toString_map[""] = make_toString(void 0, void 0, void 0, C.util.Jsonic))).bind(v), s = function(o) {
    return o != null && (typeof o == "object" || typeof o == "function") && Object.assign(this.custom$, p(o)), v;
  }, r = Object.create(Object.getPrototypeOf(v));
  return r.toString = i, r.custom$ = s, r.private$ = v.private$, r.private$.promise = !!c.promise, Object.setPrototypeOf(v, r), delete v.private$, v;
}
make_entity.MakeEntity = MakeEntity;
MakeEntity.parsecanon = parsecanon;
MakeEntity.canonstr = canonstr;
function jsonic_strify(x, C, c) {
  if (c++, x == null)
    return "null";
  var p = Object.prototype.toString.call(x).charAt(8);
  if (p === "F" && !C.showfunc)
    return null;
  if (C.custom) {
    if (x.hasOwnProperty("toString"))
      return x.toString();
    if (x.hasOwnProperty("inspect"))
      return x.inspect();
  }
  var v, n = 0, i, s;
  if (p === "N")
    return isNaN(x) ? "null" : x.toString();
  if (p === "O") {
    if (v = [], c <= C.depth) {
      i = 0;
      for (let f in x) {
        if (i >= C.maxitems)
          break;
        var r = !0;
        for (s = 0; s < C.exclude.length && r; s++)
          r = !~f.indexOf(C.exclude[s]);
        r = r && !C.omit[f];
        var o = jsonic_strify(x[f], C, c);
        if (o != null && r) {
          var u = f.match(/^[a-zA-Z0-9_$]+$/) ? f : JSON.stringify(f);
          v.push(u + ":" + o), i++;
        }
      }
    }
    return "{" + v.join(",") + "}";
  } else if (p === "A") {
    if (v = [], c <= C.depth)
      for (; n < x.length && n < C.maxitems; n++) {
        var o = jsonic_strify(x[n], C, c);
        o != null && v.push(o);
      }
    return "[" + v.join(",") + "]";
  } else {
    var a = x.toString();
    return (~` "'\r
	,}]`.indexOf(a[0]) || !~a.match(/,}]/) || ~` \r
	`.indexOf(a[a.length - 1])) && (a = "'" + a.replace(/'/g, "\\'") + "'"), a;
  }
}
function jsonic_stringify(x, C) {
  try {
    var C = C || {}, c = {};
    c.showfunc = C.showfunc || C.f || !1, c.custom = C.custom || C.c || !1, c.depth = C.depth || C.d || 3, c.maxitems = C.maxitems || C.mi || 11, c.maxchars = C.maxchars || C.mc || 111, c.exclude = C.exclude || C.x || ["$"];
    var p = C.omit || C.o || [];
    c.omit = {};
    for (var v = 0; v < p.length; v++)
      c.omit[p[v]] = !0;
    var n = jsonic_strify(x, c, 0);
    return n = n == null ? "" : n.substring(0, c.maxchars), n;
  } catch (i) {
    return "ERROR: jsonic.stringify: " + i + " input was: " + JSON.stringify(x);
  }
}
var store = {};
Object.defineProperty(store, "__esModule", { value: !0 });
store.Store = store.Intern = void 0;
const allcmds = ["save", "load", "list", "remove", "close", "native"];
function Store() {
  const x = {};
  function C(p) {
    return x[p] = (x[p] || 0) + 1, x[p];
  }
  return {
    cmds: allcmds.slice(0),
    // opts.map = { canon: [cmds] }
    // canon is in string format zone/base/name, with empty or - indicating undefined
    init: function(p, v, n, i) {
      const s = [];
      if (v.map)
        for (const a in v.map) {
          let f = v.map[a];
          f === "*" && (f = allcmds), s.push({ canon: a, cmds: f });
        }
      else
        s.push({ canon: "-/-/-", cmds: allcmds });
      const r = p.fixedargs && p.fixedargs.plugin$ && p.fixedargs.plugin$.tag, o = r == null || r === "-" ? C(n.name) : r, u = [n.name, o];
      for (let a = 0; a < s.length; a++) {
        const f = s[a];
        u.push(f.canon);
        let y, T, h, _ = /^(\w*|-)\/(\w*|-)\/(\w*|-)$/.exec(f.canon);
        _ ? (y = _[1], T = _[2], h = _[3]) : (_ = /^(\w*|-)\/(\w*|-)$/.exec(f.canon)) ? (T = _[1], h = _[2]) : (_ = /^(\w*|-)$/.exec(f.canon)) && (h = _[1]), y = y === "-" ? void 0 : y, T = T === "-" ? void 0 : T, h = h === "-" ? void 0 : h;
        const g = {};
        h !== void 0 && (g.name = h), T !== void 0 && (g.base = T), y !== void 0 && (g.zone = y), f.cmds.forEach(function(S) {
          const d = Object.assign({ role: "entity", cmd: S }, g), b = n[S];
          let k = b;
          if (k == null)
            return p.die("store_cmd_missing", {
              cmd: S,
              store: u
            });
          k = Intern.reify_entity_wrap(k, S, y, T, h);
          for (const O in b)
            k[O] = b[O];
          S !== "close" ? p.add(d, k) : S === "close" && p.add("role:seneca,cmd:close", function(O, A) {
            const l = this;
            if (!n.closed$)
              k.call(l, O, function(E) {
                E && l.log.error("close-error", O, E), n.closed$ = !0, l.prior(O, A);
              });
            else
              return l.prior(O, A);
          });
        });
      }
      if (i)
        i.call(p, null, o, u.join("~"));
      else
        return {
          tag: o,
          desc: u.join("~")
        };
    }
  };
}
store.Store = Store;
const Intern = {
  // Ensure entity objects are instantiated
  reify_entity_wrap: function(x, C, c, p, v) {
    const n = function(i, s, r) {
      return i.cmd !== "save" && (i.q == null && (i.q = {}, i.id != null && (i.q.id = i.id, delete i.id)), i.qent == null && (i.qent = this.make$({
        entity$: {
          name: i.name,
          base: i.base,
          zone: i.zone
        }
      }))), i.ent != null && typeof i.ent.canon$ != "function" && (i.ent = this.make$({
        entity$: {
          name: i.name,
          base: i.base,
          zone: i.zone
        }
      }).data$(i.ent)), x.call(this, i, s, r);
    };
    return Object.defineProperty(n, "name", {
      value: "entity_" + C + (c == null ? "" : c + "_") + (p == null ? "" : p + "_") + (v == null ? "" : v)
    }), n;
  }
};
store.Intern = Intern;
var memStoreExports = {}, memStore = {
  get exports() {
    return memStoreExports;
  },
  set exports(x) {
    memStoreExports = x;
  }
}, intern = {}, hasRequiredIntern;
function requireIntern() {
  if (hasRequiredIntern)
    return intern;
  hasRequiredIntern = 1, Object.defineProperty(intern, "__esModule", { value: !0 }), intern.intern = void 0;
  let x = class Wn {
    static is_new(c) {
      return c != null && c.id == null;
    }
    static is_upsert(c) {
      const { ent: p, q: v } = c;
      return Wn.is_new(p) && v && Array.isArray(v.upsert$);
    }
    static find_mement(c, p, v) {
      const { base: n, name: i } = p.canon$({ object: !0 }), s = c[n] && c[n][i];
      if (s == null)
        return null;
      let r = null;
      for (const u in s) {
        const a = s[u];
        if (o(a, v)) {
          r = a;
          break;
        }
      }
      return r;
      function o(u, a) {
        for (const f in a)
          if (!(f in u && a[f] === u[f]))
            return !1;
        return !0;
      }
    }
    static update_mement(c, p, v, n) {
      const i = Wn.find_mement(c, p, v);
      return i ? (Object.assign(i, n), i) : null;
    }
    static should_merge(c, p) {
      return !(p.merge === !1 || c.merge$ === !1);
    }
    // NOTE: Seneca supports a reasonable set of features
    // in terms of listing. This function can handle
    // sorting, skiping, limiting and general retrieval.
    //
    static listents(c, p, v, n, i) {
      let s = [], r = v.canon$({ object: !0 }), o = r.base, u = r.name, a = p[o] ? p[o][u] : null, f;
      if (a != null && n != null) {
        if (typeof n == "string")
          f = a[n], f && s.push(f);
        else if (Array.isArray(n))
          n.forEach(function(y) {
            let T = a[y];
            T && (T = v.make$(T), s.push(T));
          });
        else if (typeof n == "object") {
          let y = Object.keys(a);
          t:
            for (let T of y) {
              f = a[T];
              for (let h in n) {
                let _ = n[h], g = f[h];
                if (h.indexOf("$") === -1) {
                  if (Array.isArray(_)) {
                    if (_.indexOf(g) === -1)
                      continue t;
                  } else if (Wn.is_object(_)) {
                    if (_.$ne != null && _.$ne == g || _.$gte != null && _.$gte > g || _.$gt != null && _.$gt >= g || _.$lt != null && _.$lt <= g || _.$lte != null && _.$lte < g || _.$in != null && _.$in.indexOf(g) === -1 || _.$nin != null && _.$nin.indexOf(g) !== -1)
                      continue t;
                  } else if (Wn.is_date(_)) {
                    if (!(Wn.is_date(g) && Wn.eq_dates(_, g)))
                      continue t;
                  } else if (_ !== g)
                    continue t;
                }
              }
              f = v.make$(f), s.push(f);
            }
        }
      }
      if (n != null && n.sort$) {
        let y;
        for (y in n.sort$)
          break;
        let T = n.sort$[y] < 0 ? -1 : 1;
        s = s.sort(function(h, _) {
          return T * (h[y] < _[y] ? -1 : h[y] === _[y] ? 0 : 1);
        });
      }
      if (n != null && n.skip$ && n.skip$ > 0 && (s = s.slice(n.skip$)), n != null && n.limit$ && n.limit$ >= 0 && (s = s.slice(0, n.limit$)), n != null && n.fields$)
        for (let y = 0; y < s.length; y++) {
          let T = s[y].fields$();
          for (let h = 0; h < T.length; h++)
            T[h] !== "id" && n.fields$.indexOf(T[h]) == -1 && delete s[y][T[h]];
        }
      i.call(c, null, s);
    }
    static clean_array(c) {
      return c.filter((p) => !p.includes("$"));
    }
    static is_object(c) {
      return toString.call(c) === "[object Object]";
    }
    static is_date(c) {
      return toString.call(c) === "[object Date]";
    }
    static eq_dates(c, p) {
      return c.getTime() === p.getTime();
    }
  };
  return intern.intern = x, intern;
}
var hasRequiredMemStore;
function requireMemStore() {
  return hasRequiredMemStore || (hasRequiredMemStore = 1, function(x, C) {
    Object.defineProperty(C, "__esModule", { value: !0 });
    const c = requireIntern();
    let p = {
      name: "mem-store"
    };
    function v(n) {
      let i = this, s = i.export("entity/init");
      n = i.util.deepextend({
        prefix: "/mem-store",
        idlen: 6,
        web: {
          dump: !1
        },
        // TODO: use seneca.export once it allows for null values
        generate_id: i.root.private$.exports["entity/generate_id"]
      }, n);
      let r, o = {}, u = {
        // The name of the plugin, this is what is the name you would
        // use in seneca.use(), eg seneca.use('mem-store').
        name: p.name,
        save: function(f, y) {
          let T = this, h = f.ent, _ = h.canon$({ object: !0 }), g = _.zone, S = _.base, d = _.name;
          return c.intern.is_new(h) ? O() : k();
          function k(A, l) {
            o[S] = o[S] || {}, o[S][d] = o[S][d] || {};
            const E = h.data$(!0, "string");
            let M = null, B = null;
            c.intern.is_upsert(f) && (B = "upsert", M = D(E, f)), M == null && (B = c.intern.is_new(f.ent) ? "insert" : "update", M = j(E, f, A, l));
            const X = T.util.deep(M), K = h.make$(X);
            return T.log.debug("save/" + B, h.canon$({ string: 1 }), M, r), y(null, K);
            function D(Z, tt) {
              const { q: nt, ent: ct } = tt, ut = c.intern.clean_array(nt.upsert$);
              if (0 < ut.length && ut.every((ot) => ot in Z)) {
                const ot = ut.reduce((Ut, pt) => (Ut[pt] = Z[pt], Ut), {});
                return c.intern.update_mement(o, ct, ot, Z);
              }
              return null;
            }
            function j(Z, tt, nt, ct) {
              const { ent: ut } = tt;
              nt != null && (Z.id = nt);
              const V = o[S][d][Z.id];
              if (ct && V) {
                T.fail("entity-id-exists", {
                  type: ut.entity$,
                  id: Z.id
                });
                return;
              }
              return c.intern.should_merge(ut, n) && (Z = Object.assign(V || {}, Z)), o[S][d][Z.id] = Z, Z;
            }
          }
          function O() {
            let A;
            if (h.id$ != null)
              return A = h.id$, delete h.id$, k(A, !0);
            if (A = n.generate_id ? n.generate_id(h) : void 0, A !== null)
              return k(A, !0);
            {
              let l = {
                role: "basic",
                cmd: "generate_id",
                name: d,
                base: S,
                zone: g
              };
              T.act(l, function(E, M) {
                if (E)
                  return y(E);
                k(M, !0);
              });
            }
          }
        },
        load: function(f, y) {
          let T = f.qent, h = f.q || {};
          return c.intern.listents(this, o, T, h, function(_, g) {
            let S = g[0] || null;
            this.log.debug("load", h, T.canon$({ string: 1 }), S, r), y(_, S);
          });
        },
        list: function(f, y) {
          let T = f.qent, h = f.q || {};
          return c.intern.listents(this, o, T, h, function(_, g) {
            this.log.debug("list", h, T.canon$({ string: 1 }), g.length, g[0], r), y(_, g);
          });
        },
        remove: function(f, y) {
          let T = this, h = f.qent, _ = f.q || {}, g = _.all$, S = _.load$ === !0;
          return c.intern.listents(T, o, h, _, function(d, b) {
            if (d)
              return y(d);
            b = b || [], b = g ? b : b.slice(0, 1), b.forEach(function(O) {
              let A = h.canon$({
                object: !0
              });
              delete o[A.base][A.name][O.id], T.log.debug("remove/" + (g ? "all" : "one"), _, h.canon$({ string: 1 }), O, r);
            });
            let k = !g && S && b[0] || null;
            y(null, k);
          });
        },
        close: function(f, y) {
          this.log.debug("close", r), y();
        },
        // .native() is used to handle calls to the underlying driver. Since
        // there is no underlying driver for mem-store we simply return the
        // default entityMap object.
        native: function(f, y) {
          y(null, o);
        }
      }, a = s(i, n, u);
      return r = a.desc, i.add({ role: u.name, cmd: "dump" }, function(f, y) {
        y(null, o);
      }), i.add({ role: u.name, cmd: "export" }, function(f, y) {
        let T = JSON.stringify(o);
        y(null, { json: T });
      }), i.add({ role: u.name, cmd: "import" }, function(f, y) {
        let T = JSON.parse(f.json);
        o = f.merge ? this.util.deepextend(o, T) : T, y();
      }), i.init(function(f) {
        var y;
        return !((y = n == null ? void 0 : n.web) === null || y === void 0) && y.dump && this.act("role:web", {
          use: {
            prefix: n.prefix,
            pin: { role: "mem-store", cmd: "*" },
            map: { dump: !0 }
          },
          default$: {}
        }), f();
      }), {
        name: u.name,
        tag: a.tag,
        exportmap: {
          native: o
        }
      };
    }
    v.preload = function() {
      let n = this;
      return {
        name: p.name,
        exportmap: {
          native: function() {
            n.export(p.name + "/native").apply(this, arguments);
          }
        }
      };
    }, v.defaults = {
      "entity-id-exists": "Entity of type <%=type%> with id = <%=id%> already exists."
    }, v.intern = c.intern, Object.defineProperty(v, "name", { value: "mem-store" }), C.default = v, x.exports = v;
  }(memStore, memStoreExports)), memStoreExports;
}
(function(x, C) {
  Object.defineProperty(C, "__esModule", { value: !0 });
  const c = make_entity, p = store, v = {
    mem_store: !0,
    server: !1,
    client: !1,
    generate_id: r,
    // Control stringification of entities
    jsonic: {
      depth: 7,
      maxitems: 11,
      maxchars: 111
    },
    log: {
      active: !1
    },
    meta: {
      // Provide action meta object as third argument to callbacks.
      provide: !0
    },
    transaction: {
      active: !1
    }
  };
  function n() {
    return {
      name: "entity"
    };
  }
  function i(u) {
    const a = this, { deep: f } = a.util, y = f({}, v, u.options), T = (0, p.Store)();
    a.add("role:basic,cmd:generate_id", r), y.transaction.active && a.on("act-err", function(b, k) {
      var O, A;
      if (b.entity === "sys" && b.transaction === "rollback")
        return;
      let l = this, E = (O = l == null ? void 0 : l.fixedmeta) === null || O === void 0 ? void 0 : O.custom, M = ((A = E == null ? void 0 : E.sys__entity) === null || A === void 0 ? void 0 : A.transaction) || {}, B = Object.values(M);
      for (let X of B) {
        if (X.finish != null)
          continue;
        let K = () => X, D = X.canon;
        X.finish = Date.now(), l.act("sys:entity,transaction:rollback", kn(Ge({}, D), {
          get_transaction: K,
          msg: b,
          err: k
        }), function(j, Z) {
          X.result = Z;
        });
      }
    }), a.util.parsecanon = a.util.parsecanon || c.MakeEntity.parsecanon;
    const h = a.delegate();
    a.private$.entity = a.private$.entity || (0, c.MakeEntity)({}, h, y), a.private$.exports.Entity = a.private$.exports.Entity || c.Entity, y.log.active && (a.private$.exports.Entity.prototype.log$ = function() {
      const d = this.private$.get_instance();
      d.log.apply(d, arguments);
    });
    function _(d) {
      let b = function() {
        return a.private$.entity.make$(this, ...arguments, d);
      };
      return b.instance = function() {
        return this().private$.get_instance();
      }, b.state = function(k) {
        let O = this();
        return o(O, k);
      }, b.begin = function(k, O) {
        return sn(this, null, function* () {
          if (!y.transaction.active)
            return null;
          let A = this(), l = o(A, k), E = l.transaction;
          if (E && !E.finish) {
            let K = new Error("Transaction already exists" + (l.canonstr ? ` (${l.canonstr})` : ""));
            throw K.transaction = E, K;
          }
          let M = yield new Promise((K, D) => {
            l.instance.act("sys:entity,transaction:begin", Ge(Ge({}, l.canon), O || {}), function(j, Z) {
              return j ? D(j) : K(Z);
            });
          }), { get_handle: B } = M;
          E = {
            sid: "",
            did: "",
            start: Date.now(),
            begin: M,
            canon: l.canon,
            handle: B(),
            trace: [],
            id: l.instance.util.Nid()
          };
          let X = l.instance.delegate(null, {
            custom: {
              sys__entity: {
                transaction: {
                  [l.canonstr]: E
                }
              }
            }
          });
          return E.sid = X.id, E.did = X.did, X.entity = l.instance.entity.bind(X), Object.assign(X.entity, l.instance.entity), X;
        });
      }, b.end = function(k, O) {
        return sn(this, null, function* () {
          if (!y.transaction.active)
            return null;
          let A = this(), l = o(A, k), E = l.instance.fixedmeta.custom.sys__entity.transaction[l.canonstr];
          if (E == null)
            throw new Error("Transaction does not exist" + (l.canonstr ? ` (${l.canonstr})` : ""));
          let M = () => E;
          E.finish = Date.now();
          let B = yield new Promise((X, K) => {
            l.instance.act("sys:entity,transaction:end", kn(Ge(Ge({}, l.canon), O || {}), {
              get_transaction: M
            }), function(D, j) {
              return D ? K(D) : X(j);
            });
          });
          return E.result = B, E;
        });
      }, b.rollback = function(k, O) {
        return sn(this, null, function* () {
          if (!y.transaction.active)
            return null;
          let A = this(), l = o(A, k), E = l.instance.fixedmeta.custom.sys__entity.transaction[l.canonstr];
          if (E == null)
            throw new Error("Transaction does not exist" + (l.canonstr ? ` (${l.canonstr})` : ""));
          let M = () => E, B = c.MakeEntity.parsecanon(k);
          E.finish = Date.now();
          let X = yield new Promise((K, D) => {
            l.instance.act("sys:entity,transaction:rollback", kn(Ge(Ge({}, B), O || {}), {
              get_transaction: M
            }), function(j, Z) {
              return j ? D(j) : K(Z);
            });
          });
          return E.result = X, E;
        });
      }, b.adopt = function(k, O, A) {
        return sn(this, null, function* () {
          var l, E;
          if (!y.transaction.active)
            return null;
          let M = this(), B = o(M, O), X = (E = (l = B.instance.fixedmeta.custom) === null || l === void 0 ? void 0 : l.sys__entity) === null || E === void 0 ? void 0 : E.transaction[B.canonstr];
          if (X && !X.finish) {
            let Z = new Error("Transaction already exists" + (B.canonstr ? ` (${B.canonstr})` : ""));
            throw Z.transaction = X, Z;
          }
          let K = yield new Promise((Z, tt) => {
            B.instance.act("sys:entity,transaction:adopt", kn(Ge(Ge({}, B.canon), A || {}), {
              get_handle: () => k
            }), function(nt, ct) {
              return nt ? tt(nt) : Z(ct);
            });
          }), { get_handle: D } = K;
          X = {
            start: Date.now(),
            begin: K,
            canon: B.canon,
            handle: D(),
            trace: [],
            id: B.instance.util.Nid()
          };
          let j = B.instance.delegate(null, {
            custom: {
              sys__entity: {
                transaction: {
                  [B.canonstr]: X
                }
              }
            }
          });
          return X.sid = j.id, X.did = j.did, j.entity = B.instance.entity.bind(j), Object.assign(j.entity, B.instance.entity), j;
        });
      }, b;
    }
    let g = _(!1), S = _(!0);
    return a.make$ || a.decorate("make$", g), a.make || a.decorate("make", g), a.entity || a.decorate("entity", S), (!a.store || !a.store.init) && a.decorate("store", T), !a.options().default_plugins["mem-store"] && y.mem_store && !y.client && a.root.use(requireMemStore()), this.translate("sys:entity,cmd:load", "role:entity").translate("sys:entity,cmd:save", "role:entity").translate("sys:entity,cmd:list", "role:entity").translate("sys:entity,cmd:remove", "role:entity"), y.client ? (this.translate("role:entity,cmd:load", "role:remote-entity").translate("role:entity,cmd:save", "role:remote-entity").translate("role:entity,cmd:list", "role:remote-entity").translate("role:entity,cmd:remove", "role:remote-entity"), this.translate("sys:entity,cmd:load", "sys:remote-entity").translate("sys:entity,cmd:save", "sys:remote-entity").translate("sys:entity,cmd:list", "sys:remote-entity").translate("sys:entity,cmd:remove", "sys:remote-entity")) : y.server && (this.translate("role:remote-entity,cmd:load", "role:entity").translate("role:remote-entity,cmd:save", "role:entity").translate("role:remote-entity,cmd:list", "role:entity").translate("role:remote-entity,cmd:remove", "role:entity"), this.translate("sys:remote-entity,cmd:load", "sys:entity").translate("sys:remote-entity,cmd:save", "sys:entity").translate("sys:remote-entity,cmd:list", "sys:entity").translate("sys:remote-entity,cmd:remove", "sys:entity")), {
      name: "entity",
      exports: {
        store: T,
        init: T.init,
        generate_id: y.generate_id.bind(a)
      }
    };
  }
  n.preload = i;
  const s = [];
  function r(u, a) {
    let y = this.util.Nid, T = u == null ? y({}) : null;
    if (T == null) {
      const h = typeof u == "object" ? parseInt(u.length, 10) || 6 : parseInt(u, 10);
      h < 65 ? T = s[h] || (s[h] = y({ length: h })) : T = y({ length: h });
    }
    return a ? a(T()) : T();
  }
  function o(u, a) {
    var f;
    let y = u.private$.get_instance(), T = c.MakeEntity.parsecanon(a), h = c.MakeEntity.canonstr(T), _ = y.fixedmeta.custom, g = ((f = _ == null ? void 0 : _.sys__entity) === null || f === void 0 ? void 0 : f.transaction[h]) || null;
    return {
      when: Date.now(),
      instance: y,
      canon: T,
      canonstr: h,
      transaction: g
    };
  }
  C.default = n, x.exports = n;
})(entity, entityExports);
const SenecaEntity = /* @__PURE__ */ getDefaultExportFromCjs(entityExports);
var rastercoordsExports = {}, rastercoords = {
  get exports() {
    return rastercoordsExports;
  },
  set exports(x) {
    rastercoordsExports = x;
  }
};
/**
 * leaflet plugin for plain image map projection
 * @copyright 2016- commenthol
 * @license MIT
 */
(function(x) {
  (function(C) {
    var c;
    c = requireLeafletSrc(), x.exports = C(c);
  })(function(C) {
    return C.RasterCoords = function(c, p, v, n = !0) {
      this.map = c, this.width = p[0], this.height = p[1], this.tilesize = v || 256, this.zoom = this.zoomLevel(), n && this.width && this.height && this.setMaxBounds();
    }, C.RasterCoords.prototype = {
      /**
       * calculate accurate zoom level for the given image size
       */
      zoomLevel: function() {
        return Math.ceil(
          Math.log(
            Math.max(this.width, this.height) / this.tilesize
          ) / Math.log(2)
        );
      },
      /**
       * unproject `coords` to the raster coordinates used by the raster image projection
       * @param {Array} coords - [ x, y ]
       * @return {L.LatLng} - internal coordinates
       */
      unproject: function(c) {
        return this.map.unproject(c, this.zoom);
      },
      /**
       * project `coords` back to image coordinates
       * @param {Array} coords - [ x, y ]
       * @return {L.LatLng} - image coordinates
       */
      project: function(c) {
        return this.map.project(c, this.zoom);
      },
      /**
       * get the max bounds of the image
       */
      getMaxBounds: function() {
        var c = this.unproject([0, this.height]), p = this.unproject([this.width, 0]);
        return new C.LatLngBounds(c, p);
      },
      /**
       * sets the max bounds on map
       */
      setMaxBounds: function() {
        var c = this.getMaxBounds();
        this.map.setMaxBounds(c);
      }
    }, C.RasterCoords;
  });
})(rastercoords);
(function(x, C) {
  x.PLANTQUEST_ASSETMAP_DEBUG = {};
  const c = (...l) => {
    (x.PLANTQUEST_ASSETMAP_LOG === !0 || l[1] === "ERROR") && console.log.apply(null, l);
  }, p = ("" + Math.random()).substring(2, 8);
  if (c("PQAM", "script-load", "start", "version=", Pkg.version, "scriptid=", p), x.PlantQuestAssetMap) {
    c("PQAM", "script-load", "exists", p, x.PlantQuestAssetMap.id);
    return;
  } else
    c("PQAM", "script-load", "create", p);
  let v = C.querySelector.bind(C);
  C.querySelectorAll.bind(C);
  let n = C.createElement.bind(C), i;
  function s() {
    const l = {
      id: ("" + Math.random()).substring(2, 8),
      info: {
        name: "@plantquest/assetmap",
        version: Pkg.version
      },
      // default config
      config: {
        width: "100%",
        height: "100%",
        domInterval: 111,
        mapInterval: 111,
        mapBounds: [5850, 7800],
        mapImg: [7800, 5850],
        mapStart: [3e3, 2200],
        mapStartZoom: 2,
        mapRoomFocusZoom: 5,
        mapMinZoom: 2,
        mapMaxZoom: 6,
        assetFontScaleRoom: 10,
        assetFontScaleZoom: 4,
        assetFontHideZoom: -1,
        showAllAssets: !0,
        debugClick: !1,
        infobox: {
          show: !1,
          single: !0
        },
        data: "https://demo.plantquest.app/sample-data.js",
        mode: "demo",
        apikey: "<API KEY>",
        endpoint: "/",
        tilesEndPoint: "https://demo.plantquest.app/tiles",
        states: {
          up: { color: "#99f", name: "Up", marker: "standard" },
          down: { color: "#666", name: "Down", marker: "standard" },
          missing: { color: "#f9f", name: "Missing", marker: "alert" },
          alarm: { color: "#f99", name: "Alarm", marker: "alert" }
        },
        map: [],
        start: {
          map: 0,
          level: 0
        },
        room: {
          click: {
            active: !0
          },
          outline: {
            active: !0
          },
          color: "#33f"
        },
        label: {
          zoom: null
          // null => appear at mapMaxZoom
        },
        plants: [],
        asset: {
          cluster: !0
        }
      },
      data: {},
      assetMap: {},
      roomMap: {},
      current: {
        started: !1,
        room: {},
        asset: {},
        assetInfo: null,
        clusterInfo: null,
        assetInfoShown: {}
      },
      upload: {
        assetI: 0,
        interval: null
      },
      room: {
        map: {}
      },
      ux: {
        room: {
          // { [mapid]: marker }
          label: {}
        }
      },
      listeners: []
    };
    return l.log = function(...E) {
      c("PQAM", ...E);
    }, l.start = function(E) {
      if (l.current.started) {
        l.clearRoomAssets(), l.unselectRoom(), l.map.setView(l.config.mapStart, l.config.mapStartZoom);
        return;
      }
      l.config = Ge(Ge({}, l.config), E || {}), l.log("start", JSON.stringify(E)), l.config.base = l.config.base || "", l.config.base.endsWith("/") || (l.config.base += "/");
      function M() {
        if (l.target = v("#plantquest-assetmap"), !l.target) {
          l.log("ERROR", "element-id", "plantquest-assetmap", "missing"), clearInterval(B);
          return;
        }
        l.target != null && l.current.started === !1 && (l.current.started = !0, l.target.style.width = l.config.width, l.target.style.height = l.config.height, clearInterval(B), l.log("start", "target-found", l.target), l.log(
          "start",
          "target-size",
          "widthcss",
          l.config.width,
          "heightcss",
          l.config.height
        ), l.load(() => {
          l.log("start", "load-done", l.data), l.render(() => {
            l.log("start", "render-done"), l.emit({
              srv: "plantquest",
              part: "assetmap",
              state: "ready"
            });
          });
        }));
      }
      const B = setInterval(M, 50);
    }, l.load = function(E) {
      return sn(this, null, function* () {
        let M = { cfg: l.config, pqam: l }, B = yield l.getSeneca(), X = (D) => sn(this, null, function* () {
          l.data = D;
          let j = {}, Z = l.data.assets[0];
          for (let nt = 1; nt < l.data.assets.length; nt++) {
            let ct = l.data.assets[nt], ut = ct[0];
            j[ut] = Z.reduce((V, ot, xt) => (V[ot] = ct[xt], V), {});
          }
          l.data.assetMap = j;
          let tt = l.data.rooms.reduce((nt, ct) => (nt[ct.room] = ct, nt[ct.id] = ct, nt), {});
          l.data.roomMap = tt, l.data.rooms.forEach((nt) => {
            l.room.map[nt.id] = new r(nt, M);
          }), l.log("data loaded"), E(D);
        }), K = () => sn(this, null, function* () {
          if (l.dataLoaded) {
            E(l.data);
            return;
          }
          let D = {
            project_id: l.config.project_id,
            plant_id: l.config.plant_id,
            stage: l.config.stage
          }, j = {
            asset: [],
            room: [],
            building: [],
            geofence: []
          };
          for (let V of Object.keys(j)) {
            let ot = yield B.post(
              "srv:plantquest,part:assetmap",
              { list: V, query: D }
            );
            ot.ok && (j[V] = ot.list);
          }
          l.data.assets = j.asset, l.data.rooms = j.room, l.data.buildings = j.building, l.data.geofences = j.geofence, l.data.rooms.forEach((V) => {
            l.room.map[V.id] = new r(V, M);
          }), l.data.deps = {};
          let {
            deps: Z,
            maps: tt,
            levels: nt,
            // buildings,
            assetMap: ct,
            roomMap: ut
          } = O({
            assets: j.asset,
            rooms: j.room
          });
          l.data.levels = nt, l.data.maps = tt, l.data.assetMap = ct, l.data.roomMap = ut, l.data.deps = Z, l.dataLoaded = !0, E(l.data);
        });
        if (l.config.mode == "demo")
          if (l.config.data === "https://demo.plantquest.app/sample-data.js") {
            const D = v("head"), j = document.createElement("script");
            j.setAttribute("src", l.config.data), D.appendChild(j);
            let Z = setInterval(() => {
              l.log("loading data..."), x.PLANTQUEST_ASSETMAP_DATA && (clearInterval(Z), X(x.PLANTQUEST_ASSETMAP_DATA));
            }, 111);
          } else
            fetch(l.config.data).then((D) => {
              if (!D.ok)
                throw new Error("HTTP error " + D.status);
              return D.json();
            }).then((D) => X(D)).catch((D) => l.log("ERROR", "load", D));
        else
          l.config.mode == "live" && K();
      });
    }, l.render = function(E) {
      A();
      let M = n("div");
      M.style.boxSizing = "border-box", M.style.width = "100%", M.style.height = "100%", M.style.backgroundColor = "rgb(203,211,144)", M.style.padding = "0px", M.style.textAlign = "center", M.style.position = "relative", M.innerHTML = o(), l.target.appendChild(M), setTimeout(() => {
        l.vis.map.elem = v("#plantquest-assetmap-map"), l.build(), l.showMap(0), E();
      }, l.domInterval);
    }, l.send = function(E) {
      return sn(this, null, function* () {
        l.log("send", "in", E);
        let M = yield l.seneca.post(E);
        return E.zoom != null && l.map.setZoom(E.zoom), E.view != null && l.map.setView(E.view, E.zoom || l.config.mapMinZoom), M;
      });
    }, l.listen = function(E) {
      E == null || typeof E != "function" ? l.log("ERROR", "listen", "bad-listener", E) : (l.listeners.push(E), l.log(
        "listen",
        "set-listener",
        "<<" + E.toString().substring(0, 77).replace(/[\r\n]/g, "") + "...>>"
      ));
    }, l.click = function(E, M) {
      let B = Object.assign({
        srv: "plantquest",
        part: "assetmap"
      }, E);
      l.log("click", B), l.emit(B);
    }, l.emit = function(E) {
      l.log("send", E), l.listeners.forEach((M) => {
        try {
          M(E);
        } catch (B) {
          l.log("ERROR", "emit", "listener", B, E, M);
        }
      });
    }, l.vis = {
      map: {},
      ctrl: {}
    }, l.loc = {
      x: 0,
      y: 0,
      poly: null,
      room: null,
      chosen: {
        poly: null,
        room: null
      },
      stateShown: {},
      asset: {},
      map: -1
    }, l.leaflet = {}, l.map = null, l.layer = {}, l.build = function() {
      let E = {
        mapurl: l.config.map[l.config.start.map],
        bounds: [[0, 0], [...l.config.mapBounds]]
      };
      l.log("build", E, L$1), l.map = L$1.map("plantquest-assetmap-map", {
        crs: L$1.CRS.Simple,
        scrollWheelZoom: !1,
        doubleClickZoom: !1,
        attributionControl: !1,
        minZoom: l.config.mapMinZoom,
        maxZoom: l.config.mapMaxZoom
      }), i = l.rc = new L$1.RasterCoords(l.map, l.config.mapImg), l.map.getContainer().addEventListener("wheel", (D) => {
        ("" + (D.target && D.target.className || "")).indexOf("plantquest-assetmap-vis") != -1 && l.map.scrollWheelZoom._onWheelScroll(D);
      }), l.map.scrollWheelZoom._delta = 0, l.map.createPane("label");
      let M = l.map.getPane("label");
      M.style.zIndex = 220, M.style.pointerEvents = "none", l.layer.label = L$1.layerGroup(null, { pane: "label" }).addTo(l.map), l.layer.label.name$ = "label", l.layer.room = L$1.layerGroup().addTo(l.map), l.layer.room.name$ = "room", l.map.on("zoomstart", l.zoomStartRender), l.map.on("zoomend", l.zoomEndRender), setTimeout(() => {
        let D = g({ x: l.config.mapStart[0], y: l.config.mapImg[1] - l.config.mapStart[1] });
        l.map.setView(D, l.config.mapStartZoom), l.leaflet.mapCenter = l.map.getCenter();
      }, l.config.mapInterval / 2), l.layer.indicator = L$1.layerGroup().addTo(l.map), l.layer.indicator.name$ = "indicator", l.config.asset.cluster ? (l.layer.asset = L$1.markerClusterGroup({
        animateAddingMarkers: !1,
        spiderfyOnMaxZoom: !1,
        showCoverageOnHover: !1,
        // zoomToBoundsOnClick: true,
        zoomToBoundsOnClick: !1,
        // singleMarkerMode: true,
        // spiderfyDistanceMultiplier: -100,
        maxClusterRadius: 40,
        chunkedLoading: !0,
        spiderLegPolylineOptions: { weight: 1.5, color: "black", opacity: 2.5 },
        spiderfyLinear: !1,
        spiderfyLinearDistance: 30,
        spiderfyLinearSeparation: 45
      }).addTo(l.map), l.layer.clusterInfo = L$1.layerGroup().addTo(l.map), l.layer.clusterInfo.name$ = "clusterInfo", l.layer.assetInfo = L$1.layerGroup().addTo(l.map), l.layer.assetInfo.name$ = "assetInfo", l.layer.asset.on("clusterclick", (D) => {
        let j = D.layer, { xco: Z, yco: tt } = h(D.latlng), nt = j.getAllChildMarkers().map((ct) => l.data.assetMap[ct.assetID]).filter((ct) => ct != null);
        if (l.emit({
          srv: "plantquest",
          part: "assetmap",
          event: "clusterclick",
          assetlist: nt
        }), l.current.clusterInfo && j.open$ && l.current.clusterInfo.clusterID$ === j.clusterID$) {
          l.closeClusterInfo(), j.open$ = !1;
          return;
        }
        l.openClusterInfo({ clusterMarker: j, xco: Z, yco: tt });
      }), l.map.on("layeradd", (D) => {
        let j = D.layer;
        if (j instanceof L$1.Marker && !(j instanceof L$1.MarkerCluster)) {
          let Z = l.current.asset[j.assetID];
          if (Z == null)
            return;
          Z && Z.indicator.addTo(l.layer.indicator);
        }
      }), l.map.on("layerremove", (D) => {
        let j = D.layer;
        if (j instanceof L$1.Marker && !(j instanceof L$1.MarkerCluster)) {
          let Z = l.current.asset[j.assetID];
          Z && Z.indicator && Z.indicator.remove();
        }
      })) : l.layer.asset = L$1.layerGroup().addTo(l.map);
      function B() {
        for (let j of l.data.rooms) {
          let Z = l.ux.room.label[j.map] = l.ux.room.label[j.map] || [];
          if (l.data.roomMap[j.room] && j.area === "1" && j.poly) {
            let tt = T(l.config.mapImg, j.poly), nt = L$1.polygon(
              tt,
              {
                color: "transparent",
                pane: "label"
              }
            );
            nt.name$ = "ROOM:" + j.room;
            var D = L$1.tooltip({
              permanent: !0,
              direction: "center",
              opacity: 1,
              className: "polygon-labels"
            });
            nt.bindTooltip(D), nt.getBounds().getCenter(), D.setContent(`<div class="leaflet-zoom-animted"> ${j.room} </div>`), Z.push(nt);
          }
        }
      }
      B();
      function X(D) {
        let j = L$1.Control.extend({
          options: {
            position: "topleft"
          },
          onAdd: function(Z) {
            let tt = L$1.DomUtil.create("div", "control-panel"), nt = document.createElement("div");
            return nt.textContent = D, tt.appendChild(nt), L$1.DomEvent.disableClickPropagation(tt), L$1.DomEvent.disableScrollPropagation(tt), tt;
          }
        });
        return new j();
      }
      l.config.debugClick && l.map.on("click", (D) => {
        let { xco: j, yco: Z } = h(D.latlng), tt = "";
        l.leaflet.debugLog && (l.leaflet.debugLog.remove(), l.leaflet.debugLog = null);
        let nt = {};
        nt.xco = j, nt.yco = Z, tt = JSON.stringify(nt), l.leaflet.debugLog = X(tt), l.map.addControl(l.leaflet.debugLog), l.emit({
          srv: "plantquest",
          part: "assetmap",
          event: "click",
          meta: nt
        });
      }), x.PLANTQUEST_ASSETMAP_DEBUG.show_coords && l.listen((D) => {
        if (D.show == "asset") {
          let { asset: j } = D, Z = "";
          if (l.leaflet.debugLog && (l.leaflet.debugLog.remove(), l.leaflet.debugLog = null), j) {
            let tt = {};
            tt.tag = j.tag, tt.id = j.id, tt.xco = j.xco, tt.yco = j.yco, Z = JSON.stringify(tt);
          }
          l.leaflet.debugLog = X(Z), l.map.addControl(l.leaflet.debugLog);
        } else if (D.event == "click") {
          let j = D.meta || {}, Z = {}, tt = "";
          l.leaflet.debugLog && (l.leaflet.debugLog.remove(), l.leaflet.debugLog = null), Z.xco = j.xco, Z.yco = j.yco, tt = JSON.stringify(Z), l.leaflet.debugLog = X(tt), l.map.addControl(l.leaflet.debugLog);
        } else
          l.leaflet.debugLog && (l.leaflet.debugLog.remove(), l.leaflet.debugLog = null), l.leaflet.debugLog = X("DEBUG LOG"), l.map.addControl(l.leaflet.debugLog);
      }), l.map.on("mousemove", (D) => {
        let { xco: j, yco: Z } = h(D.latlng);
        l.loc.x = j, l.loc.y = Z;
      }), setInterval(l.checkRooms, l.config.mapInterval);
      let K = [];
      l.data.levels.forEach((D, j) => {
        K.push(
          L$1.Toolbar2.Action.extend({
            options: {
              toolbarIcon: {
                html: D
              }
            },
            addHooks: function() {
              l.showMap(j);
            }
          })
        );
      }), l.config.plants.forEach((D, j) => {
        K.push(
          L$1.Toolbar2.Action.extend({
            options: {
              toolbarIcon: {
                html: D.name
              }
            },
            addHooks: function() {
              l.showMap(j);
            }
          })
        );
      }), l.map.addLayer(new L$1.Toolbar2.Control({
        actions: K,
        position: "topright"
      }));
    }, l.zoomStartRender = function() {
      l.map.getZoom() != null;
    }, l.zoomEndRender = function() {
      let E = l.map.getZoom();
      if (E == null)
        return;
      let M = 1 + l.loc.map, B = l.ux.room.label[M] || [];
      l.prev_labels = l.prev_labels || [];
      let X = l.config.label.zoom == null ? l.config.mapMaxZoom : l.config.label.zoom;
      if (E >= X) {
        for (let K of l.prev_labels)
          K.remove();
        for (let K of B)
          K.remove(), K.addTo(l.layer.label);
        l.setLabel = !0, l.prev_labels = B;
      } else {
        for (let K of l.prev_labels)
          K.remove();
        for (let K of B)
          K.remove();
        l.setLabel = !1;
      }
    }, l.checkRooms = function() {
      let E = l.loc.x, M = _(l.config.mapImg, l.loc.y), B = Object.values(l.data.rooms);
      for (let X of B) {
        if (1 + l.loc.map != X.map)
          continue;
        let K = l.room.map[X.id], D = l.current.room[X.room] ? l.current.room[X.room].alarm : null, j = X.poly && a([M, E], X.poly), Z = X === l.loc.room || X === l.loc.chosen.room, tt = j && !Z && D !== "red";
        if (!tt && !j && l.loc.room === X)
          l.loc.poly && (l.loc.poly.remove(l.layer.room), l.loc.room = null);
        else if (tt) {
          l.loc.poly && (l.loc.poly.remove(l.layer.room), l.loc.room = null);
          try {
            let nt = l.current.room[X.room] || (l.current.room[X.room] = { alarm: "neutral" }), ct = T(l.config.mapImg, X.poly);
            l.loc.room = X, l.loc.alarmState = D, K.buildPoly(l.loc, ct, l.layer.room);
          } catch (nt) {
            l.log("ERROR", "map", "1020", nt.message, nt);
          }
        }
      }
    }, l.selectRoom = function(E, M) {
      M = M || {};
      try {
        let B = l.data.roomMap[E], X = l.loc.chosen.room && E === l.loc.chosen.room.room;
        if (l.data.roomMap[E] == null || X) {
          l.focusRoom(l.loc.chosen.room);
          return;
        }
        l.log("selectRoom", E, B);
        let K = l.current.room[B.room] || (l.current.room[B.room] = { alarm: "neutral" });
        if (l.loc.poly && (l.loc.poly.remove(l.layer.room), l.loc.poly = null), l.loc.room = null, l.loc.chosen.poly && B !== l.loc.chosen.room) {
          let ct = l.loc.chosen.room, ut = l.current.room[ct.room] || (l.current.room[ct.room] = { alarm: "neutral" });
          l.loc.chosen.poly.remove(l.layer.room), l.loc.chosen.poly = null;
        }
        l.loc.popup && (l.loc.popup.remove(l.map), l.loc.popop = null), l.loc.chosen.room = B;
        let D = T(l.config.mapImg, B.poly);
        l.loc.chosen.poly = L$1.polygon(
          D,
          {
            // color: self.resolveRoomColor(roomState.alarm,'hi')
            color: l.config.room.color
          }
        ), l.loc.chosen.poly.on("click", () => l.selectRoom(B.room)), l.loc.chosen.poly.addTo(l.layer.room);
        let j = l.focusRoom(B), Z = _(l.config.mapImg, j[0]), tt = j[1], nt = g({ y: Z - 4, x: tt + 5 });
        l.loc.popup = L$1.popup({
          autoClose: !1,
          closeOnClick: !1
        }).setLatLng(nt).setContent(l.roomPopup(l.loc.chosen.room)).openOn(l.map), l.showRoomAssets(B.room), l.clearRoomAssets(B.room), M.mute || l.click({ select: "room", room: l.loc.chosen.room.room });
      } catch (B) {
        l.log("ERROR", "selectRoom", "1010", E, B.message, B);
      }
    }, l.unselectRoom = function() {
      let E = l.loc.chosen.room;
      if (E) {
        l.loc.chosen.room = null;
        let M = l.current.room[E.room] || (l.current.room[E.room] = { alarm: "neutral" });
        M.alarm === "red" ? (l.loc.chosen.poly.setStyle({
          color: l.resolveRoomColor(M.alarm, "lo")
        }), l.loc.stateShown[E.room].poly = l.loc.chosen.poly) : l.loc.chosen.poly.remove(l.layer.room), l.loc.chosen.poly = null, l.loc.popup && (l.loc.popup.remove(l.map), l.loc.popop = null);
      }
    }, l.focusRoom = function(E) {
      if (E == null)
        return;
      let M = [0, 0];
      for (let D of E.poly)
        D[0] > M[0] && (M[0] = D[0], M[1] = D[1]);
      let B = _(l.config.mapImg, M[0]), X = M[1], K = g({ y: B, x: X - 30 });
      return l.map.setView(
        K,
        l.config.mapRoomFocusZoom
      ), l.zoomEndRender(), M;
    }, l.showRoom = function(E, M) {
      l.log("showRoom", E, M), M = M || assetCurrent.stateName || Object.keys(l.config.states)[0];
      let B = l.config.states[M];
      E = typeof E == "string" ? l.data.roomMap[E] : E;
      try {
        B = l.alertRoomState(E.room, B);
        let X = l.current.room[E.room] || (l.current.room[E.room] = {});
        X.stateDef = B;
        let K = l.loc.stateShown[E.room] || (l.loc.stateShown[E.room] = {});
        E === l.loc.chosen.room ? l.loc.chosen.poly && l.loc.chosen.poly.setStyle({
          // color: self.resolveRoomColor(roomCurrent.stateDef,'hi')
          color: l.config.room.color
        }) : K.poly && (K.poly.remove(l.layer.room), K.poly = null);
      } catch (X) {
        l.log("ERROR", "map", "showRoom", "1040", X.message, X);
      }
    }, l.alertRoomState = function(E, M) {
      let B = M, X = Object.keys(l.config.states).indexOf(M.stateName), K = (l.data.deps.pc.room[E] ? l.data.deps.pc.room[E].asset : []) || [];
      for (let D of K) {
        let j = l.current.asset[D];
        if (j && j.stateName) {
          let Z = l.config.states[j.stateName];
          if (Z.marker === "alert") {
            let tt = Object.keys(l.config.states).indexOf(j.stateName);
            X < tt && (B = Z);
          }
        }
      }
      return B;
    }, l.openAssetInfo = function(E) {
      let { asset: M, assetMarker: B, xco: X, yco: K } = E;
      l.closeAssetInfo(), l.closeClusterInfo();
      let D = v("#plantquest-assetmap-assetinfo");
      if (D == null)
        return;
      let j = C.createElement("div");
      j.setAttribute("id", "pq-assetinfo"), j.appendChild(D), D.style.display = "block";
      let Z = l.current.assetInfo = L$1.marker(
        g({ x: X + 1, y: K + 20 }),
        {
          zIndexOffset: 1e3,
          icon: L$1.divIcon(
            {
              className: "plantquest-assetmap-assetinfo",
              html: j
            }
          )
        }
      );
      Z.addTo(l.layer.assetInfo), Z.assetID$ = M.id, B && (B.assetID$ = Z.assetID$, B.open$ = !0), l.current.assetInfoShown[M.id] = !0;
    }, l.closeAssetInfo = function() {
      let E = l.current.assetInfo;
      if (E) {
        let M = v("#plantquest-assetmap-assetinfo");
        M && (M.style.display = "none", v("body").appendChild(M)), E.remove(), E.open$ = !1, l.current.assetInfoShown[E.assetID$] = !1;
      }
      l.current.assetInfo = null;
    }, l.openClusterInfo = function(E) {
      let { clusterMarker: M, xco: B, yco: X } = E;
      l.closeAssetInfo(), l.closeClusterInfo();
      let K = v("#plantquest-assetmap-assetcluster");
      if (K == null)
        return;
      let D = C.createElement("div");
      D.setAttribute("id", "pq-clusterinfo"), D.appendChild(K), K.style.display = "block";
      let j = l.current.clusterInfo = L$1.marker(
        g({ x: B + 1, y: X + 20 }),
        {
          zIndexOffset: 1e3,
          icon: L$1.divIcon(
            {
              className: "plantquest-assetmap-assetcluster",
              html: D
            }
          )
        }
      );
      j.addTo(l.layer.clusterInfo), j.clusterID$ = "" + (1e9 * Math.random() | 0), M && (M.clusterID$ = j.clusterID$, M.open$ = !0);
    }, l.closeClusterInfo = function(E) {
      let M = l.current.clusterInfo;
      if (M) {
        let B = v("#plantquest-assetmap-assetcluster");
        B && (B.style.display = "none", v("body").appendChild(B)), M.remove(), M.open$ = !1;
      }
    }, l.showAsset = function(E, M, B, X, K, D) {
      l.closeAssetInfo(), l.closeClusterInfo();
      let j = l.current.asset[E] || (l.current.asset[E] = {});
      M = M || j.stateName || Object.keys(l.config.states)[0];
      let Z = l.config.states[M], tt = l.data.assetMap[E];
      if (tt == null || tt.xco == null || tt.yco == null)
        return;
      if (j.infobox = D == null ? !0 : !!D, B) {
        j.label && l.layer.asset.removeLayer(j.label), j.indicator && j.indicator.remove(), delete l.current.assetInfoShown[E];
        return;
      } else
        D && (l.current.assetInfoShown[E] = j);
      let nt = [
        tt.yco,
        tt.xco
      ], ct = nt[1], ut = nt[0];
      j.stateName = M;
      let V = Z.color, ot = _(l.config.mapImg, ut);
      if (T(l.config.mapImg, [
        [ot + 10, ct],
        [ot - 10, ct + 10],
        [ot - 10, ct - 10]
      ]), j.indicator == null) {
        let xt = j.indicator = L$1.circle(
          g({ x: ct, y: ut }),
          {
            radius: 0.2,
            color: V,
            weight: 2
          }
        ).on("click", () => {
          l.current.assetInfoShown[tt.id] ? l.closeAssetInfo() : l.openAssetInfo({
            asset: tt,
            assetMarker: xt,
            xco: tt.xco,
            yco: tt.yco
          }), l.emit({
            srv: "plantquest",
            part: "assetmap",
            event: "click",
            on: "asset",
            asset: tt
          });
        });
      }
      j.blink = X == null ? !1 : X, j.label == null && (j.label = L$1.marker(
        g({ x: ct + 20, y: ut - 2 }),
        { icon: L$1.divIcon({
          className: "plantquest-assetmap-asset-marker",
          html: `<div>${tt.tag.replace(/\s+/g, "&nbsp;")}</div>`
        }) }
      ), j.label.assetID = E), j.label.addTo(l.layer.asset), l.config.asset.cluster || j.indicator.addTo(l.layer.indicator), D && l.openAssetInfo({
        asset: tt,
        assetMarker: j.indicator,
        xco: tt.xco,
        yco: tt.yco
      }), l.zoomEndRender();
    }, l.clearRoomAssets = function(E) {
      for (let M in l.current.asset) {
        let B = l.current.asset[M];
        l.data.deps.cp.asset[M].room !== E && (B.indicator && B.indicator.remove(l.layer.asset), B.label && B.label.remove(l.layer.asset));
      }
    }, l.showRoomAssets = function(E) {
      let M = (l.data.deps.pc.room[E] ? l.data.deps.pc.room[E].asset : []) || [];
      for (let B of M) {
        let X = l.current.asset[B];
        X && X.alarm && l.showAsset(B, X.alarm);
      }
    }, l.getUrl = function(E) {
      return l.config.tilesEndPoint + "/" + E + "/{z}/{x}/{y}.png";
    }, l.createTile = function(E) {
      return L$1.tileLayer(l.getUrl(E), {
        // noWrap: true,
        // maxNativeZoom: rc.zoomLevel(),
        bounds: l.rc.getMaxBounds(),
        minZoom: l.config.mapMinZoom,
        maxZoom: l.config.mapMaxZoom
      });
    }, l.showMap = function(E) {
      l.log("showMap", E, l.loc), l.closeAssetInfo(), l.closeClusterInfo(), E !== l.loc.map ? (l.leaflet.maptile && l.leaflet.maptile.remove(l.map), l.leaflet.maptile = l.createTile(E + 1), l.leaflet.maptile.addTo(l.map), l.loc.map = E, l.map.setView(l.config.mapStart, l.config.mapStartZoom), l.zoomEndRender(), l.unselectRoom(), l.loc.poly && (l.loc.poly.remove(l.layer.room), l.loc.room = null), l.config.showAllAssets && l.send({
        srv: "plantquest",
        part: "assetmap",
        show: "asset",
        asset: null
      }), l.emit({
        srv: "plantquest",
        part: "assetmap",
        show: "map",
        map: l.loc.map,
        level: l.data.levels[l.loc.map]
      })) : l.map.setView(l.config.mapStart, l.config.mapStartZoom);
    }, l.resolveRoomColor = function(E, M) {
      return M === "hi" ? E.color : l.config.room.color;
    }, l.roomPopup = function(E, M) {
      let B = [];
      return B.push(
        "<h2>",
        E.room,
        "</h2>"
      ), B.join(`
`);
    }, l.getRoomAssets = function(E) {
      let M = [], X = l.data.deps.pc.room[E];
      return M = X && X.asset ? X.asset.map((K) => ({
        asset: K
      })) : M, M;
    }, l.getSeneca = function() {
      return sn(this, null, function* () {
        if (l.seneca != null)
          return l.seneca;
        let E = (D) => {
          let j = "/api/web/public/" + D.on;
          return l.config.endpoint + j;
        }, M = new Seneca({
          log: { logger: "flat", level: "warn" },
          plugin: {
            browser: {
              endpoint: E,
              headers: {
                Authorization: "Bearer " + l.config.apikey
              }
            }
          },
          timeout: 44444
        });
        M.test().use(SenecaEntity).ready(function() {
          return sn(this, null, function* () {
          });
        }), yield M.client({
          type: "browser",
          pin: [
            "aim:web",
            "aim:web,on:assetmap,get:info",
            "aim:web,on:assetmap,list:asset",
            "aim:web,on:assetmap,load:asset",
            "aim:web,on:assetmap,save:asset",
            "aim:web,on:assetmap,remove:asset",
            "aim:web,on:assetmap,list:room",
            "aim:web,on:assetmap,load:room",
            "aim:web,on:assetmap,save:room",
            "aim:web,on:assetmap,remove:room",
            "aim:web,on:assetmap,list:building",
            "aim:web,on:assetmap,load:building",
            "aim:web,on:assetmap,save:building",
            "aim:web,on:assetmap,remove:building",
            "aim:web,on:assetmap,list:geofence",
            "aim:web,on:assetmap,load:geofence",
            "aim:web,on:assetmap,save:geofence",
            "aim:web,on:assetmap,remove:geofence"
          ]
        });
        const B = M.fix("srv:plantquest,part:assetmap");
        B.message("cmd:reset", function(j) {
          return sn(this, null, function* () {
            l.map.setView(l.config.mapStart, l.config.mapStartZoom);
          });
        });
        let X = ["asset", "room", "building", "geofence"];
        for (let D of X)
          B.message("save:" + D, function(Z) {
            return sn(this, null, function* () {
              let tt = Z[D] || Z.item;
              tt = kn(Ge({}, tt), { project_id: l.config.project_id, plant_id: l.config.plant_id, stage: l.config.stage });
              let nt = yield this.post("aim:web,on:assetmap", { save: D, item: tt });
              return nt.ok && l.emit({
                srv: "plantquest",
                part: "assetmap",
                save: D,
                item: nt.item,
                [D]: nt.item
              }), nt;
            });
          }).message("load:" + D, function(Z) {
            return sn(this, null, function* () {
              const { id: tt } = Z;
              let nt = yield this.post("aim:web,on:assetmap", { load: D, id: tt });
              return nt.ok && l.emit({
                srv: "plantquest",
                part: "assetmap",
                load: D,
                [D]: nt.item
              }), nt;
            });
          }).message("list:" + D, function(Z) {
            return sn(this, null, function* () {
              let { query: tt } = Z;
              tt = tt || {
                project_id: l.config.project_id,
                plant_id: l.config.plant_id,
                stage: l.config.stage
              };
              let nt = yield this.post("aim:web,on:assetmap", { list: D, query: tt });
              return nt.ok && l.emit({
                srv: "plantquest",
                part: "assetmap",
                list: D,
                [D]: nt.list
              }), nt;
            });
          }).message("remove:" + D, function(Z) {
            return sn(this, null, function* () {
              let { id: tt } = Z, nt = yield this.post("aim:web,on:assetmap", { remove: D, id: tt });
              return nt.ok && l.emit({
                srv: "plantquest",
                part: "assetmap",
                remove: D,
                [D]: nt.item
              }), nt;
            });
          });
        B.message("show:map", function(D) {
          return sn(this, null, function* () {
            l.showMap(D.map);
          });
        }).message("show:room", function(D) {
          return sn(this, null, function* () {
            let j = l.data.roomMap[D.room];
            if (j) {
              if (D.assets && D.assets)
                for (let Z of D.assets)
                  l.showAsset(Z.asset, Z.state);
              D.focus && l.selectRoom(j.room, { mute: !0 });
            } else
              l.log("ERROR", "send", "room", "unknown-room", D);
          });
        }).message("show:plant", function(D) {
          return sn(this, null, function* () {
            l.showMap(D.plant);
          });
        }).message("show:floor", function(D) {
          return sn(this, null, function* () {
            l.showMap(D.map), l.clearRoomAssets(), l.unselectRoom(), l.map.setView(l.config.mapStart, l.config.mapStartZoom);
          });
        }).message("show:asset", K).message("hide:asset", K).message("relate:room-asset", function(D) {
          return sn(this, null, function* () {
            l.emit({
              srv: "plantquest",
              part: "assetmap",
              relate: "room-asset",
              relation: u(l.data.deps.pc.room)
            });
          });
        }).message("srv:plantquest,part:assetmap", function(D) {
          return sn(this, null, function* () {
          });
        }), yield M.ready();
        function K(D) {
          return sn(this, null, function* () {
            try {
              if (D.reset && (yield this.post("srv:plantquest,part:assetmap,cmd:reset")), Array.isArray(D.asset) || D.asset === null) {
                let j = Object.keys(l.data.assetMap), Z = D.asset || j, tt = D.asset === null, nt = D.state;
                for (let ct of D.only ? j : Z) {
                  let ut = l.data.assetMap[ct];
                  if (ut) {
                    let V = tt || Z.indexOf(ct) != -1;
                    V = D.asset === "hide" ? !V : V, V = ut.map - 1 == l.loc.map ? V : !1, setTimeout(() => {
                      l.showAsset(
                        ut.id,
                        nt,
                        !V,
                        !!D.blink,
                        !1,
                        !1
                      );
                    }, 11);
                  }
                }
              } else {
                let j = l.data.deps.cp.asset[D.asset], Z = l.data.assetMap[D.asset], tt = D.zoom || l.config.mapMaxZoom;
                if (j) {
                  l.emit({
                    srv: "plantquest",
                    part: "assetmap",
                    show: "asset",
                    before: !0,
                    focus: !!D.focus,
                    zoom: tt,
                    asset: Z
                  });
                  let nt = g({ x: Z.xco, y: Z.yco });
                  setTimeout(() => {
                    D.focus && l.map.setView(nt, tt);
                  }, 55);
                  let ct = D.infobox == null ? l.config.infobox.show : !!D.infobox, ut = Z.map;
                  if (ut != null) {
                    let V = +ut - 1;
                    V !== l.loc.map && l.showMap(V);
                  }
                  l.showAsset(
                    D.asset,
                    D.state,
                    D.hide === "asset",
                    !!D.blink,
                    !1,
                    ct
                  );
                } else
                  l.log("ERROR", "send", "asset", "unknown-asset", D);
              }
            } catch (j) {
              console.log("ERROR showAssetMsg", j);
            }
          });
        }
        return l.seneca = M;
      });
    }, l;
  }
  class r {
    constructor(E, M) {
      yr(this, "ent", null);
      yr(this, "ctx", null);
      yr(this, "cfgroom", null);
      this.ent = E, this.ctx = M, this.cfgroom = M.cfg.room;
    }
    buildPoly(E, M, B) {
      this.cfgroom.outline.active && (E.poly = L$1.polygon(
        M,
        {
          color: this.cfgroom.color
        }
      ), this.cfgroom.click.active && E.poly.on("click", this.onClick.bind(this)), E.poly.addTo(B));
    }
    onClick(E) {
      this.ctx.pqam.selectRoom(this.ent.id);
    }
  }
  function o() {
    return [
      '<div id="plantquest-assetmap-map" class="plantquest-assetmap-vis"></div>'
    ].join("");
  }
  function u(l) {
    return l != null && typeof l == "object" ? JSON.parse(JSON.stringify(l)) : l;
  }
  function a(l, E, M, B) {
    return E.length > 0 && Array.isArray(E[0]) ? y(l, E, M, B) : f(l, E, M, B);
  }
  function f(l, E, M, B) {
    let X = l[0], K = l[1], D = !1;
    M === void 0 && (M = 0), B === void 0 && (B = E.length);
    let j = (B - M) / 2;
    for (let Z = 0, tt = j - 1; Z < j; tt = Z++) {
      let nt = E[M + Z * 2 + 0], ct = E[M + Z * 2 + 1], ut = E[M + tt * 2 + 0], V = E[M + tt * 2 + 1];
      ct > K != V > K && X < (ut - nt) * (K - ct) / (V - ct) + nt && (D = !D);
    }
    return D;
  }
  function y(l, E, M, B) {
    let X = l[0], K = l[1], D = !1;
    M === void 0 && (M = 0), B === void 0 && (B = E.length);
    let j = B - M;
    for (let Z = 0, tt = j - 1; Z < j; tt = Z++) {
      let nt = E[Z + M][0], ct = E[Z + M][1], ut = E[tt + M][0], V = E[tt + M][1];
      ct > K != V > K && X < (ut - nt) * (K - ct) / (V - ct) + nt && (D = !D);
    }
    return D;
  }
  function T(l, E) {
    let M = [];
    for (let B of E)
      M.push(i.unproject({ x: B[1], y: l[1] - B[0] }));
    return M;
  }
  function h(l) {
    let E = i.project(l);
    return {
      xco: Math.floor(E.x),
      yco: Math.floor(E.y)
    };
  }
  function _(l, E) {
    return l[1] - E;
  }
  function g({ x: l, y: E }) {
    return i.unproject({ x: l, y: E });
  }
  function S(l, E) {
    return l.p.split(/~/g).map((M) => E[M]).join("~");
  }
  function d(l, E) {
    return l.p.split(/~/g).reduce((M, B) => (M[B] = E[B], M), {});
  }
  function b(l, E) {
    return E[l.c];
  }
  function k(l, E) {
    if (l instanceof Array) {
      for (let M = 0; M < l.length; M++) {
        if (l[M] === E)
          return;
        if (l[M] > E) {
          l.splice(M, 0, E);
          return;
        }
      }
      l.push(E);
    } else
      l instanceof Set && l.add(E);
  }
  function O(l) {
    let E = {
      "Room/Area": 1
    }, M = {
      cp: {},
      pc: {}
    }, B = [
      { pc: !0, p: "room", c: "asset", exclude: (tt) => E[tt.atype] },
      { pc: !0, p: "map", c: "building" },
      { pc: !0, p: "building", c: "level" },
      { pc: !0, p: "building", c: "map" },
      { pc: !0, p: "map~building", c: "level" },
      { pc: !0, p: "map~building~level", c: "room", include: (tt) => E[tt.atype] },
      { pc: !0, p: "building~level", c: "map" },
      { pc: !0, p: "map~level", c: "level", include: (tt) => tt.map },
      { cp: !0, p: "map~building~level", c: "room" },
      { cp: !0, p: "room", c: "asset", exclude: (tt) => E[tt.atype] }
    ], X = [], K = [], D = /* @__PURE__ */ new Set(), j = {}, Z = {};
    return Object.values(l).forEach((tt) => {
      tt.forEach((nt) => {
        E[nt.atype] ? (nt.room = nt.room || nt.name, Z[nt.room] = nt, Z[nt.id] = nt, nt.poly = nt.polygon.points) : (nt.asset = nt.id, nt.room = nt.room || nt.room_id, j[nt.id] = nt, nt.xco = nt.xco || nt.xval, nt.yco = nt.yco || nt.yval), nt.map = nt.map, nt.level = nt.level, nt.building = nt.building || nt.building_id, nt.level != null && nt.level !== "" && (K.includes(nt.level) || K.push(nt.level)), nt.building != null && nt.building !== "" && D.add(nt.building), nt.map != null && nt.map !== "" && (X.includes(nt.map) || X.push(nt.map)), B.forEach((ct) => {
          if (ct.cp && (!ct.exclude || !ct.exclude(nt)) && (!ct.include || ct.include(nt))) {
            let ut = d(ct, nt);
            M.cp[ct.c] = M.cp[ct.c] || {}, M.cp[ct.c][nt[ct.c]] = ut;
          }
          if (ct.pc && (!ct.exclude || !ct.exclude(nt)) && (!ct.include || ct.include(nt))) {
            let ut = S(ct, nt);
            M.pc[ct.p] = M.pc[ct.p] || {}, M.pc[ct.p][ut] = M.pc[ct.p][ut] || {}, M.pc[ct.p][ut][ct.c] = M.pc[ct.p][ut][ct.c] || [];
            let V = b(ct, nt);
            k(M.pc[ct.p][ut][ct.c], V);
          }
        });
      });
    }), D = Array.from(D), {
      deps: M,
      maps: X,
      levels: K,
      buildings: D,
      assetMap: j,
      roomMap: Z
    };
  }
  x.PlantQuestAssetMap = new s();
  function A() {
    const l = v("head"), E = document.createElement("style");
    E.innerHTML = `

#plantquest-assetmap {
    background-color: rgb(203,211,144);
}

#plantquest-assetmap-map {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: rgb(203,211,144);
}


div.plantquest-assetmap-vis {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1000;
}


img.plantquest-assetmap-logo {
    cursor: pointer;
}


div.plantquest-assetmap-asset-label {
    xwidth: 96px;
    xheight: 48px;
    font-size: 16px;
    xoverflow: hidden;
    z-index: 1000;
}

div.plantquest-assetmap-asset-cluster {
    xwidth: 96px;
    xheight: 48px;
    font-size: 16px;
    xoverflow: hidden;
    z-index: 1000;
}


div.plantquest-assetmap-asset-label-green {
    xcolor: #696;
    color: white;
    border: 2px solid #696;
    border-radius: 4px;
    background-color: rgba(102,153,102,0.8);
}

div.plantquest-assetmap-asset-label-red {
    xcolor: #f66;
    color: white;
    border: 2px solid #f66;
    border-radius: 4px;
    background-color: rgba(255,102,102,0.8);
}

#plantquest-assetmap-assetinfo {
    display: none;
}

#plantquest-assetmap-assetcluster {
    display: none;
}



/* 
 * Leaflet 1.8.0, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2022 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 * BSD 2-Clause License, See https://leafletjs.com/
 */

.leaflet-tile,.leaflet-zoom-anim .leaflet-zoom-hide{visibility:hidden}.leaflet-image-layer,.leaflet-layer,.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-pane,.leaflet-pane>canvas,.leaflet-pane>svg,.leaflet-tile,.leaflet-tile-container,.leaflet-zoom-box{position:absolute;left:0;top:0}.leaflet-container{overflow:hidden;-webkit-tap-highlight-color:transparent;background:#ddd;outline:0;font:12px/1.5 "Helvetica Neue",Arial,Helvetica,sans-serif}.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-tile{-webkit-user-select:none;-moz-user-select:none;user-select:none;-webkit-user-drag:none}.leaflet-overlay-pane svg,.leaflet-tooltip{-moz-user-select:none}.leaflet-tile::selection{background:0 0}.leaflet-safari .leaflet-tile{image-rendering:-webkit-optimize-contrast}.leaflet-safari .leaflet-tile-container{width:1600px;height:1600px;-webkit-transform-origin:0 0}.leaflet-control-layers label,.leaflet-marker-icon,.leaflet-marker-shadow{display:block}.leaflet-container .leaflet-marker-pane img,.leaflet-container .leaflet-overlay-pane svg,.leaflet-container .leaflet-shadow-pane img,.leaflet-container .leaflet-tile,.leaflet-container .leaflet-tile-pane img,.leaflet-container img.leaflet-image-layer{max-width:none!important;max-height:none!important}.leaflet-container.leaflet-touch-zoom{-ms-touch-action:pan-x pan-y;touch-action:pan-x pan-y}.leaflet-container.leaflet-touch-drag{-ms-touch-action:pinch-zoom;touch-action:none;touch-action:pinch-zoom}.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom{-ms-touch-action:none;touch-action:none}.leaflet-container a{-webkit-tap-highlight-color:rgba(51,181,229,0.4);color:#0078a8}.leaflet-tile{filter:inherit}.leaflet-tile-loaded{visibility:inherit}.leaflet-zoom-box{width:0;height:0;-moz-box-sizing:border-box;box-sizing:border-box;z-index:800}.leaflet-overlay-pane,.leaflet-pane{z-index:400}.leaflet-map-pane svg,.leaflet-tile-pane{z-index:200}.leaflet-shadow-pane{z-index:500}.leaflet-marker-pane{z-index:600}.leaflet-tooltip-pane{z-index:650}.leaflet-popup-pane{z-index:700}.leaflet-map-pane canvas{z-index:100}.leaflet-vml-shape{width:1px;height:1px}.lvml{behavior:url(#default#VML);display:inline-block;position:absolute}.leaflet-control{position:relative;z-index:800;pointer-events:visiblePainted;pointer-events:auto;float:left;clear:both}.leaflet-bottom,.leaflet-top{position:absolute;z-index:1000;pointer-events:none}.leaflet-top{top:0}.leaflet-right{right:0}.leaflet-bottom{bottom:0}.leaflet-left{left:0}.leaflet-right .leaflet-control{float:right;margin-right:10px}.leaflet-top .leaflet-control{margin-top:10px}.leaflet-bottom .leaflet-control{margin-bottom:10px}.leaflet-left .leaflet-control{margin-left:10px}.leaflet-fade-anim .leaflet-tile{will-change:opacity}.leaflet-fade-anim .leaflet-popup{opacity:0;-webkit-transition:opacity .2s linear;-moz-transition:opacity .2s linear;transition:opacity .2s linear}.leaflet-fade-anim .leaflet-map-pane .leaflet-popup{opacity:1}.leaflet-zoom-animated{-webkit-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0}.leaflet-zoom-anim .leaflet-zoom-animated{will-change:transform;-webkit-transition:-webkit-transform .25s cubic-bezier(0,0,.25,1);-moz-transition:-moz-transform .25s cubic-bezier(0,0,.25,1);transition:transform .25s cubic-bezier(0,0,.25,1)}.leaflet-pan-anim .leaflet-tile,.leaflet-zoom-anim .leaflet-tile{-webkit-transition:none;-moz-transition:none;transition:none}.leaflet-interactive{cursor:pointer}.leaflet-grab{cursor:-webkit-grab;cursor:-moz-grab;cursor:grab}.leaflet-crosshair,.leaflet-crosshair .leaflet-interactive{cursor:crosshair}.leaflet-control,.leaflet-popup-pane{cursor:auto}.leaflet-dragging .leaflet-grab,.leaflet-dragging .leaflet-grab .leaflet-interactive,.leaflet-dragging .leaflet-marker-draggable{cursor:move;cursor:-webkit-grabbing;cursor:-moz-grabbing;cursor:grabbing}.leaflet-image-layer,.leaflet-marker-icon,.leaflet-marker-shadow,.leaflet-pane>svg path,.leaflet-tile-container{pointer-events:none}.leaflet-image-layer.leaflet-interactive,.leaflet-marker-icon.leaflet-interactive,.leaflet-pane>svg path.leaflet-interactive,svg.leaflet-image-layer.leaflet-interactive path{pointer-events:visiblePainted;pointer-events:auto}.leaflet-container a.leaflet-active{outline:orange solid 2px}.leaflet-zoom-box{border:2px dotted #38f;background:rgba(255,255,255,.5)}.leaflet-bar{box-shadow:0 1px 5px rgba(0,0,0,.65);border-radius:4px}.leaflet-bar a,.leaflet-bar a:hover{background-color:#fff;border-bottom:1px solid #ccc;width:26px;height:26px;line-height:26px;display:block;text-align:center;text-decoration:none;color:#000}.leaflet-bar a,.leaflet-control-layers-toggle{background-position:50% 50%;background-repeat:no-repeat;display:block}.leaflet-bar a:hover{background-color:#f4f4f4}.leaflet-bar a:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.leaflet-bar a:last-child{border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-bottom:none}.leaflet-bar a.leaflet-disabled{cursor:default;background-color:#f4f4f4;color:#bbb}.leaflet-touch .leaflet-bar a{width:30px;height:30px;line-height:30px}.leaflet-touch .leaflet-bar a:first-child{border-top-left-radius:2px;border-top-right-radius:2px}.leaflet-touch .leaflet-bar a:last-child{border-bottom-left-radius:2px;border-bottom-right-radius:2px}.leaflet-control-zoom-in,.leaflet-control-zoom-out{font:bold 18px 'Lucida Console',Monaco,monospace;text-indent:1px}.leaflet-touch .leaflet-control-zoom-in,.leaflet-touch .leaflet-control-zoom-out{font-size:22px}.leaflet-control-layers{box-shadow:0 1px 5px rgba(0,0,0,.4);background:#fff;border-radius:5px}.leaflet-control-layers-toggle{background-image:url(images/layers.png);width:36px;height:36px}.leaflet-retina .leaflet-control-layers-toggle{background-image:url(images/layers-2x.png);background-size:26px 26px}.leaflet-touch .leaflet-control-layers-toggle{width:44px;height:44px}.leaflet-control-layers .leaflet-control-layers-list,.leaflet-control-layers-expanded .leaflet-control-layers-toggle{display:none}.leaflet-control-layers-expanded .leaflet-control-layers-list{display:block;position:relative}.leaflet-control-layers-expanded{padding:6px 10px 6px 6px;color:#333;background:#fff}.leaflet-control-layers-scrollbar{overflow-y:scroll;overflow-x:hidden;padding-right:5px}.leaflet-control-layers-selector{margin-top:2px;position:relative;top:1px}.leaflet-control-layers-separator{height:0;border-top:1px solid #ddd;margin:5px -10px 5px -6px}.leaflet-default-icon-path{background-image:url(images/marker-icon.png)}.leaflet-container .leaflet-control-attribution{background:rgba(255,255,255,.7);margin:0}.leaflet-control-attribution,.leaflet-control-scale-line{padding:0 5px;color:#333}.leaflet-control-attribution a{text-decoration:none}.leaflet-control-attribution a:hover{text-decoration:underline}.leaflet-container .leaflet-control-attribution,.leaflet-container .leaflet-control-scale{font-size:11px}.leaflet-left .leaflet-control-scale{margin-left:5px}.leaflet-bottom .leaflet-control-scale{margin-bottom:5px}.leaflet-control-scale-line{border:2px solid #777;border-top:none;line-height:1.1;padding:2px 5px 1px;font-size:11px;white-space:nowrap;overflow:hidden;-moz-box-sizing:border-box;box-sizing:border-box;background:rgba(255,255,255,.5)}.leaflet-control-scale-line:not(:first-child){border-top:2px solid #777;border-bottom:none;margin-top:-2px}.leaflet-control-scale-line:not(:first-child):not(:last-child){border-bottom:2px solid #777}.leaflet-touch .leaflet-bar,.leaflet-touch .leaflet-control-attribution,.leaflet-touch .leaflet-control-layers{box-shadow:none}.leaflet-touch .leaflet-bar,.leaflet-touch .leaflet-control-layers{border:2px solid rgba(0,0,0,.2);background-clip:padding-box}.leaflet-popup{position:absolute;text-align:center;margin-bottom:20px}.leaflet-popup-content-wrapper{padding:1px;text-align:left;border-radius:12px}.leaflet-popup-content{margin:13px 19px;line-height:1.4}.leaflet-popup-content p{margin:18px 0}.leaflet-popup-tip-container{width:40px;height:20px;position:absolute;left:50%;margin-left:-20px;overflow:hidden;pointer-events:none}.leaflet-popup-tip{width:17px;height:17px;padding:1px;margin:-10px auto 0;-webkit-transform:rotate(45deg);-moz-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg)}.leaflet-popup-content-wrapper,.leaflet-popup-tip{background:#fff;color:#333;box-shadow:0 3px 14px rgba(0,0,0,.4)}.leaflet-container a.leaflet-popup-close-button{position:absolute;top:0;right:0;padding:4px 4px 0 0;border:none;text-align:center;width:18px;height:14px;font:700 16px/14px Tahoma,Verdana,sans-serif;color:#c3c3c3;text-decoration:none;background:0 0}.leaflet-container a.leaflet-popup-close-button:hover{color:#999}.leaflet-popup-scrolled{overflow:auto;border-bottom:1px solid #ddd;border-top:1px solid #ddd}.leaflet-oldie .leaflet-popup-content-wrapper{-ms-zoom:1}.leaflet-oldie .leaflet-popup-tip{width:24px;margin:0 auto}.leaflet-oldie .leaflet-popup-tip-container{margin-top:-1px}.leaflet-oldie .leaflet-control-layers,.leaflet-oldie .leaflet-control-zoom,.leaflet-oldie .leaflet-popup-content-wrapper,.leaflet-oldie .leaflet-popup-tip{border:1px solid #999}.leaflet-div-icon{background:#fff;border:1px solid #666}.leaflet-tooltip{position:absolute;padding:6px;background-color:#fff;border:1px solid #fff;border-radius:3px;color:#222;white-space:nowrap;-webkit-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;box-shadow:0 1px 3px rgba(0,0,0,.4)}.leaflet-tooltip.leaflet-clickable{cursor:pointer;pointer-events:auto}.leaflet-tooltip-bottom:before,.leaflet-tooltip-left:before,.leaflet-tooltip-right:before,.leaflet-tooltip-top:before{position:absolute;pointer-events:none;border:6px solid transparent;background:0 0;content:""}.leaflet-tooltip-bottom{margin-top:6px}.leaflet-tooltip-top{margin-top:-6px}.leaflet-tooltip-bottom:before,.leaflet-tooltip-top:before{left:50%;margin-left:-6px}.leaflet-tooltip-top:before{bottom:0;margin-bottom:-12px;border-top-color:#fff}.leaflet-tooltip-bottom:before{top:0;margin-top:-12px;margin-left:-6px;border-bottom-color:#fff}.leaflet-tooltip-left{margin-left:-6px}.leaflet-tooltip-right{margin-left:6px}.leaflet-tooltip-left:before,.leaflet-tooltip-right:before{top:50%;margin-top:-6px}.leaflet-tooltip-left:before{right:0;margin-right:-12px;border-left-color:#fff}.leaflet-tooltip-right:before{left:0;margin-left:-12px;border-right-color:#fff}

/* MIT LICENSE, Copyright (c) 2014-2015, Justin Manley */
.leaflet-toolbar-0{list-style:none;padding-left:0;border:2px solid rgba(0,0,0,.2);border-radius:4px}.leaflet-toolbar-0>li{position:relative}.leaflet-toolbar-0>li>.leaflet-toolbar-icon{display:block;width:30px;height:30px;line-height:30px;margin-right:0;padding-right:0;border-right:0;text-align:center;text-decoration:none;background-color:#fff}.leaflet-toolbar-0>li>.leaflet-toolbar-icon:hover{background-color:#f4f4f4}.leaflet-toolbar-0 .leaflet-toolbar-1{display:none;list-style:none}.leaflet-toolbar-tip-container{margin:-16px auto 0;height:16px;position:relative;overflow:hidden}.leaflet-toolbar-tip{width:16px;height:16px;margin:-8px auto 0;background-color:#fff;border:2px solid rgba(0,0,0,.2);background-clip:content-box;-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);transform:rotate(45deg);border-radius:4px}.leaflet-control-toolbar .leaflet-toolbar-1>li:last-child>.leaflet-toolbar-icon,.leaflet-popup-toolbar>li:last-child>.leaflet-toolbar-icon{border-top-right-radius:4px;border-bottom-right-radius:4px}.leaflet-control-toolbar>li>.leaflet-toolbar-icon{border-bottom:1px solid #ccc}.leaflet-control-toolbar>li:first-child>.leaflet-toolbar-icon{border-top-left-radius:4px;border-top-right-radius:4px}.leaflet-control-toolbar>li:last-child>.leaflet-toolbar-icon{border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-bottom-width:0}.leaflet-control-toolbar .leaflet-toolbar-1{margin:0;padding:0;position:absolute;left:30px;top:0;white-space:nowrap;height:30px}.leaflet-control-toolbar .leaflet-toolbar-1>li{display:inline-block}.leaflet-control-toolbar .leaflet-toolbar-1>li>.leaflet-toolbar-icon{display:block;background-color:#919187;border-left:1px solid #aaa;color:#fff;font:11px/19px "Helvetica Neue",Arial,Helvetica,sans-serif;line-height:30px;text-decoration:none;padding-left:10px;padding-right:10px;height:30px}.leaflet-control-toolbar .leaflet-toolbar-1>li>.leaflet-toolbar-icon:hover{background-color:#a0a098}.leaflet-popup-toolbar{position:relative;box-sizing:content-box}.leaflet-popup-toolbar>li{float:left}.leaflet-popup-toolbar>li>.leaflet-toolbar-icon{border-right:1px solid #ccc}.leaflet-popup-toolbar>li:first-child>.leaflet-toolbar-icon{border-top-left-radius:4px;border-bottom-left-radius:4px}.leaflet-popup-toolbar>li:last-child>.leaflet-toolbar-icon{border-bottom-width:0;border-right:none}.leaflet-popup-toolbar .leaflet-toolbar-1{position:absolute;top:30px;left:0;padding-left:0}.leaflet-popup-toolbar .leaflet-toolbar-1>li>.leaflet-toolbar-icon{position:relative;float:left;width:30px;height:30px}
.marker-cluster-small {
	background-color: rgba(181, 226, 140, 0.6);
	}
.marker-cluster-small div {
	background-color: rgba(110, 204, 57, 0.6);
	}

.marker-cluster-medium {
	background-color: rgba(241, 211, 87, 0.6);
	}
.marker-cluster-medium div {
	background-color: rgba(240, 194, 12, 0.6);
	}

.marker-cluster-large {
	background-color: rgba(253, 156, 115, 0.6);
	}
.marker-cluster-large div {
	background-color: rgba(241, 128, 23, 0.6);
	}

	/* IE 6-8 fallback colors */
.leaflet-oldie .marker-cluster-small {
	background-color: rgb(181, 226, 140);
	}
.leaflet-oldie .marker-cluster-small div {
	background-color: rgb(110, 204, 57);
	}

.leaflet-oldie .marker-cluster-medium {
	background-color: rgb(241, 211, 87);
	}
.leaflet-oldie .marker-cluster-medium div {
	background-color: rgb(240, 194, 12);
	}

.leaflet-oldie .marker-cluster-large {
	background-color: rgb(253, 156, 115);
	}
.leaflet-oldie .marker-cluster-large div {
	background-color: rgb(241, 128, 23);
}

.marker-cluster {
	background-clip: padding-box;
	border-radius: 20px;
	}
.marker-cluster div {
	width: 30px;
	height: 30px;
	margin-left: 5px;
	margin-top: 5px;

	text-align: center;
	border-radius: 15px;
	font: 12px "Helvetica Neue", Arial, Helvetica, sans-serif;
	}
.marker-cluster span {
	line-height: 30px;
	}
.leaflet-cluster-anim .leaflet-marker-icon, .leaflet-cluster-anim .leaflet-marker-shadow {
	-webkit-transition: -webkit-transform 0.3s ease-out, opacity 0.3s ease-in;
	-moz-transition: -moz-transform 0.3s ease-out, opacity 0.3s ease-in;
	-o-transition: -o-transform 0.3s ease-out, opacity 0.3s ease-in;
	transition: transform 0.3s ease-out, opacity 0.3s ease-in;
}

.leaflet-cluster-spider-leg {
	/* stroke-dashoffset (duration and function) should match with leaflet-marker-icon transform in order to track it exactly */
	-webkit-transition: -webkit-stroke-dashoffset 0.3s ease-out, -webkit-stroke-opacity 0.3s ease-in;
	-moz-transition: -moz-stroke-dashoffset 0.3s ease-out, -moz-stroke-opacity 0.3s ease-in;
	-o-transition: -o-stroke-dashoffset 0.3s ease-out, -o-stroke-opacity 0.3s ease-in;
	transition: stroke-dashoffset 0.3s ease-out, stroke-opacity 0.3s ease-in;
}


.leaflet-toolbar-0>li>.leaflet-toolbar-icon {
  width: 80px;
}

.control-panel {
  position: absolute;
  top: 0em;
  left: 5em;
  background-color: white;
  border: 1px solid black;
  width: 10em;
  height: 6em;
  padding: 10px;
  font-size: 14px;
  font-family: Arial, sans-serif;
  word-wrap: break-word;
  height: fit-content;
  width: fit-content;
  opacity: 0.5;
  /*block-size: fit-content;*/
}


.class1 {
    background-color: transparent;
    border: 0;
    box-shadow: none;
} 

.polygon-labels {
  background-color: transparent;
  font-weight: bold;
  color: #000000;
  border: 0;
  box-shadow: none;
  font-size: 1em;
}

div.plantquest-assetmap-asset-label {
    width: 200px;
}

div.plantquest-assetmap-asset-marker {

}


div.plantquest-assetmap-asset-state-up {
    color: white;
    border: 2px solid #696;
    border-radius: 4px;
    background-color: #696;
    opacity: 0;
}

div.plantquest-assetmap-asset-state-down {
    color: white;
    border: 2px solid #666;
    border-radius: 4px;
    background-color: #666;
    opacity: 0.7;
}

div.plantquest-assetmap-asset-state-missing {
    color: white;
    border: 2px solid #f3f;
    border-radius: 4px;
    background-color: #f3f;
    opacity: 0.7;
}

div.plantquest-assetmap-asset-state-alarm {
    color: white;
    border: 2px solid #f33;
    border-radius: 4px;
    background-color: #f33;
    opacity: 0.7;
}




`, l.appendChild(E);
  }
})(window, document);
